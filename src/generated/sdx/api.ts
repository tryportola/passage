/* tslint:disable */
/* eslint-disable */
/**
 * Passage SDX - Secure Document Exchange API
 * **Blind Vault API for Encrypted Document Storage**  The SDX (Secure Document Exchange) service provides a secure, encrypted blob storage system for sensitive loan documents and KYC materials. SDX operates as a \"blind vault\" - it never decrypts or examines document contents.  ## Authentication  All SDX endpoints require JWT authentication tokens issued by the Passage API. Tokens are short-lived (10-minute TTL) and grant either `upload` or `download` permissions.  To obtain an SDX token: 1. Call `POST /sdx-tokens` on the Passage API 2. Receive a JWT token and SDX service URL 3. Use the JWT to authenticate requests to SDX endpoints  ## Workflow  ### Upload Workflow ``` 1. SDK → Passage API: POST /sdx-tokens (action: upload) 2. Passage API → SDK: Returns { jwt, sdxUrl, tokenId } 3. SDK → SDX: POST /sdx/blobs with JWT + encrypted blob 4. SDX → SDK: Returns { documentHandle, expiresAt } 5. SDK → Passage API: POST /sdx-tokens/kyc-handle to register handle ```  ### Download Workflow ``` 1. SDK → Passage API: POST /sdx-tokens (action: download, documentHandle) 2. Passage API → SDK: Returns { jwt, sdxUrl } 3. SDK → SDX: GET /sdx/blobs/{documentHandle} with JWT 4. SDX → SDK: Returns encrypted blob (binary) ```  ## Security Features  - **JWT Authentication**: All requests require valid JWT tokens - **Rate Limiting**:   - Global: 100 requests per minute per IP (all routes)   - Health checks: 30 requests per minute per IP (health endpoints only) - **Content Deduplication**: Identical blobs return existing handles - **Idempotency**: Use `Idempotency-Key` header to prevent duplicate uploads - **Constant-Time Responses**: Prevents timing attacks - **Audit Logging**: All operations are logged with actor/application context  ## Binary Data  All document uploads and downloads use `application/octet-stream` content type. Documents are stored and retrieved as opaque binary blobs. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@tryportola.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Error code identifier
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * Optional additional error details
     * @type {{ [key: string]: any; }}
     * @memberof ErrorResponse
     */
    'details'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface HealthCheckResponse
 */
export interface HealthCheckResponse {
    /**
     * Overall health status
     * @type {string}
     * @memberof HealthCheckResponse
     */
    'status': HealthCheckResponseStatusEnum;
    /**
     * Current server time
     * @type {string}
     * @memberof HealthCheckResponse
     */
    'timestamp': string;
    /**
     * Server uptime in seconds
     * @type {number}
     * @memberof HealthCheckResponse
     */
    'uptime': number;
    /**
     * 
     * @type {HealthCheckResponseChecks}
     * @memberof HealthCheckResponse
     */
    'checks'?: HealthCheckResponseChecks;
    /**
     * Error message if unhealthy
     * @type {string}
     * @memberof HealthCheckResponse
     */
    'error'?: string;
}

export const HealthCheckResponseStatusEnum = {
    Healthy: 'healthy',
    Unhealthy: 'unhealthy'
} as const;

export type HealthCheckResponseStatusEnum = typeof HealthCheckResponseStatusEnum[keyof typeof HealthCheckResponseStatusEnum];

/**
 * Individual health check results
 * @export
 * @interface HealthCheckResponseChecks
 */
export interface HealthCheckResponseChecks {
    /**
     * Database connectivity status
     * @type {boolean}
     * @memberof HealthCheckResponseChecks
     */
    'database'?: boolean;
    /**
     * Storage backend connectivity status
     * @type {boolean}
     * @memberof HealthCheckResponseChecks
     */
    'storage'?: boolean;
}
/**
 * 
 * @export
 * @interface LivenessCheck200Response
 */
export interface LivenessCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof LivenessCheck200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ReadinessCheck200Response
 */
export interface ReadinessCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof ReadinessCheck200Response
     */
    'status'?: string;
    /**
     * 
     * @type {ReadinessCheck200ResponseChecks}
     * @memberof ReadinessCheck200Response
     */
    'checks'?: ReadinessCheck200ResponseChecks;
}
/**
 * 
 * @export
 * @interface ReadinessCheck200ResponseChecks
 */
export interface ReadinessCheck200ResponseChecks {
    /**
     * 
     * @type {boolean}
     * @memberof ReadinessCheck200ResponseChecks
     */
    'database'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReadinessCheck200ResponseChecks
     */
    'storage'?: boolean;
}
/**
 * 
 * @export
 * @interface ReadinessCheck503Response
 */
export interface ReadinessCheck503Response {
    /**
     * 
     * @type {string}
     * @memberof ReadinessCheck503Response
     */
    'status'?: string;
    /**
     * 
     * @type {ReadinessCheck503ResponseChecks}
     * @memberof ReadinessCheck503Response
     */
    'checks'?: ReadinessCheck503ResponseChecks;
}
/**
 * 
 * @export
 * @interface ReadinessCheck503ResponseChecks
 */
export interface ReadinessCheck503ResponseChecks {
    /**
     * 
     * @type {boolean}
     * @memberof ReadinessCheck503ResponseChecks
     */
    'database'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReadinessCheck503ResponseChecks
     */
    'storage'?: boolean;
}
/**
 * 
 * @export
 * @interface UploadBlob201Response
 */
export interface UploadBlob201Response {
    /**
     * Unique document handle for retrieval (96 hex characters)
     * @type {string}
     * @memberof UploadBlob201Response
     */
    'documentHandle': string;
    /**
     * ISO 8601 timestamp when document handle expires
     * @type {string}
     * @memberof UploadBlob201Response
     */
    'expiresAt': string;
    /**
     * Size of uploaded blob in bytes
     * @type {number}
     * @memberof UploadBlob201Response
     */
    'blobSize'?: number;
    /**
     * True if an identical blob was previously uploaded
     * @type {boolean}
     * @memberof UploadBlob201Response
     */
    'duplicate'?: boolean;
}
/**
 * 
 * @export
 * @interface UploadResponse
 */
export interface UploadResponse {
    /**
     * Unique document handle (96 hex characters)
     * @type {string}
     * @memberof UploadResponse
     */
    'documentHandle': string;
    /**
     * ISO 8601 expiration timestamp
     * @type {string}
     * @memberof UploadResponse
     */
    'expiresAt': string;
    /**
     * Size of uploaded blob in bytes
     * @type {number}
     * @memberof UploadResponse
     */
    'blobSize'?: number;
    /**
     * True if content was already uploaded
     * @type {boolean}
     * @memberof UploadResponse
     */
    'duplicate'?: boolean;
}

/**
 * BlobsApi - axios parameter creator
 * @export
 */
export const BlobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Download a previously uploaded encrypted blob using its document handle.  **Authentication**: Requires JWT token with `action: \"download\"`  **Security**: The JWT token must contain the exact document handle being requested. This prevents unauthorized access to other documents.  **Expiration**: Document handles expire after a configurable TTL (default: 72 hours). Expired handles return HTTP 410 Gone.  **One-Time Retrieval**: After successful download, the document status changes to \"RETRIEVED\". However, the document remains accessible until expiration. 
         * @summary Download encrypted blob
         * @param {string} documentHandle Document handle returned from upload endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBlob: async (documentHandle: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentHandle' is not null or undefined
            assertParamExists('downloadBlob', 'documentHandle', documentHandle)
            const localVarPath = `/sdx/blobs/{documentHandle}`
                .replace(`{${"documentHandle"}}`, encodeURIComponent(String(documentHandle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload an encrypted binary blob to SDX storage.  **Authentication**: Requires JWT token with `action: \"upload\"`  **Deduplication**: If an identical blob (same content hash) was previously uploaded for the same application, the existing document handle is returned without creating a duplicate.  **Idempotency**: Include an `Idempotency-Key` header to prevent duplicate uploads due to network retries. If a request with the same idempotency key is repeated, the original response is returned.  **Limitations**: - Maximum blob size: 100MB (configurable) - Content-Type must be `application/octet-stream` - Content-Length header is required 
         * @summary Upload encrypted blob
         * @param {number} contentLength Size of the blob in bytes (required)
         * @param {File} body Binary blob data (encrypted document)
         * @param {string} [xDocumentType] Optional document type hint for audit logging. Examples: \&quot;kyc_document\&quot;, \&quot;unsigned_contract\&quot;, \&quot;signed_contract\&quot; 
         * @param {string} [idempotencyKey] Optional idempotency key (16-128 characters) to prevent duplicate uploads. If provided, identical requests will return the same document handle. 
         * @param {string} [userAgent] Optional client identifier for audit logging. Will be sanitized to remove potentially malicious content. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBlob: async (contentLength: number, body: File, xDocumentType?: string, idempotencyKey?: string, userAgent?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentLength' is not null or undefined
            assertParamExists('uploadBlob', 'contentLength', contentLength)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadBlob', 'body', body)
            const localVarPath = `/sdx/blobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            if (xDocumentType != null) {
                localVarHeaderParameter['X-Document-Type'] = String(xDocumentType);
            }
            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }
            if (contentLength != null) {
                localVarHeaderParameter['Content-Length'] = typeof contentLength === 'string'
                    ? contentLength
                    : JSON.stringify(contentLength);
            }
            if (userAgent != null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlobsApi - functional programming interface
 * @export
 */
export const BlobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlobsApiAxiosParamCreator(configuration)
    return {
        /**
         * Download a previously uploaded encrypted blob using its document handle.  **Authentication**: Requires JWT token with `action: \"download\"`  **Security**: The JWT token must contain the exact document handle being requested. This prevents unauthorized access to other documents.  **Expiration**: Document handles expire after a configurable TTL (default: 72 hours). Expired handles return HTTP 410 Gone.  **One-Time Retrieval**: After successful download, the document status changes to \"RETRIEVED\". However, the document remains accessible until expiration. 
         * @summary Download encrypted blob
         * @param {string} documentHandle Document handle returned from upload endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadBlob(documentHandle: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadBlob(documentHandle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlobsApi.downloadBlob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload an encrypted binary blob to SDX storage.  **Authentication**: Requires JWT token with `action: \"upload\"`  **Deduplication**: If an identical blob (same content hash) was previously uploaded for the same application, the existing document handle is returned without creating a duplicate.  **Idempotency**: Include an `Idempotency-Key` header to prevent duplicate uploads due to network retries. If a request with the same idempotency key is repeated, the original response is returned.  **Limitations**: - Maximum blob size: 100MB (configurable) - Content-Type must be `application/octet-stream` - Content-Length header is required 
         * @summary Upload encrypted blob
         * @param {number} contentLength Size of the blob in bytes (required)
         * @param {File} body Binary blob data (encrypted document)
         * @param {string} [xDocumentType] Optional document type hint for audit logging. Examples: \&quot;kyc_document\&quot;, \&quot;unsigned_contract\&quot;, \&quot;signed_contract\&quot; 
         * @param {string} [idempotencyKey] Optional idempotency key (16-128 characters) to prevent duplicate uploads. If provided, identical requests will return the same document handle. 
         * @param {string} [userAgent] Optional client identifier for audit logging. Will be sanitized to remove potentially malicious content. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadBlob(contentLength: number, body: File, xDocumentType?: string, idempotencyKey?: string, userAgent?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadBlob201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadBlob(contentLength, body, xDocumentType, idempotencyKey, userAgent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlobsApi.uploadBlob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlobsApi - factory interface
 * @export
 */
export const BlobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlobsApiFp(configuration)
    return {
        /**
         * Download a previously uploaded encrypted blob using its document handle.  **Authentication**: Requires JWT token with `action: \"download\"`  **Security**: The JWT token must contain the exact document handle being requested. This prevents unauthorized access to other documents.  **Expiration**: Document handles expire after a configurable TTL (default: 72 hours). Expired handles return HTTP 410 Gone.  **One-Time Retrieval**: After successful download, the document status changes to \"RETRIEVED\". However, the document remains accessible until expiration. 
         * @summary Download encrypted blob
         * @param {BlobsApiDownloadBlobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBlob(requestParameters: BlobsApiDownloadBlobRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadBlob(requestParameters.documentHandle, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload an encrypted binary blob to SDX storage.  **Authentication**: Requires JWT token with `action: \"upload\"`  **Deduplication**: If an identical blob (same content hash) was previously uploaded for the same application, the existing document handle is returned without creating a duplicate.  **Idempotency**: Include an `Idempotency-Key` header to prevent duplicate uploads due to network retries. If a request with the same idempotency key is repeated, the original response is returned.  **Limitations**: - Maximum blob size: 100MB (configurable) - Content-Type must be `application/octet-stream` - Content-Length header is required 
         * @summary Upload encrypted blob
         * @param {BlobsApiUploadBlobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBlob(requestParameters: BlobsApiUploadBlobRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadBlob201Response> {
            return localVarFp.uploadBlob(requestParameters.contentLength, requestParameters.body, requestParameters.xDocumentType, requestParameters.idempotencyKey, requestParameters.userAgent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlobsApi - interface
 * @export
 * @interface BlobsApi
 */
export interface BlobsApiInterface {
    /**
     * Download a previously uploaded encrypted blob using its document handle.  **Authentication**: Requires JWT token with `action: \"download\"`  **Security**: The JWT token must contain the exact document handle being requested. This prevents unauthorized access to other documents.  **Expiration**: Document handles expire after a configurable TTL (default: 72 hours). Expired handles return HTTP 410 Gone.  **One-Time Retrieval**: After successful download, the document status changes to \"RETRIEVED\". However, the document remains accessible until expiration. 
     * @summary Download encrypted blob
     * @param {BlobsApiDownloadBlobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlobsApiInterface
     */
    downloadBlob(requestParameters: BlobsApiDownloadBlobRequest, options?: RawAxiosRequestConfig): AxiosPromise<File>;

    /**
     * Upload an encrypted binary blob to SDX storage.  **Authentication**: Requires JWT token with `action: \"upload\"`  **Deduplication**: If an identical blob (same content hash) was previously uploaded for the same application, the existing document handle is returned without creating a duplicate.  **Idempotency**: Include an `Idempotency-Key` header to prevent duplicate uploads due to network retries. If a request with the same idempotency key is repeated, the original response is returned.  **Limitations**: - Maximum blob size: 100MB (configurable) - Content-Type must be `application/octet-stream` - Content-Length header is required 
     * @summary Upload encrypted blob
     * @param {BlobsApiUploadBlobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlobsApiInterface
     */
    uploadBlob(requestParameters: BlobsApiUploadBlobRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadBlob201Response>;

}

/**
 * Request parameters for downloadBlob operation in BlobsApi.
 * @export
 * @interface BlobsApiDownloadBlobRequest
 */
export interface BlobsApiDownloadBlobRequest {
    /**
     * Document handle returned from upload endpoint
     * @type {string}
     * @memberof BlobsApiDownloadBlob
     */
    readonly documentHandle: string
}

/**
 * Request parameters for uploadBlob operation in BlobsApi.
 * @export
 * @interface BlobsApiUploadBlobRequest
 */
export interface BlobsApiUploadBlobRequest {
    /**
     * Size of the blob in bytes (required)
     * @type {number}
     * @memberof BlobsApiUploadBlob
     */
    readonly contentLength: number

    /**
     * Binary blob data (encrypted document)
     * @type {File}
     * @memberof BlobsApiUploadBlob
     */
    readonly body: File

    /**
     * Optional document type hint for audit logging. Examples: \&quot;kyc_document\&quot;, \&quot;unsigned_contract\&quot;, \&quot;signed_contract\&quot; 
     * @type {string}
     * @memberof BlobsApiUploadBlob
     */
    readonly xDocumentType?: string

    /**
     * Optional idempotency key (16-128 characters) to prevent duplicate uploads. If provided, identical requests will return the same document handle. 
     * @type {string}
     * @memberof BlobsApiUploadBlob
     */
    readonly idempotencyKey?: string

    /**
     * Optional client identifier for audit logging. Will be sanitized to remove potentially malicious content. 
     * @type {string}
     * @memberof BlobsApiUploadBlob
     */
    readonly userAgent?: string
}

/**
 * BlobsApi - object-oriented interface
 * @export
 * @class BlobsApi
 * @extends {BaseAPI}
 */
export class BlobsApi extends BaseAPI implements BlobsApiInterface {
    /**
     * Download a previously uploaded encrypted blob using its document handle.  **Authentication**: Requires JWT token with `action: \"download\"`  **Security**: The JWT token must contain the exact document handle being requested. This prevents unauthorized access to other documents.  **Expiration**: Document handles expire after a configurable TTL (default: 72 hours). Expired handles return HTTP 410 Gone.  **One-Time Retrieval**: After successful download, the document status changes to \"RETRIEVED\". However, the document remains accessible until expiration. 
     * @summary Download encrypted blob
     * @param {BlobsApiDownloadBlobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlobsApi
     */
    public downloadBlob(requestParameters: BlobsApiDownloadBlobRequest, options?: RawAxiosRequestConfig) {
        return BlobsApiFp(this.configuration).downloadBlob(requestParameters.documentHandle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload an encrypted binary blob to SDX storage.  **Authentication**: Requires JWT token with `action: \"upload\"`  **Deduplication**: If an identical blob (same content hash) was previously uploaded for the same application, the existing document handle is returned without creating a duplicate.  **Idempotency**: Include an `Idempotency-Key` header to prevent duplicate uploads due to network retries. If a request with the same idempotency key is repeated, the original response is returned.  **Limitations**: - Maximum blob size: 100MB (configurable) - Content-Type must be `application/octet-stream` - Content-Length header is required 
     * @summary Upload encrypted blob
     * @param {BlobsApiUploadBlobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlobsApi
     */
    public uploadBlob(requestParameters: BlobsApiUploadBlobRequest, options?: RawAxiosRequestConfig) {
        return BlobsApiFp(this.configuration).uploadBlob(requestParameters.contentLength, requestParameters.body, requestParameters.xDocumentType, requestParameters.idempotencyKey, requestParameters.userAgent, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Basic health check endpoint that returns service status.  **Authentication**: Not required (public endpoint)  This endpoint checks: - Service availability - Database connectivity - Storage backend connectivity 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kubernetes liveness probe endpoint. Returns 200 if process is alive.  **Authentication**: Not required (public endpoint) 
         * @summary Liveness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        livenessCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveness`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kubernetes readiness probe endpoint. Returns 200 if service is ready to accept traffic.  **Authentication**: Not required (public endpoint) 
         * @summary Readiness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readinessCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/readiness`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Basic health check endpoint that returns service status.  **Authentication**: Not required (public endpoint)  This endpoint checks: - Service availability - Database connectivity - Storage backend connectivity 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kubernetes liveness probe endpoint. Returns 200 if process is alive.  **Authentication**: Not required (public endpoint) 
         * @summary Liveness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async livenessCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LivenessCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.livenessCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.livenessCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kubernetes readiness probe endpoint. Returns 200 if service is ready to accept traffic.  **Authentication**: Not required (public endpoint) 
         * @summary Readiness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readinessCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadinessCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readinessCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.readinessCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Basic health check endpoint that returns service status.  **Authentication**: Not required (public endpoint)  This endpoint checks: - Service availability - Database connectivity - Storage backend connectivity 
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: RawAxiosRequestConfig): AxiosPromise<HealthCheckResponse> {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Kubernetes liveness probe endpoint. Returns 200 if process is alive.  **Authentication**: Not required (public endpoint) 
         * @summary Liveness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        livenessCheck(options?: RawAxiosRequestConfig): AxiosPromise<LivenessCheck200Response> {
            return localVarFp.livenessCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Kubernetes readiness probe endpoint. Returns 200 if service is ready to accept traffic.  **Authentication**: Not required (public endpoint) 
         * @summary Readiness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readinessCheck(options?: RawAxiosRequestConfig): AxiosPromise<ReadinessCheck200Response> {
            return localVarFp.readinessCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - interface
 * @export
 * @interface HealthApi
 */
export interface HealthApiInterface {
    /**
     * Basic health check endpoint that returns service status.  **Authentication**: Not required (public endpoint)  This endpoint checks: - Service availability - Database connectivity - Storage backend connectivity 
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    healthCheck(options?: RawAxiosRequestConfig): AxiosPromise<HealthCheckResponse>;

    /**
     * Kubernetes liveness probe endpoint. Returns 200 if process is alive.  **Authentication**: Not required (public endpoint) 
     * @summary Liveness probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    livenessCheck(options?: RawAxiosRequestConfig): AxiosPromise<LivenessCheck200Response>;

    /**
     * Kubernetes readiness probe endpoint. Returns 200 if service is ready to accept traffic.  **Authentication**: Not required (public endpoint) 
     * @summary Readiness probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    readinessCheck(options?: RawAxiosRequestConfig): AxiosPromise<ReadinessCheck200Response>;

}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI implements HealthApiInterface {
    /**
     * Basic health check endpoint that returns service status.  **Authentication**: Not required (public endpoint)  This endpoint checks: - Service availability - Database connectivity - Storage backend connectivity 
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kubernetes liveness probe endpoint. Returns 200 if process is alive.  **Authentication**: Not required (public endpoint) 
     * @summary Liveness probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public livenessCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).livenessCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kubernetes readiness probe endpoint. Returns 200 if service is ready to accept traffic.  **Authentication**: Not required (public endpoint) 
     * @summary Readiness probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public readinessCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).readinessCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



