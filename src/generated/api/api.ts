/* tslint:disable */
/* eslint-disable */
/**
 * Passage by Portola - Public API
 * Public API for Neobanks and Lenders - Global Distribution System for Loans. A pure technology provider facilitating secure loan application routing between stablecoin neobanks/wallets and US-based lenders.  ## Key Principles - **Blind Conduit**: All PII data is end-to-end encrypted - **Broadcast RFQ**: Applications are broadcast to all eligible lenders - **Agnostic Presentation**: Offers returned without ranking or filtering  ## Note This specification is for public-facing endpoints only. Admin endpoints are documented separately and are not included in the public SDK. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@tryportola.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * All wallets data
 * @export
 * @interface AllWalletsData
 */
export interface AllWalletsData {
    /**
     * 
     * @type {MainWallet}
     * @memberof AllWalletsData
     */
    'mainWallet'?: MainWallet | null;
    /**
     * 
     * @type {Array<LoanWallet>}
     * @memberof AllWalletsData
     */
    'loanWallets'?: Array<LoanWallet>;
    /**
     * 
     * @type {WalletAggregate}
     * @memberof AllWalletsData
     */
    'aggregate'?: WalletAggregate;
    /**
     * 
     * @type {InfraStats}
     * @memberof AllWalletsData
     */
    'infraStats'?: InfraStats;
}
/**
 * All wallets response
 * @export
 * @interface AllWalletsResponse
 */
export interface AllWalletsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof AllWalletsResponse
     */
    'success': boolean;
    /**
     * 
     * @type {AllWalletsData}
     * @memberof AllWalletsResponse
     */
    'data': AllWalletsData;
    /**
     * 
     * @type {string}
     * @memberof AllWalletsResponse
     */
    'fetchedAt': string;
}
/**
 * 
 * @export
 * @interface ApplicationListItem
 */
export interface ApplicationListItem {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof ApplicationListItem
     */
    'id': string;
    /**
     * 
     * @type {ApplicationStatus}
     * @memberof ApplicationListItem
     */
    'status': ApplicationStatus;
    /**
     * Type of loan product
     * @type {string}
     * @memberof ApplicationListItem
     */
    'productType': ApplicationListItemProductTypeEnum;
    /**
     * Non-PII metadata
     * @type {{ [key: string]: any; }}
     * @memberof ApplicationListItem
     */
    'metadata'?: { [key: string]: any; };
    /**
     * ID of the neobank (neobank list only)
     * @type {string}
     * @memberof ApplicationListItem
     */
    'neobankId'?: string;
    /**
     * External reference ID (neobank list only)
     * @type {string}
     * @memberof ApplicationListItem
     */
    'externalId'?: string;
    /**
     * When application was created (neobank list only)
     * @type {string}
     * @memberof ApplicationListItem
     */
    'createdAt'?: string;
    /**
     * When application was routed to this lender (lender list only)
     * @type {string}
     * @memberof ApplicationListItem
     */
    'routedAt'?: string;
}

export const ApplicationListItemProductTypeEnum = {
    Consumer: 'consumer',
    Auto: 'auto',
    Mortgage: 'mortgage',
    Personal: 'personal',
    Business: 'business'
} as const;

export type ApplicationListItemProductTypeEnum = typeof ApplicationListItemProductTypeEnum[keyof typeof ApplicationListItemProductTypeEnum];

/**
 * 
 * @export
 * @interface ApplicationRequest
 */
export interface ApplicationRequest {
    /**
     * Neobank\'s external reference ID
     * @type {string}
     * @memberof ApplicationRequest
     */
    'externalId'?: string;
    /**
     * Type of loan product
     * @type {string}
     * @memberof ApplicationRequest
     */
    'productType': ApplicationRequestProductTypeEnum;
    /**
     * Array of lender-specific encrypted payloads
     * @type {Array<ApplicationRequestEncryptedPayloadsInner>}
     * @memberof ApplicationRequest
     */
    'encryptedPayloads': Array<ApplicationRequestEncryptedPayloadsInner>;
    /**
     * Non-PII metadata for routing/processing
     * @type {{ [key: string]: any; }}
     * @memberof ApplicationRequest
     */
    'metadata'?: { [key: string]: any; };
    /**
     * If true, creates application in DRAFT status without creating routes or sending webhooks. Use POST /applications/{id}/submit to finalize after uploading per-lender KYC documents to SDX.  **Draft Application Flow:** 1. Create draft application (draft: true) - returns status: DRAFT 2. Get SDX upload token for this application 3. Upload KYC document encrypted for each lender to SDX 4. Call POST /applications/{id}/submit with per-lender handles 5. Application becomes OFFERS_PENDING and lenders are notified  If omitted or false, application is created and submitted immediately (original behavior for backwards compatibility). 
     * @type {boolean}
     * @memberof ApplicationRequest
     */
    'draft'?: boolean;
    /**
     * Borrower\'s wallet address for disbursement (optional - for wallet-first apps). Use this when the borrower\'s wallet is known at application time. 
     * @type {string}
     * @memberof ApplicationRequest
     */
    'borrowerWalletAddress'?: string;
    /**
     * Blockchain chain for borrower\'s wallet
     * @type {string}
     * @memberof ApplicationRequest
     */
    'borrowerWalletChain'?: ApplicationRequestBorrowerWalletChainEnum;
}

export const ApplicationRequestProductTypeEnum = {
    Consumer: 'consumer',
    Auto: 'auto',
    Mortgage: 'mortgage',
    Personal: 'personal',
    Business: 'business'
} as const;

export type ApplicationRequestProductTypeEnum = typeof ApplicationRequestProductTypeEnum[keyof typeof ApplicationRequestProductTypeEnum];
export const ApplicationRequestBorrowerWalletChainEnum = {
    Base: 'base',
    Ethereum: 'ethereum',
    Polygon: 'polygon',
    Arbitrum: 'arbitrum',
    Optimism: 'optimism',
    Solana: 'solana'
} as const;

export type ApplicationRequestBorrowerWalletChainEnum = typeof ApplicationRequestBorrowerWalletChainEnum[keyof typeof ApplicationRequestBorrowerWalletChainEnum];

/**
 * 
 * @export
 * @interface ApplicationRequestEncryptedPayloadsInner
 */
export interface ApplicationRequestEncryptedPayloadsInner {
    /**
     * Unique identifier for the lender
     * @type {string}
     * @memberof ApplicationRequestEncryptedPayloadsInner
     */
    'lenderId': string;
    /**
     * Base64-encoded encrypted PII data for this lender
     * @type {string}
     * @memberof ApplicationRequestEncryptedPayloadsInner
     */
    'encryptedData': string;
    /**
     * SDX handle for this lender\'s encrypted KYC blob. The neobank uploads the KYC document to SDX encrypted with this specific lender\'s public key, receiving a unique handle. Each lender gets their own encrypted blob - not a shared resource. 
     * @type {string}
     * @memberof ApplicationRequestEncryptedPayloadsInner
     */
    'perLenderKycHandle'?: string;
    /**
     * SHA-256 checksum of the original plaintext KYC document (for post-decrypt verification)
     * @type {string}
     * @memberof ApplicationRequestEncryptedPayloadsInner
     */
    'kycChecksumSha256'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationResponse
 */
export interface ApplicationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationResponse
     */
    'success': boolean;
    /**
     * 
     * @type {ApplicationResponseData}
     * @memberof ApplicationResponse
     */
    'data': ApplicationResponseData;
}
/**
 * 
 * @export
 * @interface ApplicationResponseData
 */
export interface ApplicationResponseData {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'id': string;
    /**
     * Type of loan product
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'productType': ApplicationResponseDataProductTypeEnum;
    /**
     * 
     * @type {ApplicationStatus}
     * @memberof ApplicationResponseData
     */
    'status': ApplicationStatus;
    /**
     * Non-PII metadata for the application
     * @type {{ [key: string]: any; }}
     * @memberof ApplicationResponseData
     */
    'metadata'?: { [key: string]: any; };
    /**
     * ISO 8601 timestamp
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'createdAt': string;
    /**
     * ISO 8601 timestamp of last update (neobank only)
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'updatedAt'?: string;
    /**
     * ID of the neobank that submitted the application (neobank only)
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'neobankId'?: string;
    /**
     * External reference ID (neobank only)
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'externalId'?: string;
    /**
     * Borrower\'s crypto wallet address (neobank only)
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'borrowerWalletAddress'?: string;
    /**
     * Blockchain network for the wallet (neobank only)
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'borrowerWalletChain'?: string;
    /**
     * Type of wallet custody (neobank only). - borrower_self_custody: Borrower controls their own wallet - neobank_custodial: Neobank manages wallet on behalf of borrower 
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'walletType'?: ApplicationResponseDataWalletTypeEnum;
    /**
     * When unsigned loan documents were sent to the borrower (neobank only). Null if documents have not yet been sent. 
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'docsSentAt'?: string | null;
    /**
     * When the borrower signed the loan documents (neobank only). Null if documents have not yet been signed. 
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'docsSignedAt'?: string | null;
    /**
     * 
     * @type {ApplicationResponseDataEncryptedPayload}
     * @memberof ApplicationResponseData
     */
    'encryptedPayload'?: ApplicationResponseDataEncryptedPayload;
    /**
     * SDX handle for this lender\'s encrypted KYC blob (lender only). Points to KYC document encrypted with this lender\'s public key at SDX layer. This is the preferred field - use instead of deprecated kycDocumentHandle. 
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'perLenderKycHandle'?: string;
    /**
     * SHA-256 checksum of original plaintext KYC doc for post-decrypt verification (lender only)
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'kycChecksumSha256'?: string;
    /**
     * Handle to KYC document in SDX (lender only). DEPRECATED: This field is shared across all lenders and will be removed. Use encryptedKycPayload instead for per-lender encrypted KYC documents. 
     * @type {string}
     * @memberof ApplicationResponseData
     * @deprecated
     */
    'kycDocumentHandle'?: string;
    /**
     * KYC attestation details (lender only)
     * @type {{ [key: string]: any; }}
     * @memberof ApplicationResponseData
     */
    'kycAttestation'?: { [key: string]: any; };
    /**
     * When KYC was submitted (lender only)
     * @type {string}
     * @memberof ApplicationResponseData
     */
    'kycSubmittedAt'?: string;
}

export const ApplicationResponseDataProductTypeEnum = {
    Consumer: 'consumer',
    Auto: 'auto',
    Mortgage: 'mortgage',
    Personal: 'personal',
    Business: 'business'
} as const;

export type ApplicationResponseDataProductTypeEnum = typeof ApplicationResponseDataProductTypeEnum[keyof typeof ApplicationResponseDataProductTypeEnum];
export const ApplicationResponseDataWalletTypeEnum = {
    BorrowerSelfCustody: 'borrower_self_custody',
    NeobankCustodial: 'neobank_custodial'
} as const;

export type ApplicationResponseDataWalletTypeEnum = typeof ApplicationResponseDataWalletTypeEnum[keyof typeof ApplicationResponseDataWalletTypeEnum];

/**
 * Lender-specific encrypted payload (lender only)
 * @export
 * @interface ApplicationResponseDataEncryptedPayload
 */
export interface ApplicationResponseDataEncryptedPayload {
    /**
     * The encrypted application data
     * @type {string}
     * @memberof ApplicationResponseDataEncryptedPayload
     */
    'encryptedData'?: string;
    /**
     * The encrypted symmetric key
     * @type {string}
     * @memberof ApplicationResponseDataEncryptedPayload
     */
    'encryptedKey'?: string;
    /**
     * Initialization vector for decryption
     * @type {string}
     * @memberof ApplicationResponseDataEncryptedPayload
     */
    'iv'?: string;
    /**
     * Authentication tag for verification
     * @type {string}
     * @memberof ApplicationResponseDataEncryptedPayload
     */
    'authTag'?: string;
}
/**
 * Application status progression: - DRAFT: Initial state when draft=true, awaiting submit - PENDING/ROUTING: Being processed for routing - OFFERS_PENDING: Sent to lenders, awaiting offers - OFFERS_READY: One or more offers received - ACCEPTED: Borrower accepted an offer - PROCESSING: Hard credit pull in progress - APPROVED: Loan approved by lender - REJECTED: Loan rejected - FUNDED: Loan disbursed - EXPIRED: 60-second queue timeout - CANCELLED: Neobank cancelled - SIGNED: Documents signed - SETTLED: Final settlement complete 
 * @export
 * @enum {string}
 */

export const ApplicationStatus = {
    Draft: 'DRAFT',
    Pending: 'PENDING',
    Routing: 'ROUTING',
    OffersPending: 'OFFERS_PENDING',
    OffersReady: 'OFFERS_READY',
    Accepted: 'ACCEPTED',
    Processing: 'PROCESSING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Funded: 'FUNDED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED',
    Signed: 'SIGNED',
    Settled: 'SETTLED'
} as const;

export type ApplicationStatus = typeof ApplicationStatus[keyof typeof ApplicationStatus];


/**
 * 
 * @export
 * @interface ApplicationStatusResponse
 */
export interface ApplicationStatusResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationStatusResponse
     */
    'success': boolean;
    /**
     * 
     * @type {ApplicationStatusResponseData}
     * @memberof ApplicationStatusResponse
     */
    'data': ApplicationStatusResponseData;
}
/**
 * 
 * @export
 * @interface ApplicationStatusResponseData
 */
export interface ApplicationStatusResponseData {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof ApplicationStatusResponseData
     */
    'id': string;
    /**
     * 
     * @type {ApplicationStatus}
     * @memberof ApplicationStatusResponseData
     */
    'status': ApplicationStatus;
    /**
     * Number of offers received
     * @type {number}
     * @memberof ApplicationStatusResponseData
     */
    'offerCount': number;
    /**
     * When application was created
     * @type {string}
     * @memberof ApplicationStatusResponseData
     */
    'createdAt': string;
    /**
     * When application was last updated
     * @type {string}
     * @memberof ApplicationStatusResponseData
     */
    'updatedAt': string;
}


/**
 * Response from PATCH /applications/{id}/status - minimal response for status updates
 * @export
 * @interface ApplicationStatusUpdateResponse
 */
export interface ApplicationStatusUpdateResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationStatusUpdateResponse
     */
    'success': boolean;
    /**
     * 
     * @type {ApplicationStatusUpdateResponseData}
     * @memberof ApplicationStatusUpdateResponse
     */
    'data': ApplicationStatusUpdateResponseData;
}
/**
 * 
 * @export
 * @interface ApplicationStatusUpdateResponseData
 */
export interface ApplicationStatusUpdateResponseData {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof ApplicationStatusUpdateResponseData
     */
    'id': string;
    /**
     * 
     * @type {ApplicationStatus}
     * @memberof ApplicationStatusUpdateResponseData
     */
    'status': ApplicationStatus;
    /**
     * When application status was updated
     * @type {string}
     * @memberof ApplicationStatusUpdateResponseData
     */
    'updatedAt': string;
}


/**
 * Response after successfully submitting a new application
 * @export
 * @interface ApplicationSubmitResponse
 */
export interface ApplicationSubmitResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationSubmitResponse
     */
    'success': boolean;
    /**
     * 
     * @type {ApplicationSubmitResponseData}
     * @memberof ApplicationSubmitResponse
     */
    'data': ApplicationSubmitResponseData;
}
/**
 * 
 * @export
 * @interface ApplicationSubmitResponseData
 */
export interface ApplicationSubmitResponseData {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof ApplicationSubmitResponseData
     */
    'id': string;
    /**
     * 
     * @type {ApplicationStatus}
     * @memberof ApplicationSubmitResponseData
     */
    'status': ApplicationStatus;
    /**
     * ISO 8601 timestamp
     * @type {string}
     * @memberof ApplicationSubmitResponseData
     */
    'createdAt': string;
    /**
     * List of lender IDs the application was routed to
     * @type {Array<string>}
     * @memberof ApplicationSubmitResponseData
     */
    'routedTo': Array<string>;
}


/**
 * 
 * @export
 * @interface Attestation
 */
export interface Attestation {
    /**
     * Unique identifier for the attestation
     * @type {string}
     * @memberof Attestation
     */
    'attestationId': string;
    /**
     * 
     * @type {AttestationProvider}
     * @memberof Attestation
     */
    'provider': AttestationProvider;
    /**
     * 
     * @type {AttestationVerification}
     * @memberof Attestation
     */
    'verification': AttestationVerification;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof Attestation
     */
    'verifiedFields'?: { [key: string]: boolean; };
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof Attestation
     */
    'checksPerformed'?: { [key: string]: boolean; };
    /**
     * Whether proof document is available in SDX
     * @type {boolean}
     * @memberof Attestation
     */
    'hasProof'?: boolean;
    /**
     * Whether attestation meets CIP requirements
     * @type {boolean}
     * @memberof Attestation
     */
    'cipCompliant'?: boolean;
    /**
     * When the verification was performed
     * @type {string}
     * @memberof Attestation
     */
    'performedAt'?: string;
    /**
     * When the attestation expires
     * @type {string}
     * @memberof Attestation
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {AttestationTrustEvaluation}
     * @memberof Attestation
     */
    'trustEvaluation'?: AttestationTrustEvaluation;
}
/**
 * 
 * @export
 * @interface AttestationProvider
 */
export interface AttestationProvider {
    /**
     * 
     * @type {string}
     * @memberof AttestationProvider
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttestationProvider
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttestationProvider
     */
    'type'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttestationProvider
     */
    'certifications'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttestationProvider
     */
    'regulatoryApprovals'?: Array<string>;
}
/**
 * Trust evaluation specific to requesting lender
 * @export
 * @interface AttestationTrustEvaluation
 */
export interface AttestationTrustEvaluation {
    /**
     * 
     * @type {boolean}
     * @memberof AttestationTrustEvaluation
     */
    'isTrusted'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttestationTrustEvaluation
     */
    'reasons'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof AttestationTrustEvaluation
     */
    'meetsRequirements'?: boolean;
}
/**
 * 
 * @export
 * @interface AttestationVerification
 */
export interface AttestationVerification {
    /**
     * 
     * @type {string}
     * @memberof AttestationVerification
     */
    'type'?: AttestationVerificationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AttestationVerification
     */
    'status'?: AttestationVerificationStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof AttestationVerification
     */
    'confidenceScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof AttestationVerification
     */
    'riskScore'?: number;
}

export const AttestationVerificationTypeEnum = {
    Document: 'document',
    Identity: 'identity',
    Address: 'address',
    Age: 'age'
} as const;

export type AttestationVerificationTypeEnum = typeof AttestationVerificationTypeEnum[keyof typeof AttestationVerificationTypeEnum];
export const AttestationVerificationStatusEnum = {
    Passed: 'passed',
    Failed: 'failed',
    ManualReview: 'manual_review',
    Insufficient: 'insufficient'
} as const;

export type AttestationVerificationStatusEnum = typeof AttestationVerificationStatusEnum[keyof typeof AttestationVerificationStatusEnum];

/**
 * Response from GET /applications/{applicationId}/attestations
 * @export
 * @interface AttestationsResponse
 */
export interface AttestationsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof AttestationsResponse
     */
    'success': boolean;
    /**
     * 
     * @type {AttestationsResponseData}
     * @memberof AttestationsResponse
     */
    'data': AttestationsResponseData;
}
/**
 * 
 * @export
 * @interface AttestationsResponseData
 */
export interface AttestationsResponseData {
    /**
     * Application ID the attestations are for
     * @type {string}
     * @memberof AttestationsResponseData
     */
    'applicationId': string;
    /**
     * 
     * @type {Array<Attestation>}
     * @memberof AttestationsResponseData
     */
    'attestations': Array<Attestation>;
    /**
     * 
     * @type {AttestationsSummary}
     * @memberof AttestationsResponseData
     */
    'summary': AttestationsSummary;
}
/**
 * 
 * @export
 * @interface AttestationsSummary
 */
export interface AttestationsSummary {
    /**
     * Total number of attestations
     * @type {number}
     * @memberof AttestationsSummary
     */
    'totalAttestations': number;
    /**
     * Number of attestations trusted by requesting lender
     * @type {number}
     * @memberof AttestationsSummary
     */
    'trustedAttestations': number;
    /**
     * Whether any attestation is CIP compliant
     * @type {boolean}
     * @memberof AttestationsSummary
     */
    'hasCipCompliant': boolean;
    /**
     * List of unique provider codes
     * @type {Array<string>}
     * @memberof AttestationsSummary
     */
    'providers': Array<string>;
}
/**
 * 
 * @export
 * @interface BatchGetLenderPublicKeysRequest
 */
export interface BatchGetLenderPublicKeysRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchGetLenderPublicKeysRequest
     */
    'lenderIds': Array<string>;
}
/**
 * 
 * @export
 * @interface BatchGetNeobankPublicKeysRequest
 */
export interface BatchGetNeobankPublicKeysRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchGetNeobankPublicKeysRequest
     */
    'neobankIds': Array<string>;
}
/**
 * Response from POST /lenders/public-keys
 * @export
 * @interface BatchLenderKeysResponse
 */
export interface BatchLenderKeysResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BatchLenderKeysResponse
     */
    'success': boolean;
    /**
     * 
     * @type {BatchLenderKeysResponseData}
     * @memberof BatchLenderKeysResponse
     */
    'data': BatchLenderKeysResponseData;
}
/**
 * 
 * @export
 * @interface BatchLenderKeysResponseData
 */
export interface BatchLenderKeysResponseData {
    /**
     * 
     * @type {{ [key: string]: BatchLenderKeysResponseDataKeysValue; }}
     * @memberof BatchLenderKeysResponseData
     */
    'keys': { [key: string]: BatchLenderKeysResponseDataKeysValue; };
    /**
     * 
     * @type {string}
     * @memberof BatchLenderKeysResponseData
     */
    'retrievedAt': string;
}
/**
 * 
 * @export
 * @interface BatchLenderKeysResponseDataKeysValue
 */
export interface BatchLenderKeysResponseDataKeysValue {
    /**
     * 
     * @type {string}
     * @memberof BatchLenderKeysResponseDataKeysValue
     */
    'publicKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchLenderKeysResponseDataKeysValue
     */
    'keyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchLenderKeysResponseDataKeysValue
     */
    'expiresAt'?: string | null;
}
/**
 * Response from POST /neobanks/public-keys
 * @export
 * @interface BatchNeobankKeysResponse
 */
export interface BatchNeobankKeysResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BatchNeobankKeysResponse
     */
    'success': boolean;
    /**
     * 
     * @type {BatchNeobankKeysResponseData}
     * @memberof BatchNeobankKeysResponse
     */
    'data': BatchNeobankKeysResponseData;
}
/**
 * 
 * @export
 * @interface BatchNeobankKeysResponseData
 */
export interface BatchNeobankKeysResponseData {
    /**
     * 
     * @type {{ [key: string]: BatchNeobankKeysResponseDataKeysValue; }}
     * @memberof BatchNeobankKeysResponseData
     */
    'keys': { [key: string]: BatchNeobankKeysResponseDataKeysValue; };
    /**
     * Neobank IDs that were not found or have no active key
     * @type {Array<string>}
     * @memberof BatchNeobankKeysResponseData
     */
    'missing': Array<string>;
}
/**
 * 
 * @export
 * @interface BatchNeobankKeysResponseDataKeysValue
 */
export interface BatchNeobankKeysResponseDataKeysValue {
    /**
     * 
     * @type {string}
     * @memberof BatchNeobankKeysResponseDataKeysValue
     */
    'keyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchNeobankKeysResponseDataKeysValue
     */
    'publicKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchNeobankKeysResponseDataKeysValue
     */
    'algorithm'?: string;
    /**
     * 
     * @type {number}
     * @memberof BatchNeobankKeysResponseDataKeysValue
     */
    'keySize'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatchNeobankKeysResponseDataKeysValue
     */
    'expiresAt'?: string | null;
}
/**
 * Repayment from Bridge liquidation address drain
 * @export
 * @interface BridgeRepayment
 */
export interface BridgeRepayment {
    /**
     * Drain ID
     * @type {string}
     * @memberof BridgeRepayment
     */
    'id'?: string;
    /**
     * Bridge drain ID
     * @type {string}
     * @memberof BridgeRepayment
     */
    'bridgeDrainId'?: string;
    /**
     * Amount
     * @type {string}
     * @memberof BridgeRepayment
     */
    'amount'?: string;
    /**
     * Currency (e.g., USDC)
     * @type {string}
     * @memberof BridgeRepayment
     */
    'currency'?: string;
    /**
     * Drain state (e.g., payment_processed, pending)
     * @type {string}
     * @memberof BridgeRepayment
     */
    'state'?: string;
    /**
     * Source blockchain address
     * @type {string}
     * @memberof BridgeRepayment
     */
    'fromAddress'?: string | null;
    /**
     * Source blockchain/payment rail
     * @type {string}
     * @memberof BridgeRepayment
     */
    'sourceChain'?: string;
    /**
     * Deposit transaction hash
     * @type {string}
     * @memberof BridgeRepayment
     */
    'depositTxHash'?: string | null;
    /**
     * Destination transaction hash
     * @type {string}
     * @memberof BridgeRepayment
     */
    'destinationTxHash'?: string | null;
    /**
     * 
     * @type {BridgeRepaymentReceipt}
     * @memberof BridgeRepayment
     */
    'receipt'?: BridgeRepaymentReceipt | null;
    /**
     * Not available from Bridge (null)
     * @type {string}
     * @memberof BridgeRepayment
     */
    'principalPortion'?: string | null;
    /**
     * Not available from Bridge (null)
     * @type {string}
     * @memberof BridgeRepayment
     */
    'interestPortion'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BridgeRepayment
     */
    'receivedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BridgeRepayment
     */
    'completedAt'?: string | null;
}
/**
 * Response when fetching repayments from Bridge API (source=bridge)
 * @export
 * @interface BridgeRepaymentListResponse
 */
export interface BridgeRepaymentListResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BridgeRepaymentListResponse
     */
    'success': boolean;
    /**
     * 
     * @type {BridgeRepaymentListResponseData}
     * @memberof BridgeRepaymentListResponse
     */
    'data': BridgeRepaymentListResponseData;
    /**
     * When the data was fetched from Bridge
     * @type {string}
     * @memberof BridgeRepaymentListResponse
     */
    'fetchedAt': string;
}
/**
 * 
 * @export
 * @interface BridgeRepaymentListResponseData
 */
export interface BridgeRepaymentListResponseData {
    /**
     * Loan ID
     * @type {string}
     * @memberof BridgeRepaymentListResponseData
     */
    'loanId': string;
    /**
     * Bridge liquidation address ID
     * @type {string}
     * @memberof BridgeRepaymentListResponseData
     */
    'liquidationAddressId'?: string | null;
    /**
     * Blockchain address for repayments
     * @type {string}
     * @memberof BridgeRepaymentListResponseData
     */
    'liquidationAddress'?: string | null;
    /**
     * 
     * @type {Array<BridgeRepayment>}
     * @memberof BridgeRepaymentListResponseData
     */
    'repayments': Array<BridgeRepayment>;
    /**
     * 
     * @type {BridgeRepaymentListResponseDataSummary}
     * @memberof BridgeRepaymentListResponseData
     */
    'summary': BridgeRepaymentListResponseDataSummary;
    /**
     * 
     * @type {BridgeRepaymentListResponseDataPagination}
     * @memberof BridgeRepaymentListResponseData
     */
    'pagination': BridgeRepaymentListResponseDataPagination;
}
/**
 * 
 * @export
 * @interface BridgeRepaymentListResponseDataPagination
 */
export interface BridgeRepaymentListResponseDataPagination {
    /**
     * 
     * @type {number}
     * @memberof BridgeRepaymentListResponseDataPagination
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof BridgeRepaymentListResponseDataPagination
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof BridgeRepaymentListResponseDataPagination
     */
    'offset': number;
    /**
     * 
     * @type {boolean}
     * @memberof BridgeRepaymentListResponseDataPagination
     */
    'hasMore': boolean;
}
/**
 * 
 * @export
 * @interface BridgeRepaymentListResponseDataSummary
 */
export interface BridgeRepaymentListResponseDataSummary {
    /**
     * Total number of repayments
     * @type {number}
     * @memberof BridgeRepaymentListResponseDataSummary
     */
    'totalRepayments': number;
    /**
     * Total amount successfully processed
     * @type {string}
     * @memberof BridgeRepaymentListResponseDataSummary
     */
    'totalAmountReceived': string;
    /**
     * Amount pending processing
     * @type {string}
     * @memberof BridgeRepaymentListResponseDataSummary
     */
    'pendingAmount': string;
}
/**
 * Receipt details
 * @export
 * @interface BridgeRepaymentReceipt
 */
export interface BridgeRepaymentReceipt {
    /**
     * 
     * @type {string}
     * @memberof BridgeRepaymentReceipt
     */
    'initialAmount'?: string;
    /**
     * 
     * @type {string}
     * @memberof BridgeRepaymentReceipt
     */
    'developerFee'?: string;
    /**
     * 
     * @type {string}
     * @memberof BridgeRepaymentReceipt
     */
    'finalAmount'?: string;
}
/**
 * 
 * @export
 * @interface CompleteSigningSessionRequest
 */
export interface CompleteSigningSessionRequest {
    /**
     * SDX handle for lender\'s copy of signed document
     * @type {string}
     * @memberof CompleteSigningSessionRequest
     */
    'signedDocHandleLender': string;
    /**
     * SDX handle for neobank\'s copy of signed document
     * @type {string}
     * @memberof CompleteSigningSessionRequest
     */
    'signedDocHandleNeobank': string;
    /**
     * When the document was signed (defaults to now)
     * @type {string}
     * @memberof CompleteSigningSessionRequest
     */
    'signedAt'?: string;
}
/**
 * 
 * @export
 * @interface ConfirmESignComplete200Response
 */
export interface ConfirmESignComplete200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ConfirmESignComplete200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ConfirmESignComplete200ResponseData}
     * @memberof ConfirmESignComplete200Response
     */
    'data': ConfirmESignComplete200ResponseData;
}
/**
 * 
 * @export
 * @interface ConfirmESignComplete200ResponseData
 */
export interface ConfirmESignComplete200ResponseData {
    /**
     * The application ID
     * @type {string}
     * @memberof ConfirmESignComplete200ResponseData
     */
    'applicationId': string;
    /**
     * The updated status
     * @type {string}
     * @memberof ConfirmESignComplete200ResponseData
     */
    'status': ConfirmESignComplete200ResponseDataStatusEnum;
    /**
     * When the document was signed
     * @type {string}
     * @memberof ConfirmESignComplete200ResponseData
     */
    'signedAt': string;
}

export const ConfirmESignComplete200ResponseDataStatusEnum = {
    Signed: 'SIGNED'
} as const;

export type ConfirmESignComplete200ResponseDataStatusEnum = typeof ConfirmESignComplete200ResponseDataStatusEnum[keyof typeof ConfirmESignComplete200ResponseDataStatusEnum];

/**
 * 
 * @export
 * @interface ConsentToFunding200Response
 */
export interface ConsentToFunding200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ConsentToFunding200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {ConsentToFunding200ResponseData}
     * @memberof ConsentToFunding200Response
     */
    'data'?: ConsentToFunding200ResponseData;
}
/**
 * 
 * @export
 * @interface ConsentToFunding200ResponseData
 */
export interface ConsentToFunding200ResponseData {
    /**
     * Unique funding identifier
     * @type {string}
     * @memberof ConsentToFunding200ResponseData
     */
    'fundingId'?: string;
    /**
     * New funding status after consent
     * @type {string}
     * @memberof ConsentToFunding200ResponseData
     */
    'status'?: string;
    /**
     * Timestamp when consent was recorded
     * @type {string}
     * @memberof ConsentToFunding200ResponseData
     */
    'consentedAt'?: string;
}
/**
 * 
 * @export
 * @interface CreateSigningSessionRequest
 */
export interface CreateSigningSessionRequest {
    /**
     * Email address of the borrower for signing
     * @type {string}
     * @memberof CreateSigningSessionRequest
     */
    'borrowerEmail': string;
    /**
     * Full name of the borrower
     * @type {string}
     * @memberof CreateSigningSessionRequest
     */
    'borrowerName': string;
}
/**
 * 
 * @export
 * @interface DeclineApplication200Response
 */
export interface DeclineApplication200Response {
    /**
     * 
     * @type {boolean}
     * @memberof DeclineApplication200Response
     */
    'success': boolean;
    /**
     * 
     * @type {DeclineApplication200ResponseData}
     * @memberof DeclineApplication200Response
     */
    'data': DeclineApplication200ResponseData;
}
/**
 * 
 * @export
 * @interface DeclineApplication200ResponseData
 */
export interface DeclineApplication200ResponseData {
    /**
     * The declined application ID
     * @type {string}
     * @memberof DeclineApplication200ResponseData
     */
    'applicationId': string;
    /**
     * The lender who declined
     * @type {string}
     * @memberof DeclineApplication200ResponseData
     */
    'lenderId': string;
    /**
     * Route status after decline
     * @type {string}
     * @memberof DeclineApplication200ResponseData
     */
    'status': DeclineApplication200ResponseDataStatusEnum;
    /**
     * When the decline was recorded
     * @type {string}
     * @memberof DeclineApplication200ResponseData
     */
    'declinedAt': string;
    /**
     * Optional decline reason provided by lender
     * @type {string}
     * @memberof DeclineApplication200ResponseData
     */
    'declineReason'?: string | null;
}

export const DeclineApplication200ResponseDataStatusEnum = {
    Declined: 'DECLINED'
} as const;

export type DeclineApplication200ResponseDataStatusEnum = typeof DeclineApplication200ResponseDataStatusEnum[keyof typeof DeclineApplication200ResponseDataStatusEnum];

/**
 * 
 * @export
 * @interface DeclineApplicationRequest
 */
export interface DeclineApplicationRequest {
    /**
     * Optional free-form decline reason (not ECOA codes)
     * @type {string}
     * @memberof DeclineApplicationRequest
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface DeclineFunding200Response
 */
export interface DeclineFunding200Response {
    /**
     * 
     * @type {boolean}
     * @memberof DeclineFunding200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {DeclineFunding200ResponseData}
     * @memberof DeclineFunding200Response
     */
    'data'?: DeclineFunding200ResponseData;
}
/**
 * 
 * @export
 * @interface DeclineFunding200ResponseData
 */
export interface DeclineFunding200ResponseData {
    /**
     * Unique funding identifier
     * @type {string}
     * @memberof DeclineFunding200ResponseData
     */
    'fundingId'?: string;
    /**
     * New funding status after decline
     * @type {string}
     * @memberof DeclineFunding200ResponseData
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeclineFundingRequest
 */
export interface DeclineFundingRequest {
    /**
     * Optional reason for declining the funding
     * @type {string}
     * @memberof DeclineFundingRequest
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface DeclinedApplicationsResponse
 */
export interface DeclinedApplicationsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeclinedApplicationsResponse
     */
    'success': boolean;
    /**
     * 
     * @type {DeclinedApplicationsResponseData}
     * @memberof DeclinedApplicationsResponse
     */
    'data': DeclinedApplicationsResponseData;
}
/**
 * 
 * @export
 * @interface DeclinedApplicationsResponseData
 */
export interface DeclinedApplicationsResponseData {
    /**
     * 
     * @type {Array<DeclinedApplicationsResponseDataApplicationsInner>}
     * @memberof DeclinedApplicationsResponseData
     */
    'applications': Array<DeclinedApplicationsResponseDataApplicationsInner>;
    /**
     * 
     * @type {DeclinedApplicationsResponseDataPagination}
     * @memberof DeclinedApplicationsResponseData
     */
    'pagination': DeclinedApplicationsResponseDataPagination;
    /**
     * When this response was generated
     * @type {string}
     * @memberof DeclinedApplicationsResponseData
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface DeclinedApplicationsResponseDataApplicationsInner
 */
export interface DeclinedApplicationsResponseDataApplicationsInner {
    /**
     * The declined application ID
     * @type {string}
     * @memberof DeclinedApplicationsResponseDataApplicationsInner
     */
    'applicationId': string;
    /**
     * Type of loan product
     * @type {string}
     * @memberof DeclinedApplicationsResponseDataApplicationsInner
     */
    'productType': DeclinedApplicationsResponseDataApplicationsInnerProductTypeEnum;
    /**
     * When the application was declined
     * @type {string}
     * @memberof DeclinedApplicationsResponseDataApplicationsInner
     */
    'declinedAt': string;
    /**
     * Optional reason provided at decline
     * @type {string}
     * @memberof DeclinedApplicationsResponseDataApplicationsInner
     */
    'declineReason'?: string | null;
    /**
     * Number of days since decline
     * @type {number}
     * @memberof DeclinedApplicationsResponseDataApplicationsInner
     */
    'daysSinceDecline': number;
    /**
     * 30-day deadline for adverse action notice
     * @type {string}
     * @memberof DeclinedApplicationsResponseDataApplicationsInner
     */
    'adverseActionDeadline': string;
    /**
     * True if more than 30 days since decline
     * @type {boolean}
     * @memberof DeclinedApplicationsResponseDataApplicationsInner
     */
    'adverseActionOverdue': boolean;
}

export const DeclinedApplicationsResponseDataApplicationsInnerProductTypeEnum = {
    Consumer: 'consumer',
    Auto: 'auto',
    Mortgage: 'mortgage',
    Personal: 'personal',
    Business: 'business'
} as const;

export type DeclinedApplicationsResponseDataApplicationsInnerProductTypeEnum = typeof DeclinedApplicationsResponseDataApplicationsInnerProductTypeEnum[keyof typeof DeclinedApplicationsResponseDataApplicationsInnerProductTypeEnum];

/**
 * 
 * @export
 * @interface DeclinedApplicationsResponseDataPagination
 */
export interface DeclinedApplicationsResponseDataPagination {
    /**
     * Total number of declined applications
     * @type {number}
     * @memberof DeclinedApplicationsResponseDataPagination
     */
    'total': number;
    /**
     * Maximum results per page
     * @type {number}
     * @memberof DeclinedApplicationsResponseDataPagination
     */
    'limit': number;
    /**
     * Number of results skipped
     * @type {number}
     * @memberof DeclinedApplicationsResponseDataPagination
     */
    'offset': number;
    /**
     * True if more results available
     * @type {boolean}
     * @memberof DeclinedApplicationsResponseDataPagination
     */
    'hasMore': boolean;
}
/**
 * Request body for submitting (finalizing) a draft application
 * @export
 * @interface DraftSubmitRequest
 */
export interface DraftSubmitRequest {
    /**
     * Per-lender KYC document handles from SDX. Each handle points to a KYC blob encrypted specifically for that lender. Lenders cannot see other lenders\' handles. 
     * @type {Array<DraftSubmitRequestPerLenderKycHandlesInner>}
     * @memberof DraftSubmitRequest
     */
    'perLenderKycHandles'?: Array<DraftSubmitRequestPerLenderKycHandlesInner>;
    /**
     * SHA-256 checksum of the original plaintext KYC document. Same value for all lenders since it\'s computed before encryption. Enables post-decrypt integrity verification. 
     * @type {string}
     * @memberof DraftSubmitRequest
     */
    'kycChecksumSha256'?: string;
}
/**
 * 
 * @export
 * @interface DraftSubmitRequestPerLenderKycHandlesInner
 */
export interface DraftSubmitRequestPerLenderKycHandlesInner {
    /**
     * Lender ID this handle is for (must match original encryptedPayloads)
     * @type {string}
     * @memberof DraftSubmitRequestPerLenderKycHandlesInner
     */
    'lenderId': string;
    /**
     * SDX blob handle for this lender\'s encrypted KYC document
     * @type {string}
     * @memberof DraftSubmitRequestPerLenderKycHandlesInner
     */
    'handle': string;
}
/**
 * 
 * @export
 * @interface DraftSubmitResponse
 */
export interface DraftSubmitResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DraftSubmitResponse
     */
    'success': boolean;
    /**
     * 
     * @type {DraftSubmitResponseData}
     * @memberof DraftSubmitResponse
     */
    'data': DraftSubmitResponseData;
}
/**
 * 
 * @export
 * @interface DraftSubmitResponseData
 */
export interface DraftSubmitResponseData {
    /**
     * Application ID
     * @type {string}
     * @memberof DraftSubmitResponseData
     */
    'id': string;
    /**
     * 
     * @type {ApplicationStatus}
     * @memberof DraftSubmitResponseData
     */
    'status': ApplicationStatus;
    /**
     * List of lender IDs the application was routed to
     * @type {Array<string>}
     * @memberof DraftSubmitResponseData
     */
    'routedTo': Array<string>;
    /**
     * When the application was originally created
     * @type {string}
     * @memberof DraftSubmitResponseData
     */
    'createdAt': string;
    /**
     * Present and true when the application was already submitted (idempotent response). Indicates no new routes were created. 
     * @type {boolean}
     * @memberof DraftSubmitResponseData
     */
    'alreadySubmitted'?: boolean;
}


/**
 * 
 * @export
 * @interface EmergencyRevokeKeyRequest
 */
export interface EmergencyRevokeKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof EmergencyRevokeKeyRequest
     */
    'reason': EmergencyRevokeKeyRequestReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof EmergencyRevokeKeyRequest
     */
    'description'?: string;
    /**
     * Replacement key (required)
     * @type {string}
     * @memberof EmergencyRevokeKeyRequest
     */
    'newPublicKey': string;
}

export const EmergencyRevokeKeyRequestReasonEnum = {
    Compromised: 'COMPROMISED',
    Lost: 'LOST',
    Rotation: 'ROTATION'
} as const;

export type EmergencyRevokeKeyRequestReasonEnum = typeof EmergencyRevokeKeyRequestReasonEnum[keyof typeof EmergencyRevokeKeyRequestReasonEnum];

/**
 * 
 * @export
 * @interface EncryptedOffer
 */
export interface EncryptedOffer {
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffer
     */
    'offerId': string;
    /**
     * Type of offer: - prequalified: Initial soft-pull offer before hard credit check - final: Firm offer after hard credit pull and full underwriting 
     * @type {string}
     * @memberof EncryptedOffer
     */
    'offerType': EncryptedOfferOfferTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffer
     */
    'lenderId': string;
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffer
     */
    'neobankId': string;
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffer
     */
    'applicationId': string;
    /**
     * Loan amount (publicly visible, string for precision)
     * @type {string}
     * @memberof EncryptedOffer
     */
    'loanAmount': string;
    /**
     * Encrypted offer details (decrypt with neobank private key)
     * @type {string}
     * @memberof EncryptedOffer
     */
    'encryptedOfferDetailsNeobank': string;
    /**
     * SHA-256 checksum for integrity verification
     * @type {string}
     * @memberof EncryptedOffer
     */
    'checksumSha256': string;
    /**
     * 
     * @type {OfferStatus}
     * @memberof EncryptedOffer
     */
    'status': OfferStatus;
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffer
     */
    'externalId'?: string | null;
    /**
     * For final offers only: ID of the prequalified offer this final offer originated from. Useful for showing the borrower the progression from prequal to final offer. Null for prequalified offers. 
     * @type {string}
     * @memberof EncryptedOffer
     */
    'prequalifiedOfferId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffer
     */
    'expiresAt': string;
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffer
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffer
     */
    'updatedAt'?: string;
}

export const EncryptedOfferOfferTypeEnum = {
    Prequalified: 'prequalified',
    Final: 'final'
} as const;

export type EncryptedOfferOfferTypeEnum = typeof EncryptedOfferOfferTypeEnum[keyof typeof EncryptedOfferOfferTypeEnum];

/**
 * 
 * @export
 * @interface EncryptedOfferSubmission
 */
export interface EncryptedOfferSubmission {
    /**
     * Loan amount in USD (publicly visible for sorting/filtering)
     * @type {number}
     * @memberof EncryptedOfferSubmission
     */
    'loanAmount': number;
    /**
     * Base64-encoded encrypted offer details (RSA-OAEP with neobank\'s public key). Contains: {interestRate, term, monthlyPayment, fees, offerDetails, etc.} 
     * @type {string}
     * @memberof EncryptedOfferSubmission
     */
    'encryptedOfferDetailsNeobank': string;
    /**
     * SHA-256 checksum of plaintext offer details (before encryption)
     * @type {string}
     * @memberof EncryptedOfferSubmission
     */
    'checksumSha256': string;
    /**
     * Lender\'s external reference ID for this offer
     * @type {string}
     * @memberof EncryptedOfferSubmission
     */
    'externalId'?: string;
    /**
     * Offer expiration timestamp (max 90 days from now)
     * @type {string}
     * @memberof EncryptedOfferSubmission
     */
    'expiresAt': string;
    /**
     * Required for final offers only (references accepted prequal offer)
     * @type {string}
     * @memberof EncryptedOfferSubmission
     */
    'prequalifiedOfferId'?: string;
}
/**
 * 
 * @export
 * @interface EncryptedOffersResponse
 */
export interface EncryptedOffersResponse {
    /**
     * 
     * @type {boolean}
     * @memberof EncryptedOffersResponse
     */
    'success': boolean;
    /**
     * 
     * @type {EncryptedOffersResponseData}
     * @memberof EncryptedOffersResponse
     */
    'data': EncryptedOffersResponseData;
}
/**
 * 
 * @export
 * @interface EncryptedOffersResponseData
 */
export interface EncryptedOffersResponseData {
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffersResponseData
     */
    'applicationId': string;
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffersResponseData
     */
    'offerType': EncryptedOffersResponseDataOfferTypeEnum;
    /**
     * Offers grouped by lender
     * @type {Array<EncryptedOffersResponseDataLendersInner>}
     * @memberof EncryptedOffersResponseData
     */
    'lenders': Array<EncryptedOffersResponseDataLendersInner>;
    /**
     * 
     * @type {number}
     * @memberof EncryptedOffersResponseData
     */
    'totalOffers': number;
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffersResponseData
     */
    'retrievedAt': string;
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffersResponseData
     */
    'requestId'?: string;
}

export const EncryptedOffersResponseDataOfferTypeEnum = {
    Prequalified: 'prequalified',
    Final: 'final'
} as const;

export type EncryptedOffersResponseDataOfferTypeEnum = typeof EncryptedOffersResponseDataOfferTypeEnum[keyof typeof EncryptedOffersResponseDataOfferTypeEnum];

/**
 * 
 * @export
 * @interface EncryptedOffersResponseDataLendersInner
 */
export interface EncryptedOffersResponseDataLendersInner {
    /**
     * 
     * @type {string}
     * @memberof EncryptedOffersResponseDataLendersInner
     */
    'lenderId'?: string;
    /**
     * 
     * @type {number}
     * @memberof EncryptedOffersResponseDataLendersInner
     */
    'offerCount'?: number;
    /**
     * 
     * @type {Array<EncryptedOffer>}
     * @memberof EncryptedOffersResponseDataLendersInner
     */
    'offers'?: Array<EncryptedOffer>;
}
/**
 * 
 * @export
 * @interface ErrorDetailsInner
 */
export interface ErrorDetailsInner {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetailsInner
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetailsInner
     */
    'message'?: string;
}
/**
 * Standard error response format for all API errors
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Machine-readable error code (SCREAMING_SNAKE_CASE)
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
    /**
     * Human-readable error description
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * HTTP status code
     * @type {number}
     * @memberof ErrorResponse
     */
    'status': number;
    /**
     * Unique request identifier for debugging/support
     * @type {string}
     * @memberof ErrorResponse
     */
    'requestId': string;
}
/**
 * 
 * @export
 * @interface FinalOfferSubmission
 */
export interface FinalOfferSubmission {
    /**
     * 1-10 final offers (post hard pull)
     * @type {Array<FinalOfferSubmissionOffersInner>}
     * @memberof FinalOfferSubmission
     */
    'offers': Array<FinalOfferSubmissionOffersInner>;
}
/**
 * 
 * @export
 * @interface FinalOfferSubmissionOffersInner
 */
export interface FinalOfferSubmissionOffersInner {
    /**
     * Loan amount in USD (publicly visible for sorting/filtering)
     * @type {number}
     * @memberof FinalOfferSubmissionOffersInner
     */
    'loanAmount': number;
    /**
     * Base64-encoded encrypted offer details (RSA-OAEP with neobank\'s public key). Contains: {interestRate, term, monthlyPayment, fees, offerDetails, etc.} 
     * @type {string}
     * @memberof FinalOfferSubmissionOffersInner
     */
    'encryptedOfferDetailsNeobank': string;
    /**
     * SHA-256 checksum of plaintext offer details (before encryption)
     * @type {string}
     * @memberof FinalOfferSubmissionOffersInner
     */
    'checksumSha256': string;
    /**
     * Lender\'s external reference ID for this offer
     * @type {string}
     * @memberof FinalOfferSubmissionOffersInner
     */
    'externalId'?: string;
    /**
     * Offer expiration timestamp (max 90 days from now)
     * @type {string}
     * @memberof FinalOfferSubmissionOffersInner
     */
    'expiresAt': string;
    /**
     * REQUIRED for final offers
     * @type {string}
     * @memberof FinalOfferSubmissionOffersInner
     */
    'prequalifiedOfferId': string;
}
/**
 * Funding consent record for Bridge integration
 * @export
 * @interface FundingRecord
 */
export interface FundingRecord {
    /**
     * Unique funding identifier
     * @type {string}
     * @memberof FundingRecord
     */
    'id': string;
    /**
     * Associated application ID
     * @type {string}
     * @memberof FundingRecord
     */
    'applicationId': string;
    /**
     * Lender ID
     * @type {string}
     * @memberof FundingRecord
     */
    'lenderId': string;
    /**
     * Loan amount to be funded
     * @type {number}
     * @memberof FundingRecord
     */
    'amount': number;
    /**
     * Currency for funding (stablecoin)
     * @type {string}
     * @memberof FundingRecord
     */
    'currency': string;
    /**
     * Current funding status
     * @type {string}
     * @memberof FundingRecord
     */
    'status': FundingRecordStatusEnum;
    /**
     * Timestamp when lender consented to fund
     * @type {string}
     * @memberof FundingRecord
     */
    'lenderConsentedAt'?: string;
    /**
     * Timestamp when funds were disbursed
     * @type {string}
     * @memberof FundingRecord
     */
    'disbursedAt'?: string;
    /**
     * Timestamp when Bridge transfer was initiated
     * @type {string}
     * @memberof FundingRecord
     */
    'initiatedAt'?: string | null;
    /**
     * Timestamp when funds fully arrived at recipient
     * @type {string}
     * @memberof FundingRecord
     */
    'completedAt'?: string | null;
    /**
     * Timestamp when funding failed (if applicable)
     * @type {string}
     * @memberof FundingRecord
     */
    'failedAt'?: string | null;
    /**
     * Reason for failure or cancellation
     * @type {string}
     * @memberof FundingRecord
     */
    'failureReason'?: string | null;
    /**
     * Bridge transfer ID for tracking disbursement
     * @type {string}
     * @memberof FundingRecord
     */
    'bridgeTransferId'?: string;
    /**
     * Blockchain network used for disbursement
     * @type {string}
     * @memberof FundingRecord
     */
    'blockchain'?: string;
    /**
     * On-chain transaction hash for the disbursement
     * @type {string}
     * @memberof FundingRecord
     */
    'txHash'?: string;
    /**
     * Wallet address where funds were disbursed
     * @type {string}
     * @memberof FundingRecord
     */
    'recipientAddress'?: string;
    /**
     * Record creation timestamp
     * @type {string}
     * @memberof FundingRecord
     */
    'createdAt': string;
    /**
     * Record last update timestamp
     * @type {string}
     * @memberof FundingRecord
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {FundingRecordApplication}
     * @memberof FundingRecord
     */
    'Application'?: FundingRecordApplication;
}

export const FundingRecordStatusEnum = {
    Pending: 'PENDING',
    Consented: 'CONSENTED',
    Disbursing: 'DISBURSING',
    Disbursed: 'DISBURSED',
    Funded: 'FUNDED',
    Failed: 'FAILED',
    Cancelled: 'CANCELLED'
} as const;

export type FundingRecordStatusEnum = typeof FundingRecordStatusEnum[keyof typeof FundingRecordStatusEnum];

/**
 * Associated application summary (included in pending fundings)
 * @export
 * @interface FundingRecordApplication
 */
export interface FundingRecordApplication {
    /**
     * 
     * @type {string}
     * @memberof FundingRecordApplication
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingRecordApplication
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingRecordApplication
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingRecordApplication
     */
    'neobankId'?: string;
}
/**
 * 
 * @export
 * @interface GetAccountStats200Response
 */
export interface GetAccountStats200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetAccountStats200Response
     */
    'success': boolean;
    /**
     * 
     * @type {GetAccountStats200ResponseData}
     * @memberof GetAccountStats200Response
     */
    'data': GetAccountStats200ResponseData;
}
/**
 * 
 * @export
 * @interface GetAccountStats200ResponseData
 */
export interface GetAccountStats200ResponseData {
    /**
     * 
     * @type {GetAccountStats200ResponseDataApplications}
     * @memberof GetAccountStats200ResponseData
     */
    'applications'?: GetAccountStats200ResponseDataApplications;
    /**
     * 
     * @type {GetAccountStats200ResponseDataLoans}
     * @memberof GetAccountStats200ResponseData
     */
    'loans'?: GetAccountStats200ResponseDataLoans;
    /**
     * 
     * @type {GetAccountStats200ResponseDataBorrowers}
     * @memberof GetAccountStats200ResponseData
     */
    'borrowers'?: GetAccountStats200ResponseDataBorrowers;
    /**
     * Timestamp when stats were calculated
     * @type {string}
     * @memberof GetAccountStats200ResponseData
     */
    'asOf'?: string;
}
/**
 * Application statistics (neobank only)
 * @export
 * @interface GetAccountStats200ResponseDataApplications
 */
export interface GetAccountStats200ResponseDataApplications {
    /**
     * Total number of applications
     * @type {number}
     * @memberof GetAccountStats200ResponseDataApplications
     */
    'total'?: number;
    /**
     * Count of applications by status
     * @type {{ [key: string]: number; }}
     * @memberof GetAccountStats200ResponseDataApplications
     */
    'byStatus'?: { [key: string]: number; };
}
/**
 * Borrower statistics (neobank only)
 * @export
 * @interface GetAccountStats200ResponseDataBorrowers
 */
export interface GetAccountStats200ResponseDataBorrowers {
    /**
     * Unique borrowers (by wallet address)
     * @type {number}
     * @memberof GetAccountStats200ResponseDataBorrowers
     */
    'total'?: number;
}
/**
 * Loan statistics
 * @export
 * @interface GetAccountStats200ResponseDataLoans
 */
export interface GetAccountStats200ResponseDataLoans {
    /**
     * 
     * @type {number}
     * @memberof GetAccountStats200ResponseDataLoans
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAccountStats200ResponseDataLoans
     */
    'active'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAccountStats200ResponseDataLoans
     */
    'paidOff'?: number;
    /**
     * Lender only
     * @type {number}
     * @memberof GetAccountStats200ResponseDataLoans
     */
    'defaulted'?: number;
    /**
     * Total amount disbursed (decimal string)
     * @type {string}
     * @memberof GetAccountStats200ResponseDataLoans
     */
    'totalDisbursed'?: string;
    /**
     * Total outstanding principal (decimal string)
     * @type {string}
     * @memberof GetAccountStats200ResponseDataLoans
     */
    'outstandingPrincipal'?: string;
    /**
     * Total amount repaid (lender only)
     * @type {string}
     * @memberof GetAccountStats200ResponseDataLoans
     */
    'totalRepaid'?: string;
}
/**
 * 
 * @export
 * @interface GetESignUrl200Response
 */
export interface GetESignUrl200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetESignUrl200Response
     */
    'success': boolean;
    /**
     * 
     * @type {GetESignUrl200ResponseData}
     * @memberof GetESignUrl200Response
     */
    'data': GetESignUrl200ResponseData;
}
/**
 * 
 * @export
 * @interface GetESignUrl200ResponseData
 */
export interface GetESignUrl200ResponseData {
    /**
     * The application ID
     * @type {string}
     * @memberof GetESignUrl200ResponseData
     */
    'applicationId': string;
    /**
     * URL for e-signature flow
     * @type {string}
     * @memberof GetESignUrl200ResponseData
     */
    'esignUrl': string;
    /**
     * When the e-sign URL expires
     * @type {string}
     * @memberof GetESignUrl200ResponseData
     */
    'expiresAt': string;
    /**
     * List of documents to sign
     * @type {Array<GetESignUrl200ResponseDataDocumentsInner>}
     * @memberof GetESignUrl200ResponseData
     */
    'documents': Array<GetESignUrl200ResponseDataDocumentsInner>;
    /**
     * 
     * @type {GetESignUrl200ResponseDataEmbedMode}
     * @memberof GetESignUrl200ResponseData
     */
    'embedMode': GetESignUrl200ResponseDataEmbedMode;
}
/**
 * 
 * @export
 * @interface GetESignUrl200ResponseDataDocumentsInner
 */
export interface GetESignUrl200ResponseDataDocumentsInner {
    /**
     * 
     * @type {string}
     * @memberof GetESignUrl200ResponseDataDocumentsInner
     */
    'documentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetESignUrl200ResponseDataDocumentsInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetESignUrl200ResponseDataDocumentsInner
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetESignUrl200ResponseDataDocumentsInner
     */
    'pages'?: number;
}
/**
 * Embed mode configuration
 * @export
 * @interface GetESignUrl200ResponseDataEmbedMode
 */
export interface GetESignUrl200ResponseDataEmbedMode {
    /**
     * 
     * @type {boolean}
     * @memberof GetESignUrl200ResponseDataEmbedMode
     */
    'supported'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetESignUrl200ResponseDataEmbedMode
     */
    'iframeUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetESignUrl200ResponseDataEmbedMode
     */
    'webhookUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface GetFundingById200Response
 */
export interface GetFundingById200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetFundingById200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {FundingRecord}
     * @memberof GetFundingById200Response
     */
    'data'?: FundingRecord;
}
/**
 * 
 * @export
 * @interface GetHardPullConsent200Response
 */
export interface GetHardPullConsent200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetHardPullConsent200Response
     */
    'success': boolean;
    /**
     * 
     * @type {GetHardPullConsent200ResponseData}
     * @memberof GetHardPullConsent200Response
     */
    'data': GetHardPullConsent200ResponseData;
}
/**
 * 
 * @export
 * @interface GetHardPullConsent200ResponseData
 */
export interface GetHardPullConsent200ResponseData {
    /**
     * The application ID
     * @type {string}
     * @memberof GetHardPullConsent200ResponseData
     */
    'applicationId': string;
    /**
     * The accepted offer ID
     * @type {string}
     * @memberof GetHardPullConsent200ResponseData
     */
    'offerId': string;
    /**
     * Type of offer accepted
     * @type {string}
     * @memberof GetHardPullConsent200ResponseData
     */
    'offerType': GetHardPullConsent200ResponseDataOfferTypeEnum | null;
    /**
     * 
     * @type {GetHardPullConsent200ResponseDataConsent}
     * @memberof GetHardPullConsent200ResponseData
     */
    'consent': GetHardPullConsent200ResponseDataConsent;
    /**
     * Additional consent metadata
     * @type {object}
     * @memberof GetHardPullConsent200ResponseData
     */
    'metadata'?: object | null;
}

export const GetHardPullConsent200ResponseDataOfferTypeEnum = {
    Prequalified: 'prequalified',
    Final: 'final'
} as const;

export type GetHardPullConsent200ResponseDataOfferTypeEnum = typeof GetHardPullConsent200ResponseDataOfferTypeEnum[keyof typeof GetHardPullConsent200ResponseDataOfferTypeEnum];

/**
 * 
 * @export
 * @interface GetHardPullConsent200ResponseDataConsent
 */
export interface GetHardPullConsent200ResponseDataConsent {
    /**
     * Whether consent was given
     * @type {boolean}
     * @memberof GetHardPullConsent200ResponseDataConsent
     */
    'given': boolean;
    /**
     * When consent was recorded
     * @type {string}
     * @memberof GetHardPullConsent200ResponseDataConsent
     */
    'timestamp'?: string | null;
    /**
     * IP address of consenting user
     * @type {string}
     * @memberof GetHardPullConsent200ResponseDataConsent
     */
    'ipAddress'?: string | null;
    /**
     * User agent of consenting user
     * @type {string}
     * @memberof GetHardPullConsent200ResponseDataConsent
     */
    'userAgent'?: string | null;
    /**
     * When the offer was accepted
     * @type {string}
     * @memberof GetHardPullConsent200ResponseDataConsent
     */
    'acceptedAt': string;
}
/**
 * 
 * @export
 * @interface GetPendingFundings200Response
 */
export interface GetPendingFundings200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetPendingFundings200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<FundingRecord>}
     * @memberof GetPendingFundings200Response
     */
    'data'?: Array<FundingRecord>;
}
/**
 * 
 * @export
 * @interface GetPlatformPublicKey200Response
 */
export interface GetPlatformPublicKey200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetPlatformPublicKey200Response
     */
    'success': boolean;
    /**
     * 
     * @type {GetPlatformPublicKey200ResponseData}
     * @memberof GetPlatformPublicKey200Response
     */
    'data': GetPlatformPublicKey200ResponseData;
}
/**
 * 
 * @export
 * @interface GetPlatformPublicKey200ResponseData
 */
export interface GetPlatformPublicKey200ResponseData {
    /**
     * Unique identifier for this key
     * @type {string}
     * @memberof GetPlatformPublicKey200ResponseData
     */
    'keyId': string;
    /**
     * PEM-encoded RSA public key
     * @type {string}
     * @memberof GetPlatformPublicKey200ResponseData
     */
    'publicKey': string;
    /**
     * Encryption algorithm
     * @type {string}
     * @memberof GetPlatformPublicKey200ResponseData
     */
    'algorithm': string;
    /**
     * Key size in bits
     * @type {number}
     * @memberof GetPlatformPublicKey200ResponseData
     */
    'keySize': number;
    /**
     * Key usage purpose
     * @type {string}
     * @memberof GetPlatformPublicKey200ResponseData
     */
    'usage': string;
    /**
     * SHA-256 fingerprint of the key
     * @type {string}
     * @memberof GetPlatformPublicKey200ResponseData
     */
    'fingerprint': string;
    /**
     * Key expiration date
     * @type {string}
     * @memberof GetPlatformPublicKey200ResponseData
     */
    'expiresAt'?: string | null;
    /**
     * How often the key is rotated
     * @type {string}
     * @memberof GetPlatformPublicKey200ResponseData
     */
    'rotationSchedule'?: string;
}
/**
 * Infrastructure status statistics
 * @export
 * @interface InfraStats
 */
export interface InfraStats {
    /**
     * Wallets ready for repayment
     * @type {number}
     * @memberof InfraStats
     */
    'ready'?: number;
    /**
     * Wallets pending setup
     * @type {number}
     * @memberof InfraStats
     */
    'pending'?: number;
    /**
     * Wallets being created
     * @type {number}
     * @memberof InfraStats
     */
    'creating'?: number;
    /**
     * Wallets that failed setup
     * @type {number}
     * @memberof InfraStats
     */
    'failed'?: number;
    /**
     * Total loan count
     * @type {number}
     * @memberof InfraStats
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface InitiateKYCRequest
 */
export interface InitiateKYCRequest {
    /**
     * 
     * @type {string}
     * @memberof InitiateKYCRequest
     */
    'provider_code': string;
    /**
     * 
     * @type {string}
     * @memberof InitiateKYCRequest
     */
    'return_url'?: string;
}
/**
 * 
 * @export
 * @interface KYCHandleRequest
 */
export interface KYCHandleRequest {
    /**
     * Application ID
     * @type {string}
     * @memberof KYCHandleRequest
     */
    'applicationId': string;
    /**
     * SDX handle for KYC document
     * @type {string}
     * @memberof KYCHandleRequest
     */
    'kycDocumentHandle': string;
    /**
     * Type of KYC document (e.g., drivers_license, passport, ssn_card)
     * @type {string}
     * @memberof KYCHandleRequest
     */
    'documentType': string;
    /**
     * Additional document metadata
     * @type {{ [key: string]: any; }}
     * @memberof KYCHandleRequest
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * Response from POST /sdx-tokens/kyc-handle
 * @export
 * @interface KYCHandleResponse
 */
export interface KYCHandleResponse {
    /**
     * 
     * @type {boolean}
     * @memberof KYCHandleResponse
     */
    'success': boolean;
    /**
     * 
     * @type {KYCHandleResponseData}
     * @memberof KYCHandleResponse
     */
    'data': KYCHandleResponseData;
}
/**
 * 
 * @export
 * @interface KYCHandleResponseData
 */
export interface KYCHandleResponseData {
    /**
     * Application ID the handle was stored for
     * @type {string}
     * @memberof KYCHandleResponseData
     */
    'applicationId': string;
    /**
     * SDX handle for the KYC document
     * @type {string}
     * @memberof KYCHandleResponseData
     */
    'kycDocumentHandle': string;
    /**
     * When the KYC document was submitted
     * @type {string}
     * @memberof KYCHandleResponseData
     */
    'kycSubmittedAt'?: string | null;
}
/**
 * Response from POST /applications/{applicationId}/kyc/initiate
 * @export
 * @interface KYCInitiateResponse
 */
export interface KYCInitiateResponse {
    /**
     * 
     * @type {boolean}
     * @memberof KYCInitiateResponse
     */
    'success': boolean;
    /**
     * 
     * @type {KYCInitiateResponseData}
     * @memberof KYCInitiateResponse
     */
    'data': KYCInitiateResponseData;
}
/**
 * 
 * @export
 * @interface KYCInitiateResponseData
 */
export interface KYCInitiateResponseData {
    /**
     * KYC session ID
     * @type {string}
     * @memberof KYCInitiateResponseData
     */
    'sessionId': string;
    /**
     * URL to redirect user for KYC verification
     * @type {string}
     * @memberof KYCInitiateResponseData
     */
    'redirectUrl': string;
    /**
     * 
     * @type {string}
     * @memberof KYCInitiateResponseData
     */
    'expiresAt'?: string;
}
/**
 * Response from GET /providers
 * @export
 * @interface KYCProvidersResponse
 */
export interface KYCProvidersResponse {
    /**
     * 
     * @type {boolean}
     * @memberof KYCProvidersResponse
     */
    'success': boolean;
    /**
     * 
     * @type {KYCProvidersResponseData}
     * @memberof KYCProvidersResponse
     */
    'data': KYCProvidersResponseData;
}
/**
 * 
 * @export
 * @interface KYCProvidersResponseData
 */
export interface KYCProvidersResponseData {
    /**
     * 
     * @type {Array<KYCProvidersResponseDataProvidersInner>}
     * @memberof KYCProvidersResponseData
     */
    'providers': Array<KYCProvidersResponseDataProvidersInner>;
}
/**
 * 
 * @export
 * @interface KYCProvidersResponseDataProvidersInner
 */
export interface KYCProvidersResponseDataProvidersInner {
    /**
     * 
     * @type {string}
     * @memberof KYCProvidersResponseDataProvidersInner
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof KYCProvidersResponseDataProvidersInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof KYCProvidersResponseDataProvidersInner
     */
    'type'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof KYCProvidersResponseDataProvidersInner
     */
    'supportedVerifications'?: Array<string>;
}
/**
 * Response from GET /applications/{applicationId}/kyc/status
 * @export
 * @interface KYCStatusResponse
 */
export interface KYCStatusResponse {
    /**
     * 
     * @type {boolean}
     * @memberof KYCStatusResponse
     */
    'success': boolean;
    /**
     * 
     * @type {KYCStatusResponseData}
     * @memberof KYCStatusResponse
     */
    'data': KYCStatusResponseData;
}
/**
 * 
 * @export
 * @interface KYCStatusResponseData
 */
export interface KYCStatusResponseData {
    /**
     * 
     * @type {string}
     * @memberof KYCStatusResponseData
     */
    'applicationId': string;
    /**
     * 
     * @type {string}
     * @memberof KYCStatusResponseData
     */
    'status': KYCStatusResponseDataStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof KYCStatusResponseData
     */
    'kycSubmittedAt'?: string | null;
    /**
     * 
     * @type {Array<KYCStatusResponseDataAttestationsInner>}
     * @memberof KYCStatusResponseData
     */
    'attestations'?: Array<KYCStatusResponseDataAttestationsInner>;
}

export const KYCStatusResponseDataStatusEnum = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type KYCStatusResponseDataStatusEnum = typeof KYCStatusResponseDataStatusEnum[keyof typeof KYCStatusResponseDataStatusEnum];

/**
 * 
 * @export
 * @interface KYCStatusResponseDataAttestationsInner
 */
export interface KYCStatusResponseDataAttestationsInner {
    /**
     * 
     * @type {string}
     * @memberof KYCStatusResponseDataAttestationsInner
     */
    'attestationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof KYCStatusResponseDataAttestationsInner
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof KYCStatusResponseDataAttestationsInner
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof KYCStatusResponseDataAttestationsInner
     */
    'performedAt'?: string;
}
/**
 * Response from GET /keys/history
 * @export
 * @interface KeyHistoryResponse
 */
export interface KeyHistoryResponse {
    /**
     * 
     * @type {boolean}
     * @memberof KeyHistoryResponse
     */
    'success': boolean;
    /**
     * 
     * @type {KeyHistoryResponseData}
     * @memberof KeyHistoryResponse
     */
    'data': KeyHistoryResponseData;
}
/**
 * 
 * @export
 * @interface KeyHistoryResponseData
 */
export interface KeyHistoryResponseData {
    /**
     * 
     * @type {Array<KeyHistoryResponseDataKeysInner>}
     * @memberof KeyHistoryResponseData
     */
    'keys': Array<KeyHistoryResponseDataKeysInner>;
}
/**
 * 
 * @export
 * @interface KeyHistoryResponseDataKeysInner
 */
export interface KeyHistoryResponseDataKeysInner {
    /**
     * 
     * @type {string}
     * @memberof KeyHistoryResponseDataKeysInner
     */
    'keyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeyHistoryResponseDataKeysInner
     */
    'status'?: KeyHistoryResponseDataKeysInnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof KeyHistoryResponseDataKeysInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeyHistoryResponseDataKeysInner
     */
    'activatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KeyHistoryResponseDataKeysInner
     */
    'expiresAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KeyHistoryResponseDataKeysInner
     */
    'revokedAt'?: string | null;
}

export const KeyHistoryResponseDataKeysInnerStatusEnum = {
    Active: 'ACTIVE',
    PendingActivation: 'PENDING_ACTIVATION',
    RotatingOut: 'ROTATING_OUT',
    Revoked: 'REVOKED',
    Expired: 'EXPIRED'
} as const;

export type KeyHistoryResponseDataKeysInnerStatusEnum = typeof KeyHistoryResponseDataKeysInnerStatusEnum[keyof typeof KeyHistoryResponseDataKeysInnerStatusEnum];

/**
 * Response from POST /keys/{keyId}/revoke
 * @export
 * @interface KeyRevokeResponse
 */
export interface KeyRevokeResponse {
    /**
     * 
     * @type {boolean}
     * @memberof KeyRevokeResponse
     */
    'success': boolean;
    /**
     * 
     * @type {KeyRevokeResponseData}
     * @memberof KeyRevokeResponse
     */
    'data': KeyRevokeResponseData;
}
/**
 * 
 * @export
 * @interface KeyRevokeResponseData
 */
export interface KeyRevokeResponseData {
    /**
     * 
     * @type {string}
     * @memberof KeyRevokeResponseData
     */
    'revokedKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof KeyRevokeResponseData
     */
    'newKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof KeyRevokeResponseData
     */
    'status': KeyRevokeResponseDataStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof KeyRevokeResponseData
     */
    'revokedAt'?: string;
}

export const KeyRevokeResponseDataStatusEnum = {
    Revoked: 'REVOKED'
} as const;

export type KeyRevokeResponseDataStatusEnum = typeof KeyRevokeResponseDataStatusEnum[keyof typeof KeyRevokeResponseDataStatusEnum];

/**
 * Response from POST /keys/rotate
 * @export
 * @interface KeyRotationResponse
 */
export interface KeyRotationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof KeyRotationResponse
     */
    'success': boolean;
    /**
     * 
     * @type {KeyRotationResponseData}
     * @memberof KeyRotationResponse
     */
    'data': KeyRotationResponseData;
}
/**
 * 
 * @export
 * @interface KeyRotationResponseData
 */
export interface KeyRotationResponseData {
    /**
     * ID of the new key
     * @type {string}
     * @memberof KeyRotationResponseData
     */
    'keyId': string;
    /**
     * 
     * @type {string}
     * @memberof KeyRotationResponseData
     */
    'status': KeyRotationResponseDataStatusEnum;
    /**
     * When the key becomes active
     * @type {string}
     * @memberof KeyRotationResponseData
     */
    'activatesAt': string;
    /**
     * ID of the key being replaced
     * @type {string}
     * @memberof KeyRotationResponseData
     */
    'previousKeyId'?: string;
    /**
     * Days of overlap before previous key expires
     * @type {number}
     * @memberof KeyRotationResponseData
     */
    'rotationPeriodDays'?: number;
}

export const KeyRotationResponseDataStatusEnum = {
    PendingActivation: 'PENDING_ACTIVATION',
    Active: 'ACTIVE'
} as const;

export type KeyRotationResponseDataStatusEnum = typeof KeyRotationResponseDataStatusEnum[keyof typeof KeyRotationResponseDataStatusEnum];

/**
 * 
 * @export
 * @interface LenderDetail
 */
export interface LenderDetail {
    /**
     * 
     * @type {string}
     * @memberof LenderDetail
     */
    'lenderId': string;
    /**
     * 
     * @type {string}
     * @memberof LenderDetail
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LenderDetail
     */
    'supportedProducts': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof LenderDetail
     */
    'isActive': boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof LenderDetail
     */
    'metadata'?: { [key: string]: any; };
    /**
     * 
     * @type {LenderDetailPublicKey}
     * @memberof LenderDetail
     */
    'publicKey'?: LenderDetailPublicKey;
}
/**
 * 
 * @export
 * @interface LenderDetailPublicKey
 */
export interface LenderDetailPublicKey {
    /**
     * 
     * @type {string}
     * @memberof LenderDetailPublicKey
     */
    'keyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof LenderDetailPublicKey
     */
    'expiresAt'?: string | null;
}
/**
 * Response from GET /lenders/{lenderId}
 * @export
 * @interface LenderDetailResponse
 */
export interface LenderDetailResponse {
    /**
     * 
     * @type {boolean}
     * @memberof LenderDetailResponse
     */
    'success': boolean;
    /**
     * 
     * @type {LenderDetailResponseData}
     * @memberof LenderDetailResponse
     */
    'data': LenderDetailResponseData;
}
/**
 * 
 * @export
 * @interface LenderDetailResponseData
 */
export interface LenderDetailResponseData {
    /**
     * 
     * @type {LenderDetail}
     * @memberof LenderDetailResponseData
     */
    'lender': LenderDetail;
    /**
     * 
     * @type {string}
     * @memberof LenderDetailResponseData
     */
    'retrievedAt': string;
}
/**
 * Lender summary for list endpoint
 * @export
 * @interface LenderListItem
 */
export interface LenderListItem {
    /**
     * Unique lender identifier
     * @type {string}
     * @memberof LenderListItem
     */
    'lenderId': string;
    /**
     * Lender display name
     * @type {string}
     * @memberof LenderListItem
     */
    'name': string;
    /**
     * Product types this lender supports
     * @type {Array<string>}
     * @memberof LenderListItem
     */
    'supportedProducts': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof LenderListItem
     */
    'isActive': boolean;
    /**
     * Additional lender metadata
     * @type {{ [key: string]: any; }}
     * @memberof LenderListItem
     */
    'metadata'?: { [key: string]: any; };
    /**
     * Lender\'s public key (for encryption)
     * @type {string}
     * @memberof LenderListItem
     */
    'publicKey'?: string | null;
}
/**
 * Response from GET /lenders
 * @export
 * @interface LenderListResponse
 */
export interface LenderListResponse {
    /**
     * 
     * @type {boolean}
     * @memberof LenderListResponse
     */
    'success': boolean;
    /**
     * 
     * @type {LenderListResponseData}
     * @memberof LenderListResponse
     */
    'data': LenderListResponseData;
}
/**
 * 
 * @export
 * @interface LenderListResponseData
 */
export interface LenderListResponseData {
    /**
     * 
     * @type {Array<LenderListItem>}
     * @memberof LenderListResponseData
     */
    'lenders': Array<LenderListItem>;
    /**
     * Total number of lenders returned
     * @type {number}
     * @memberof LenderListResponseData
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof LenderListResponseData
     */
    'retrievedAt': string;
}
/**
 * 
 * @export
 * @interface LenderOffersResponse
 */
export interface LenderOffersResponse {
    /**
     * 
     * @type {boolean}
     * @memberof LenderOffersResponse
     */
    'success': boolean;
    /**
     * 
     * @type {LenderOffersResponseData}
     * @memberof LenderOffersResponse
     */
    'data': LenderOffersResponseData;
}
/**
 * 
 * @export
 * @interface LenderOffersResponseData
 */
export interface LenderOffersResponseData {
    /**
     * 
     * @type {Array<EncryptedOffer>}
     * @memberof LenderOffersResponseData
     */
    'offers': Array<EncryptedOffer>;
    /**
     * 
     * @type {LenderOffersResponseDataPagination}
     * @memberof LenderOffersResponseData
     */
    'pagination': LenderOffersResponseDataPagination;
    /**
     * 
     * @type {string}
     * @memberof LenderOffersResponseData
     */
    'requestId'?: string;
}
/**
 * 
 * @export
 * @interface LenderOffersResponseDataPagination
 */
export interface LenderOffersResponseDataPagination {
    /**
     * 
     * @type {number}
     * @memberof LenderOffersResponseDataPagination
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof LenderOffersResponseDataPagination
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof LenderOffersResponseDataPagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof LenderOffersResponseDataPagination
     */
    'pages'?: number;
}
/**
 * Response from GET /lenders/{lenderId}/public-key
 * @export
 * @interface LenderPublicKeyResponse
 */
export interface LenderPublicKeyResponse {
    /**
     * 
     * @type {boolean}
     * @memberof LenderPublicKeyResponse
     */
    'success': boolean;
    /**
     * 
     * @type {LenderPublicKeyResponseData}
     * @memberof LenderPublicKeyResponse
     */
    'data': LenderPublicKeyResponseData;
}
/**
 * 
 * @export
 * @interface LenderPublicKeyResponseData
 */
export interface LenderPublicKeyResponseData {
    /**
     * 
     * @type {string}
     * @memberof LenderPublicKeyResponseData
     */
    'lenderId': string;
    /**
     * PEM-encoded RSA public key
     * @type {string}
     * @memberof LenderPublicKeyResponseData
     */
    'publicKey': string;
    /**
     * 
     * @type {string}
     * @memberof LenderPublicKeyResponseData
     */
    'algorithm': string;
    /**
     * 
     * @type {string}
     * @memberof LenderPublicKeyResponseData
     */
    'keyId': string;
    /**
     * 
     * @type {string}
     * @memberof LenderPublicKeyResponseData
     */
    'expiresAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LenderPublicKeyResponseData
     */
    'retrievedAt': string;
}
/**
 * 
 * @export
 * @interface ListApplications200Response
 */
export interface ListApplications200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ListApplications200ResponseData}
     * @memberof ListApplications200Response
     */
    'data': ListApplications200ResponseData;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseData
 */
export interface ListApplications200ResponseData {
    /**
     * For neobanks: includes neobankId, externalId, createdAt For lenders: includes routedAt instead of createdAt 
     * @type {Array<ApplicationListItem>}
     * @memberof ListApplications200ResponseData
     */
    'applications': Array<ApplicationListItem>;
}
/**
 * @type ListLoanRepayments200Response
 * @export
 */
export type ListLoanRepayments200Response = BridgeRepaymentListResponse | RepaymentListResponse;

/**
 * Loan record with nested disbursement, terms, state, and repayment info
 * @export
 * @interface Loan
 */
export interface Loan {
    /**
     * Unique loan identifier
     * @type {string}
     * @memberof Loan
     */
    'id': string;
    /**
     * Associated funding record ID
     * @type {string}
     * @memberof Loan
     */
    'fundingId': string;
    /**
     * Associated application ID
     * @type {string}
     * @memberof Loan
     */
    'applicationId': string;
    /**
     * Lender entity ID
     * @type {string}
     * @memberof Loan
     */
    'lenderId': string;
    /**
     * Neobank entity ID
     * @type {string}
     * @memberof Loan
     */
    'neobankId': string;
    /**
     * 
     * @type {LoanStatus}
     * @memberof Loan
     */
    'status': LoanStatus;
    /**
     * 
     * @type {LoanDisbursement}
     * @memberof Loan
     */
    'disbursement': LoanDisbursement;
    /**
     * 
     * @type {LoanRepayment}
     * @memberof Loan
     */
    'repayment': LoanRepayment;
    /**
     * 
     * @type {LoanTerms}
     * @memberof Loan
     */
    'terms': LoanTerms;
    /**
     * 
     * @type {LoanState}
     * @memberof Loan
     */
    'state': LoanState;
    /**
     * 
     * @type {string}
     * @memberof Loan
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Loan
     */
    'updatedAt': string;
}


/**
 * Immutable facts about the loan disbursement
 * @export
 * @interface LoanDisbursement
 */
export interface LoanDisbursement {
    /**
     * Disbursed amount (string for precision)
     * @type {string}
     * @memberof LoanDisbursement
     */
    'amount': string;
    /**
     * Currency of disbursement
     * @type {string}
     * @memberof LoanDisbursement
     */
    'currency': string;
    /**
     * When funds were disbursed
     * @type {string}
     * @memberof LoanDisbursement
     */
    'disbursedAt': string;
    /**
     * Blockchain transaction hash of disbursement
     * @type {string}
     * @memberof LoanDisbursement
     */
    'txHash'?: string | null;
    /**
     * Wallet address where funds were sent
     * @type {string}
     * @memberof LoanDisbursement
     */
    'borrowerAddress': string;
    /**
     * Blockchain network of disbursement
     * @type {string}
     * @memberof LoanDisbursement
     */
    'borrowerChain': string;
}
/**
 * 
 * @export
 * @interface LoanListResponse
 */
export interface LoanListResponse {
    /**
     * 
     * @type {boolean}
     * @memberof LoanListResponse
     */
    'success': boolean;
    /**
     * 
     * @type {LoanListResponseData}
     * @memberof LoanListResponse
     */
    'data': LoanListResponseData;
}
/**
 * 
 * @export
 * @interface LoanListResponseData
 */
export interface LoanListResponseData {
    /**
     * 
     * @type {Array<Loan>}
     * @memberof LoanListResponseData
     */
    'loans': Array<Loan>;
    /**
     * 
     * @type {LoanListResponseDataPagination}
     * @memberof LoanListResponseData
     */
    'pagination': LoanListResponseDataPagination;
}
/**
 * 
 * @export
 * @interface LoanListResponseDataPagination
 */
export interface LoanListResponseDataPagination {
    /**
     * 
     * @type {number}
     * @memberof LoanListResponseDataPagination
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof LoanListResponseDataPagination
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof LoanListResponseDataPagination
     */
    'offset': number;
    /**
     * 
     * @type {boolean}
     * @memberof LoanListResponseDataPagination
     */
    'hasMore': boolean;
}
/**
 * Repayment infrastructure details (Bridge resources)
 * @export
 * @interface LoanRepayment
 */
export interface LoanRepayment {
    /**
     * Bridge liquidation address where borrower sends USDC payments
     * @type {string}
     * @memberof LoanRepayment
     */
    'address'?: string | null;
    /**
     * Blockchain network for repayments
     * @type {string}
     * @memberof LoanRepayment
     */
    'chain': string;
    /**
     * Repayment infrastructure status
     * @type {string}
     * @memberof LoanRepayment
     */
    'status': LoanRepaymentStatusEnum;
    /**
     * Bridge wallet ID for this loan (for Bridge API calls)
     * @type {string}
     * @memberof LoanRepayment
     */
    'walletId'?: string | null;
    /**
     * On-chain address of the per-loan Bridge wallet
     * @type {string}
     * @memberof LoanRepayment
     */
    'walletAddress'?: string | null;
    /**
     * Bridge liquidation address ID (for Bridge API calls)
     * @type {string}
     * @memberof LoanRepayment
     */
    'liquidationAddressId'?: string | null;
}

export const LoanRepaymentStatusEnum = {
    Pending: 'pending',
    Creating: 'creating',
    Ready: 'ready',
    Failed: 'failed',
    FailedNotified: 'failed_notified'
} as const;

export type LoanRepaymentStatusEnum = typeof LoanRepaymentStatusEnum[keyof typeof LoanRepaymentStatusEnum];

/**
 * 
 * @export
 * @interface LoanResponse
 */
export interface LoanResponse {
    /**
     * 
     * @type {boolean}
     * @memberof LoanResponse
     */
    'success': boolean;
    /**
     * 
     * @type {Loan}
     * @memberof LoanResponse
     */
    'data': Loan;
    /**
     * Optional success message
     * @type {string}
     * @memberof LoanResponse
     */
    'message'?: string;
}
/**
 * Current loan state (calculated or lender-overridden)
 * @export
 * @interface LoanState
 */
export interface LoanState {
    /**
     * Current outstanding principal balance
     * @type {string}
     * @memberof LoanState
     */
    'principalBalance': string;
    /**
     * Total amount paid to date
     * @type {string}
     * @memberof LoanState
     */
    'totalPaid': string;
    /**
     * Total principal paid to date
     * @type {string}
     * @memberof LoanState
     */
    'totalPrincipalPaid': string;
    /**
     * Total interest paid to date
     * @type {string}
     * @memberof LoanState
     */
    'totalInterestPaid': string;
    /**
     * Current payoff amount (principal + accrued interest)
     * @type {string}
     * @memberof LoanState
     */
    'payoffAmount'?: string;
    /**
     * Date the payoff amount was calculated
     * @type {string}
     * @memberof LoanState
     */
    'payoffAsOfDate'?: string;
    /**
     * Next payment due date
     * @type {string}
     * @memberof LoanState
     */
    'nextPaymentDue'?: string | null;
    /**
     * Next payment amount
     * @type {string}
     * @memberof LoanState
     */
    'nextPaymentAmount'?: string | null;
    /**
     * Number of payments completed
     * @type {number}
     * @memberof LoanState
     */
    'paymentsMade': number;
    /**
     * Estimated payments remaining
     * @type {number}
     * @memberof LoanState
     */
    'paymentsRemaining'?: number | null;
    /**
     * Date of most recent payment
     * @type {string}
     * @memberof LoanState
     */
    'lastPaymentDate'?: string | null;
    /**
     * Whether lender override is in effect
     * @type {boolean}
     * @memberof LoanState
     */
    'isLenderOverride': boolean;
    /**
     * When state was last calculated
     * @type {string}
     * @memberof LoanState
     */
    'calculatedAt'?: string | null;
}
/**
 * Request to apply lender override to loan state
 * @export
 * @interface LoanStateOverrideRequest
 */
export interface LoanStateOverrideRequest {
    /**
     * 
     * @type {LoanStatus}
     * @memberof LoanStateOverrideRequest
     */
    'status': LoanStatus;
    /**
     * Reason for the override
     * @type {string}
     * @memberof LoanStateOverrideRequest
     */
    'reason': string;
    /**
     * Effective date of the override
     * @type {string}
     * @memberof LoanStateOverrideRequest
     */
    'effectiveDate'?: string;
}


/**
 * Current status of the loan
 * @export
 * @enum {string}
 */

export const LoanStatus = {
    Active: 'ACTIVE',
    PaidOff: 'PAID_OFF',
    Delinquent: 'DELINQUENT',
    Defaulted: 'DEFAULTED',
    Closed: 'CLOSED'
} as const;

export type LoanStatus = typeof LoanStatus[keyof typeof LoanStatus];


/**
 * Loan sweep request
 * @export
 * @interface LoanSweepRequest
 */
export interface LoanSweepRequest {
    /**
     * Specific amount to sweep (defaults to full balance if omitted)
     * @type {string}
     * @memberof LoanSweepRequest
     */
    'amount'?: string;
}
/**
 * Loan sweep response
 * @export
 * @interface LoanSweepResponse
 */
export interface LoanSweepResponse {
    /**
     * 
     * @type {boolean}
     * @memberof LoanSweepResponse
     */
    'success': boolean;
    /**
     * Human-readable result message
     * @type {string}
     * @memberof LoanSweepResponse
     */
    'message': string;
    /**
     * 
     * @type {LoanSweepResponseLoan}
     * @memberof LoanSweepResponse
     */
    'loan'?: LoanSweepResponseLoan;
    /**
     * 
     * @type {LoanSweepResponseWallet}
     * @memberof LoanSweepResponse
     */
    'wallet'?: LoanSweepResponseWallet;
    /**
     * 
     * @type {LoanSweepResponseTransfer}
     * @memberof LoanSweepResponse
     */
    'transfer'?: LoanSweepResponseTransfer;
    /**
     * Whether a sweep was executed (false if balance too low)
     * @type {boolean}
     * @memberof LoanSweepResponse
     */
    'swept'?: boolean;
    /**
     * Reason if sweep was not executed
     * @type {string}
     * @memberof LoanSweepResponse
     */
    'reason'?: string;
    /**
     * Destination master wallet ID
     * @type {string}
     * @memberof LoanSweepResponse
     */
    'masterWalletId'?: string;
    /**
     * Timestamp of execution
     * @type {string}
     * @memberof LoanSweepResponse
     */
    'executedAt'?: string;
}
/**
 * 
 * @export
 * @interface LoanSweepResponseLoan
 */
export interface LoanSweepResponseLoan {
    /**
     * Loan ID
     * @type {string}
     * @memberof LoanSweepResponseLoan
     */
    'id'?: string;
    /**
     * Current loan status
     * @type {string}
     * @memberof LoanSweepResponseLoan
     */
    'status'?: string;
}
/**
 * Transfer details (present if sweep was executed)
 * @export
 * @interface LoanSweepResponseTransfer
 */
export interface LoanSweepResponseTransfer {
    /**
     * Bridge transfer ID
     * @type {string}
     * @memberof LoanSweepResponseTransfer
     */
    'id'?: string;
    /**
     * Transfer state
     * @type {string}
     * @memberof LoanSweepResponseTransfer
     */
    'state'?: string;
    /**
     * Amount transferred
     * @type {string}
     * @memberof LoanSweepResponseTransfer
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface LoanSweepResponseWallet
 */
export interface LoanSweepResponseWallet {
    /**
     * Wallet ID
     * @type {string}
     * @memberof LoanSweepResponseWallet
     */
    'id'?: string;
    /**
     * Wallet address
     * @type {string}
     * @memberof LoanSweepResponseWallet
     */
    'address'?: string | null;
    /**
     * Blockchain chain
     * @type {string}
     * @memberof LoanSweepResponseWallet
     */
    'chain'?: string;
    /**
     * Current or previous balance
     * @type {string}
     * @memberof LoanSweepResponseWallet
     */
    'balance'?: string;
    /**
     * Balance before sweep
     * @type {string}
     * @memberof LoanSweepResponseWallet
     */
    'previousBalance'?: string;
}
/**
 * Loan terms (from accepted offer)
 * @export
 * @interface LoanTerms
 */
export interface LoanTerms {
    /**
     * Original loan principal amount (string for precision)
     * @type {string}
     * @memberof LoanTerms
     */
    'principal': string;
    /**
     * Annual interest rate as decimal (e.g., 0.054900 for 5.49%)
     * @type {string}
     * @memberof LoanTerms
     */
    'annualRate': string;
    /**
     * Loan term in months
     * @type {number}
     * @memberof LoanTerms
     */
    'termMonths': number;
    /**
     * Monthly payment amount
     * @type {string}
     * @memberof LoanTerms
     */
    'monthlyPayment': string;
    /**
     * First payment due date
     * @type {string}
     * @memberof LoanTerms
     */
    'firstPaymentDue': string;
    /**
     * Loan maturity date
     * @type {string}
     * @memberof LoanTerms
     */
    'maturityDate': string;
}
/**
 * Request to update loan terms (all fields optional, at least one required)
 * @export
 * @interface LoanTermsUpdateRequest
 */
export interface LoanTermsUpdateRequest {
    /**
     * Updated annual interest rate as decimal
     * @type {string}
     * @memberof LoanTermsUpdateRequest
     */
    'annualRate'?: string;
    /**
     * Updated monthly payment amount
     * @type {string}
     * @memberof LoanTermsUpdateRequest
     */
    'monthlyPayment'?: string;
    /**
     * Updated loan term in months
     * @type {number}
     * @memberof LoanTermsUpdateRequest
     */
    'termMonths'?: number;
}
/**
 * Per-loan wallet information
 * @export
 * @interface LoanWallet
 */
export interface LoanWallet {
    /**
     * Loan ID
     * @type {string}
     * @memberof LoanWallet
     */
    'loanId'?: string;
    /**
     * Current loan status
     * @type {string}
     * @memberof LoanWallet
     */
    'loanStatus'?: string;
    /**
     * Bridge wallet ID
     * @type {string}
     * @memberof LoanWallet
     */
    'walletId'?: string | null;
    /**
     * Wallet blockchain address
     * @type {string}
     * @memberof LoanWallet
     */
    'walletAddress'?: string | null;
    /**
     * Bridge liquidation address ID
     * @type {string}
     * @memberof LoanWallet
     */
    'liquidationAddressId'?: string | null;
    /**
     * Liquidation address for repayments
     * @type {string}
     * @memberof LoanWallet
     */
    'liquidationAddress'?: string | null;
    /**
     * Repayment infrastructure status
     * @type {string}
     * @memberof LoanWallet
     */
    'infraStatus'?: LoanWalletInfraStatusEnum;
    /**
     * USDC balance
     * @type {string}
     * @memberof LoanWallet
     */
    'balance'?: string | null;
    /**
     * Blockchain chain
     * @type {string}
     * @memberof LoanWallet
     */
    'chain'?: string;
}

export const LoanWalletInfraStatusEnum = {
    Pending: 'pending',
    Creating: 'creating',
    Ready: 'ready',
    Failed: 'failed',
    FailedNotified: 'failed_notified'
} as const;

export type LoanWalletInfraStatusEnum = typeof LoanWalletInfraStatusEnum[keyof typeof LoanWalletInfraStatusEnum];

/**
 * 
 * @export
 * @interface LoanWalletResponse
 */
export interface LoanWalletResponse {
    /**
     * 
     * @type {boolean}
     * @memberof LoanWalletResponse
     */
    'success': boolean;
    /**
     * 
     * @type {LoanWalletResponseData}
     * @memberof LoanWalletResponse
     */
    'data': LoanWalletResponseData;
    /**
     * Timestamp of when data was fetched
     * @type {string}
     * @memberof LoanWalletResponse
     */
    'fetchedAt': string;
}
/**
 * 
 * @export
 * @interface LoanWalletResponseData
 */
export interface LoanWalletResponseData {
    /**
     * 
     * @type {LoanWalletResponseDataLoan}
     * @memberof LoanWalletResponseData
     */
    'loan': LoanWalletResponseDataLoan;
    /**
     * 
     * @type {LoanWalletResponseDataWallet}
     * @memberof LoanWalletResponseData
     */
    'wallet': LoanWalletResponseDataWallet;
    /**
     * 
     * @type {LoanWalletResponseDataLiquidationAddress}
     * @memberof LoanWalletResponseData
     */
    'liquidationAddress': LoanWalletResponseDataLiquidationAddress;
}
/**
 * 
 * @export
 * @interface LoanWalletResponseDataLiquidationAddress
 */
export interface LoanWalletResponseDataLiquidationAddress {
    /**
     * Bridge liquidation address ID
     * @type {string}
     * @memberof LoanWalletResponseDataLiquidationAddress
     */
    'id': string | null;
    /**
     * Address borrower pays to
     * @type {string}
     * @memberof LoanWalletResponseDataLiquidationAddress
     */
    'address': string | null;
    /**
     * Liquidation address status
     * @type {string}
     * @memberof LoanWalletResponseDataLiquidationAddress
     */
    'status': LoanWalletResponseDataLiquidationAddressStatusEnum;
    /**
     * Wallet ID where funds are routed
     * @type {string}
     * @memberof LoanWalletResponseDataLiquidationAddress
     */
    'destinationWalletId': string | null;
}

export const LoanWalletResponseDataLiquidationAddressStatusEnum = {
    Active: 'active',
    Deactivated: 'deactivated',
    Unknown: 'unknown'
} as const;

export type LoanWalletResponseDataLiquidationAddressStatusEnum = typeof LoanWalletResponseDataLiquidationAddressStatusEnum[keyof typeof LoanWalletResponseDataLiquidationAddressStatusEnum];

/**
 * 
 * @export
 * @interface LoanWalletResponseDataLoan
 */
export interface LoanWalletResponseDataLoan {
    /**
     * Loan ID
     * @type {string}
     * @memberof LoanWalletResponseDataLoan
     */
    'id': string;
    /**
     * Status of repayment infrastructure
     * @type {string}
     * @memberof LoanWalletResponseDataLoan
     */
    'repaymentInfraStatus': LoanWalletResponseDataLoanRepaymentInfraStatusEnum;
}

export const LoanWalletResponseDataLoanRepaymentInfraStatusEnum = {
    Pending: 'pending',
    Creating: 'creating',
    Ready: 'ready',
    Failed: 'failed'
} as const;

export type LoanWalletResponseDataLoanRepaymentInfraStatusEnum = typeof LoanWalletResponseDataLoanRepaymentInfraStatusEnum[keyof typeof LoanWalletResponseDataLoanRepaymentInfraStatusEnum];

/**
 * 
 * @export
 * @interface LoanWalletResponseDataWallet
 */
export interface LoanWalletResponseDataWallet {
    /**
     * Bridge wallet ID
     * @type {string}
     * @memberof LoanWalletResponseDataWallet
     */
    'id': string | null;
    /**
     * On-chain wallet address
     * @type {string}
     * @memberof LoanWalletResponseDataWallet
     */
    'address': string | null;
    /**
     * Blockchain network
     * @type {string}
     * @memberof LoanWalletResponseDataWallet
     */
    'chain': string;
    /**
     * USDC balance in the wallet
     * @type {string}
     * @memberof LoanWalletResponseDataWallet
     */
    'balance': string | null;
    /**
     * Timestamp when balance was fetched
     * @type {string}
     * @memberof LoanWalletResponseDataWallet
     */
    'balanceFetchedAt': string | null;
}
/**
 * Main treasury wallet
 * @export
 * @interface MainWallet
 */
export interface MainWallet {
    /**
     * Bridge wallet ID
     * @type {string}
     * @memberof MainWallet
     */
    'id'?: string;
    /**
     * Wallet blockchain address
     * @type {string}
     * @memberof MainWallet
     */
    'address'?: string;
    /**
     * Blockchain chain
     * @type {string}
     * @memberof MainWallet
     */
    'chain'?: string;
    /**
     * USDC balance
     * @type {string}
     * @memberof MainWallet
     */
    'balance'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Machine-readable error code (SCREAMING_SNAKE_CASE)
     * @type {string}
     * @memberof ModelError
     */
    'error': string;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * HTTP status code
     * @type {number}
     * @memberof ModelError
     */
    'status': number;
    /**
     * Request correlation ID for debugging
     * @type {string}
     * @memberof ModelError
     */
    'requestId': string;
    /**
     * Detailed validation errors (for VALIDATION_ERROR)
     * @type {Array<ErrorDetailsInner>}
     * @memberof ModelError
     */
    'details'?: Array<ErrorDetailsInner>;
}
/**
 * Neobank account information
 * @export
 * @interface NeobankAccountResponse
 */
export interface NeobankAccountResponse {
    /**
     * 
     * @type {boolean}
     * @memberof NeobankAccountResponse
     */
    'success': boolean;
    /**
     * 
     * @type {NeobankAccountResponseData}
     * @memberof NeobankAccountResponse
     */
    'data': NeobankAccountResponseData;
}
/**
 * 
 * @export
 * @interface NeobankAccountResponseData
 */
export interface NeobankAccountResponseData {
    /**
     * Unique identifier for the neobank
     * @type {string}
     * @memberof NeobankAccountResponseData
     */
    'neobankId': string;
    /**
     * Neobank display name
     * @type {string}
     * @memberof NeobankAccountResponseData
     */
    'name': string;
    /**
     * URL for receiving webhook notifications
     * @type {string}
     * @memberof NeobankAccountResponseData
     */
    'webhookUrl'?: string | null;
    /**
     * Product types this neobank is allowed to offer
     * @type {Array<string>}
     * @memberof NeobankAccountResponseData
     */
    'allowedProducts'?: Array<string>;
    /**
     * API rate limit (requests per minute)
     * @type {number}
     * @memberof NeobankAccountResponseData
     */
    'rateLimit'?: number;
    /**
     * Whether the neobank account is active
     * @type {boolean}
     * @memberof NeobankAccountResponseData
     */
    'isActive': boolean;
    /**
     * When the account was created
     * @type {string}
     * @memberof NeobankAccountResponseData
     */
    'createdAt': string;
}
/**
 * Response from GET /neobanks/{neobankId}
 * @export
 * @interface NeobankDetailResponse
 */
export interface NeobankDetailResponse {
    /**
     * 
     * @type {boolean}
     * @memberof NeobankDetailResponse
     */
    'success': boolean;
    /**
     * 
     * @type {NeobankDetailResponseData}
     * @memberof NeobankDetailResponse
     */
    'data': NeobankDetailResponseData;
}
/**
 * 
 * @export
 * @interface NeobankDetailResponseData
 */
export interface NeobankDetailResponseData {
    /**
     * 
     * @type {string}
     * @memberof NeobankDetailResponseData
     */
    'neobankId': string;
    /**
     * 
     * @type {string}
     * @memberof NeobankDetailResponseData
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NeobankDetailResponseData
     */
    'isActive': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NeobankDetailResponseData
     */
    'allowedProducts': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NeobankDetailResponseData
     */
    'webhookUrl'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NeobankDetailResponseData
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * Neobank summary for list endpoint
 * @export
 * @interface NeobankListItem
 */
export interface NeobankListItem {
    /**
     * 
     * @type {string}
     * @memberof NeobankListItem
     */
    'neobankId': string;
    /**
     * 
     * @type {string}
     * @memberof NeobankListItem
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NeobankListItem
     */
    'allowedProducts': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NeobankListItem
     */
    'webhookUrl'?: string | null;
}
/**
 * Response from GET /neobanks
 * @export
 * @interface NeobankListResponse
 */
export interface NeobankListResponse {
    /**
     * 
     * @type {boolean}
     * @memberof NeobankListResponse
     */
    'success': boolean;
    /**
     * 
     * @type {NeobankListResponseData}
     * @memberof NeobankListResponse
     */
    'data': NeobankListResponseData;
}
/**
 * 
 * @export
 * @interface NeobankListResponseData
 */
export interface NeobankListResponseData {
    /**
     * 
     * @type {Array<NeobankListItem>}
     * @memberof NeobankListResponseData
     */
    'neobanks': Array<NeobankListItem>;
    /**
     * 
     * @type {NeobankListResponseDataPagination}
     * @memberof NeobankListResponseData
     */
    'pagination': NeobankListResponseDataPagination;
}
/**
 * 
 * @export
 * @interface NeobankListResponseDataPagination
 */
export interface NeobankListResponseDataPagination {
    /**
     * 
     * @type {number}
     * @memberof NeobankListResponseDataPagination
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof NeobankListResponseDataPagination
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof NeobankListResponseDataPagination
     */
    'offset': number;
    /**
     * 
     * @type {boolean}
     * @memberof NeobankListResponseDataPagination
     */
    'hasMore': boolean;
}
/**
 * Response from GET /neobanks/{neobankId}/public-key
 * @export
 * @interface NeobankPublicKeyResponse
 */
export interface NeobankPublicKeyResponse {
    /**
     * 
     * @type {boolean}
     * @memberof NeobankPublicKeyResponse
     */
    'success': boolean;
    /**
     * 
     * @type {NeobankPublicKeyResponseData}
     * @memberof NeobankPublicKeyResponse
     */
    'data': NeobankPublicKeyResponseData;
}
/**
 * 
 * @export
 * @interface NeobankPublicKeyResponseData
 */
export interface NeobankPublicKeyResponseData {
    /**
     * 
     * @type {string}
     * @memberof NeobankPublicKeyResponseData
     */
    'neobankId': string;
    /**
     * 
     * @type {string}
     * @memberof NeobankPublicKeyResponseData
     */
    'keyId': string;
    /**
     * PEM-encoded RSA public key
     * @type {string}
     * @memberof NeobankPublicKeyResponseData
     */
    'publicKey': string;
    /**
     * 
     * @type {string}
     * @memberof NeobankPublicKeyResponseData
     */
    'algorithm': string;
    /**
     * 
     * @type {number}
     * @memberof NeobankPublicKeyResponseData
     */
    'keySize': number;
    /**
     * 
     * @type {string}
     * @memberof NeobankPublicKeyResponseData
     */
    'expiresAt'?: string | null;
}
/**
 * 
 * @export
 * @interface Offer
 */
export interface Offer {
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'offerId': string;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'lenderId': string;
    /**
     * Display name of the lender
     * @type {string}
     * @memberof Offer
     */
    'lenderName': string;
    /**
     * 
     * @type {OfferStatus}
     * @memberof Offer
     */
    'status': OfferStatus;
    /**
     * Loan amount in USD as string to preserve decimal precision
     * @type {string}
     * @memberof Offer
     */
    'loanAmount': string;
    /**
     * APR as decimal string to preserve precision (e.g., \"0.0599\" = 5.99%)
     * @type {string}
     * @memberof Offer
     */
    'interestRate': string;
    /**
     * Term in months
     * @type {number}
     * @memberof Offer
     */
    'term': number;
    /**
     * Monthly payment amount in USD as string to preserve decimal precision
     * @type {string}
     * @memberof Offer
     */
    'monthlyPayment': string;
    /**
     * 
     * @type {Array<OfferFeesInner>}
     * @memberof Offer
     */
    'fees'?: Array<OfferFeesInner>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Offer
     */
    'offerDetails': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'expiresAt': string;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'createdAt': string;
}


/**
 * 
 * @export
 * @interface OfferAcceptanceRequest
 */
export interface OfferAcceptanceRequest {
    /**
     * 
     * @type {OfferAcceptanceRequestHardPullConsent}
     * @memberof OfferAcceptanceRequest
     */
    'hardPullConsent': OfferAcceptanceRequestHardPullConsent;
    /**
     * 
     * @type {OfferAcceptanceRequestCommunicationPreferences}
     * @memberof OfferAcceptanceRequest
     */
    'communicationPreferences'?: OfferAcceptanceRequestCommunicationPreferences;
    /**
     * 
     * @type {OfferAcceptanceRequestRequestedDisbursement}
     * @memberof OfferAcceptanceRequest
     */
    'requestedDisbursement'?: OfferAcceptanceRequestRequestedDisbursement;
    /**
     * 
     * @type {OfferAcceptanceRequestBorrowerWallet}
     * @memberof OfferAcceptanceRequest
     */
    'borrowerWallet'?: OfferAcceptanceRequestBorrowerWallet;
    /**
     * Borrower email for signing session
     * @type {string}
     * @memberof OfferAcceptanceRequest
     */
    'borrowerEmail'?: string;
    /**
     * Borrower full name for signing session
     * @type {string}
     * @memberof OfferAcceptanceRequest
     */
    'borrowerName'?: string;
}
/**
 * Borrower wallet for USDC disbursement (required for final offers)
 * @export
 * @interface OfferAcceptanceRequestBorrowerWallet
 */
export interface OfferAcceptanceRequestBorrowerWallet {
    /**
     * Wallet address for receiving disbursement
     * @type {string}
     * @memberof OfferAcceptanceRequestBorrowerWallet
     */
    'address'?: string;
    /**
     * Blockchain network for disbursement
     * @type {string}
     * @memberof OfferAcceptanceRequestBorrowerWallet
     */
    'chain'?: OfferAcceptanceRequestBorrowerWalletChainEnum;
    /**
     * Type of wallet ownership
     * @type {string}
     * @memberof OfferAcceptanceRequestBorrowerWallet
     */
    'walletType'?: OfferAcceptanceRequestBorrowerWalletWalletTypeEnum;
}

export const OfferAcceptanceRequestBorrowerWalletChainEnum = {
    Base: 'base',
    Ethereum: 'ethereum',
    Polygon: 'polygon'
} as const;

export type OfferAcceptanceRequestBorrowerWalletChainEnum = typeof OfferAcceptanceRequestBorrowerWalletChainEnum[keyof typeof OfferAcceptanceRequestBorrowerWalletChainEnum];
export const OfferAcceptanceRequestBorrowerWalletWalletTypeEnum = {
    BorrowerSelfCustody: 'borrower_self_custody',
    NeobankCustodial: 'neobank_custodial'
} as const;

export type OfferAcceptanceRequestBorrowerWalletWalletTypeEnum = typeof OfferAcceptanceRequestBorrowerWalletWalletTypeEnum[keyof typeof OfferAcceptanceRequestBorrowerWalletWalletTypeEnum];

/**
 * 
 * @export
 * @interface OfferAcceptanceRequestCommunicationPreferences
 */
export interface OfferAcceptanceRequestCommunicationPreferences {
    /**
     * 
     * @type {boolean}
     * @memberof OfferAcceptanceRequestCommunicationPreferences
     */
    'email'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OfferAcceptanceRequestCommunicationPreferences
     */
    'sms'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OfferAcceptanceRequestCommunicationPreferences
     */
    'phone'?: boolean;
}
/**
 * 
 * @export
 * @interface OfferAcceptanceRequestHardPullConsent
 */
export interface OfferAcceptanceRequestHardPullConsent {
    /**
     * Must be true
     * @type {boolean}
     * @memberof OfferAcceptanceRequestHardPullConsent
     */
    'consented': boolean;
    /**
     * ISO 8601 timestamp of consent
     * @type {string}
     * @memberof OfferAcceptanceRequestHardPullConsent
     */
    'consentedAt': string;
    /**
     * IPv4 address of user
     * @type {string}
     * @memberof OfferAcceptanceRequestHardPullConsent
     */
    'ipAddress': string;
    /**
     * Browser user agent string
     * @type {string}
     * @memberof OfferAcceptanceRequestHardPullConsent
     */
    'userAgent': string;
    /**
     * TCPA consent for communications
     * @type {boolean}
     * @memberof OfferAcceptanceRequestHardPullConsent
     */
    'tcpaConsent'?: boolean;
    /**
     * E-signature consent
     * @type {boolean}
     * @memberof OfferAcceptanceRequestHardPullConsent
     */
    'esignConsent'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OfferAcceptanceRequestHardPullConsent
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface OfferAcceptanceRequestRequestedDisbursement
 */
export interface OfferAcceptanceRequestRequestedDisbursement {
    /**
     * 
     * @type {number}
     * @memberof OfferAcceptanceRequestRequestedDisbursement
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferAcceptanceRequestRequestedDisbursement
     */
    'method'?: OfferAcceptanceRequestRequestedDisbursementMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferAcceptanceRequestRequestedDisbursement
     */
    'destination'?: string;
}

export const OfferAcceptanceRequestRequestedDisbursementMethodEnum = {
    Ach: 'ach',
    Wire: 'wire',
    Stablecoin: 'stablecoin'
} as const;

export type OfferAcceptanceRequestRequestedDisbursementMethodEnum = typeof OfferAcceptanceRequestRequestedDisbursementMethodEnum[keyof typeof OfferAcceptanceRequestRequestedDisbursementMethodEnum];

/**
 * 
 * @export
 * @interface OfferAcceptanceResponse
 */
export interface OfferAcceptanceResponse {
    /**
     * 
     * @type {boolean}
     * @memberof OfferAcceptanceResponse
     */
    'success': boolean;
    /**
     * 
     * @type {OfferAcceptanceResponseData}
     * @memberof OfferAcceptanceResponse
     */
    'data': OfferAcceptanceResponseData;
}
/**
 * 
 * @export
 * @interface OfferAcceptanceResponseData
 */
export interface OfferAcceptanceResponseData {
    /**
     * 
     * @type {string}
     * @memberof OfferAcceptanceResponseData
     */
    'offerId': string;
    /**
     * 
     * @type {string}
     * @memberof OfferAcceptanceResponseData
     */
    'offerType': OfferAcceptanceResponseDataOfferTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferAcceptanceResponseData
     */
    'applicationId': string;
    /**
     * 
     * @type {string}
     * @memberof OfferAcceptanceResponseData
     */
    'lenderId': string;
    /**
     * 
     * @type {string}
     * @memberof OfferAcceptanceResponseData
     */
    'status': OfferAcceptanceResponseDataStatusEnum;
    /**
     * 
     * @type {OfferAcceptanceResponseDataNextSteps}
     * @memberof OfferAcceptanceResponseData
     */
    'nextSteps'?: OfferAcceptanceResponseDataNextSteps;
    /**
     * URL for document signing (final offers only)
     * @type {string}
     * @memberof OfferAcceptanceResponseData
     */
    'signingUrl'?: string;
    /**
     * Signing session ID (final offers only)
     * @type {string}
     * @memberof OfferAcceptanceResponseData
     */
    'signingSessionId'?: string;
    /**
     * Number of other offers rejected
     * @type {number}
     * @memberof OfferAcceptanceResponseData
     */
    'rejectedOffers'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferAcceptanceResponseData
     */
    'acceptedAt': string;
    /**
     * 
     * @type {string}
     * @memberof OfferAcceptanceResponseData
     */
    'requestId'?: string;
}

export const OfferAcceptanceResponseDataOfferTypeEnum = {
    Prequalified: 'prequalified',
    Final: 'final'
} as const;

export type OfferAcceptanceResponseDataOfferTypeEnum = typeof OfferAcceptanceResponseDataOfferTypeEnum[keyof typeof OfferAcceptanceResponseDataOfferTypeEnum];
export const OfferAcceptanceResponseDataStatusEnum = {
    Accepted: 'ACCEPTED'
} as const;

export type OfferAcceptanceResponseDataStatusEnum = typeof OfferAcceptanceResponseDataStatusEnum[keyof typeof OfferAcceptanceResponseDataStatusEnum];

/**
 * 
 * @export
 * @interface OfferAcceptanceResponseDataNextSteps
 */
export interface OfferAcceptanceResponseDataNextSteps {
    /**
     * 
     * @type {string}
     * @memberof OfferAcceptanceResponseDataNextSteps
     */
    'action'?: OfferAcceptanceResponseDataNextStepsActionEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferAcceptanceResponseDataNextSteps
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferAcceptanceResponseDataNextSteps
     */
    'estimatedTime'?: string;
}

export const OfferAcceptanceResponseDataNextStepsActionEnum = {
    HardPull: 'HARD_PULL',
    DocumentSigning: 'DOCUMENT_SIGNING'
} as const;

export type OfferAcceptanceResponseDataNextStepsActionEnum = typeof OfferAcceptanceResponseDataNextStepsActionEnum[keyof typeof OfferAcceptanceResponseDataNextStepsActionEnum];

/**
 * 
 * @export
 * @interface OfferDetailResponse
 */
export interface OfferDetailResponse {
    /**
     * 
     * @type {boolean}
     * @memberof OfferDetailResponse
     */
    'success': boolean;
    /**
     * 
     * @type {OfferDetailResponseData}
     * @memberof OfferDetailResponse
     */
    'data': OfferDetailResponseData;
}
/**
 * 
 * @export
 * @interface OfferDetailResponseData
 */
export interface OfferDetailResponseData {
    /**
     * 
     * @type {OfferDetailResponseDataOffer}
     * @memberof OfferDetailResponseData
     */
    'offer': OfferDetailResponseDataOffer;
    /**
     * 
     * @type {string}
     * @memberof OfferDetailResponseData
     */
    'requestId'?: string;
}
/**
 * 
 * @export
 * @interface OfferDetailResponseDataOffer
 */
export interface OfferDetailResponseDataOffer {
    /**
     * 
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'offerId': string;
    /**
     * Type of offer: - prequalified: Initial soft-pull offer before hard credit check - final: Firm offer after hard credit pull and full underwriting 
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'offerType': OfferDetailResponseDataOfferOfferTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'lenderId': string;
    /**
     * 
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'neobankId': string;
    /**
     * 
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'applicationId': string;
    /**
     * Loan amount (publicly visible, string for precision)
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'loanAmount': string;
    /**
     * Encrypted offer details (decrypt with neobank private key)
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'encryptedOfferDetailsNeobank': string;
    /**
     * SHA-256 checksum for integrity verification
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'checksumSha256': string;
    /**
     * 
     * @type {OfferStatus}
     * @memberof OfferDetailResponseDataOffer
     */
    'status': OfferStatus;
    /**
     * 
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'externalId'?: string | null;
    /**
     * For final offers only: ID of the prequalified offer this final offer originated from. Useful for showing the borrower the progression from prequal to final offer. Null for prequalified offers. 
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'prequalifiedOfferId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'expiresAt': string;
    /**
     * 
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof OfferDetailResponseDataOffer
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {OfferDetailResponseDataOfferAllOfApplication}
     * @memberof OfferDetailResponseDataOffer
     */
    'application'?: OfferDetailResponseDataOfferAllOfApplication;
}

export const OfferDetailResponseDataOfferOfferTypeEnum = {
    Prequalified: 'prequalified',
    Final: 'final'
} as const;

export type OfferDetailResponseDataOfferOfferTypeEnum = typeof OfferDetailResponseDataOfferOfferTypeEnum[keyof typeof OfferDetailResponseDataOfferOfferTypeEnum];

/**
 * Basic application details
 * @export
 * @interface OfferDetailResponseDataOfferAllOfApplication
 */
export interface OfferDetailResponseDataOfferAllOfApplication {
    /**
     * 
     * @type {string}
     * @memberof OfferDetailResponseDataOfferAllOfApplication
     */
    'applicationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferDetailResponseDataOfferAllOfApplication
     */
    'neobankId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferDetailResponseDataOfferAllOfApplication
     */
    'productType'?: string;
    /**
     * 
     * @type {ApplicationStatus}
     * @memberof OfferDetailResponseDataOfferAllOfApplication
     */
    'status'?: ApplicationStatus;
}


/**
 * 
 * @export
 * @interface OfferFeesInner
 */
export interface OfferFeesInner {
    /**
     * 
     * @type {string}
     * @memberof OfferFeesInner
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof OfferFeesInner
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferFeesInner
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface OfferRequest
 */
export interface OfferRequest {
    /**
     * Loan amount in USD
     * @type {number}
     * @memberof OfferRequest
     */
    'loanAmount': number;
    /**
     * Annual Percentage Rate (APR) as decimal
     * @type {number}
     * @memberof OfferRequest
     */
    'interestRate': number;
    /**
     * Loan term in months
     * @type {number}
     * @memberof OfferRequest
     */
    'term': number;
    /**
     * Monthly payment amount in USD
     * @type {number}
     * @memberof OfferRequest
     */
    'monthlyPayment': number;
    /**
     * Array of fees
     * @type {Array<OfferRequestFeesInner>}
     * @memberof OfferRequest
     */
    'fees'?: Array<OfferRequestFeesInner>;
    /**
     * Full offer details and conditions
     * @type {{ [key: string]: any; }}
     * @memberof OfferRequest
     */
    'offerDetails': { [key: string]: any; };
    /**
     * Offer expiration timestamp
     * @type {string}
     * @memberof OfferRequest
     */
    'expiresAt': string;
}
/**
 * 
 * @export
 * @interface OfferRequestFeesInner
 */
export interface OfferRequestFeesInner {
    /**
     * 
     * @type {string}
     * @memberof OfferRequestFeesInner
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof OfferRequestFeesInner
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof OfferRequestFeesInner
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface OfferResponse
 */
export interface OfferResponse {
    /**
     * 
     * @type {string}
     * @memberof OfferResponse
     */
    'offerId': string;
    /**
     * 
     * @type {string}
     * @memberof OfferResponse
     */
    'applicationId': string;
    /**
     * 
     * @type {string}
     * @memberof OfferResponse
     */
    'lenderId': string;
    /**
     * 
     * @type {OfferStatus}
     * @memberof OfferResponse
     */
    'status': OfferStatus;
    /**
     * 
     * @type {string}
     * @memberof OfferResponse
     */
    'createdAt': string;
}


/**
 * - PENDING: Offer awaiting borrower decision - ACCEPTED: Offer accepted by borrower - REJECTED: Offer rejected (automatically when another offer accepted) - EXPIRED: Offer expired past expiration date - WITHDRAWN: Lender withdrew the offer - SUPERSEDED: Prequalified offer superseded by final offer 
 * @export
 * @enum {string}
 */

export const OfferStatus = {
    Pending: 'PENDING',
    Accepted: 'ACCEPTED',
    Rejected: 'REJECTED',
    Expired: 'EXPIRED',
    Withdrawn: 'WITHDRAWN',
    Superseded: 'SUPERSEDED'
} as const;

export type OfferStatus = typeof OfferStatus[keyof typeof OfferStatus];


/**
 * 
 * @export
 * @interface OfferSubmissionResponse
 */
export interface OfferSubmissionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof OfferSubmissionResponse
     */
    'success': boolean;
    /**
     * 
     * @type {OfferSubmissionResponseData}
     * @memberof OfferSubmissionResponse
     */
    'data': OfferSubmissionResponseData;
}
/**
 * 
 * @export
 * @interface OfferSubmissionResponseData
 */
export interface OfferSubmissionResponseData {
    /**
     * 
     * @type {string}
     * @memberof OfferSubmissionResponseData
     */
    'applicationId': string;
    /**
     * 
     * @type {string}
     * @memberof OfferSubmissionResponseData
     */
    'offerType': OfferSubmissionResponseDataOfferTypeEnum;
    /**
     * Array of created offer IDs with metadata
     * @type {Array<OfferSubmissionResponseDataOffersInner>}
     * @memberof OfferSubmissionResponseData
     */
    'offers': Array<OfferSubmissionResponseDataOffersInner>;
    /**
     * 
     * @type {string}
     * @memberof OfferSubmissionResponseData
     */
    'submittedAt': string;
    /**
     * 
     * @type {string}
     * @memberof OfferSubmissionResponseData
     */
    'requestId'?: string;
}

export const OfferSubmissionResponseDataOfferTypeEnum = {
    Prequalified: 'prequalified',
    Final: 'final'
} as const;

export type OfferSubmissionResponseDataOfferTypeEnum = typeof OfferSubmissionResponseDataOfferTypeEnum[keyof typeof OfferSubmissionResponseDataOfferTypeEnum];

/**
 * 
 * @export
 * @interface OfferSubmissionResponseDataOffersInner
 */
export interface OfferSubmissionResponseDataOffersInner {
    /**
     * 
     * @type {string}
     * @memberof OfferSubmissionResponseDataOffersInner
     */
    'offerId'?: string;
    /**
     * Loan amount (string for decimal precision)
     * @type {string}
     * @memberof OfferSubmissionResponseDataOffersInner
     */
    'loanAmount'?: string;
    /**
     * 
     * @type {OfferStatus}
     * @memberof OfferSubmissionResponseDataOffersInner
     */
    'status'?: OfferStatus;
    /**
     * 
     * @type {string}
     * @memberof OfferSubmissionResponseDataOffersInner
     */
    'expiresAt'?: string;
}


/**
 * 
 * @export
 * @interface OffersResponse
 */
export interface OffersResponse {
    /**
     * 
     * @type {string}
     * @memberof OffersResponse
     */
    'applicationId': string;
    /**
     * Array of offers (unranked, unfiltered)
     * @type {Array<Offer>}
     * @memberof OffersResponse
     */
    'offers': Array<Offer>;
    /**
     * 
     * @type {string}
     * @memberof OffersResponse
     */
    'retrievedAt': string;
}
/**
 * 
 * @export
 * @interface PaymentScheduleResponse
 */
export interface PaymentScheduleResponse {
    /**
     * 
     * @type {boolean}
     * @memberof PaymentScheduleResponse
     */
    'success': boolean;
    /**
     * 
     * @type {PaymentScheduleResponseData}
     * @memberof PaymentScheduleResponse
     */
    'data': PaymentScheduleResponseData;
}
/**
 * 
 * @export
 * @interface PaymentScheduleResponseData
 */
export interface PaymentScheduleResponseData {
    /**
     * 
     * @type {string}
     * @memberof PaymentScheduleResponseData
     */
    'loanId': string;
    /**
     * Current principal balance
     * @type {string}
     * @memberof PaymentScheduleResponseData
     */
    'currentPrincipalBalance': string;
    /**
     * Number of payments already made
     * @type {number}
     * @memberof PaymentScheduleResponseData
     */
    'paymentsMade': number;
    /**
     * 
     * @type {Array<ScheduledPayment>}
     * @memberof PaymentScheduleResponseData
     */
    'projectedSchedule': Array<ScheduledPayment>;
    /**
     * Disclaimer about projections
     * @type {string}
     * @memberof PaymentScheduleResponseData
     */
    'note'?: string;
}
/**
 * 
 * @export
 * @interface PrequalOfferSubmission
 */
export interface PrequalOfferSubmission {
    /**
     * 1-10 prequalified offers (soft pull only). Note: prequalifiedOfferId must NOT be provided for prequalified offers. 
     * @type {Array<EncryptedOfferSubmission>}
     * @memberof PrequalOfferSubmission
     */
    'offers': Array<EncryptedOfferSubmission>;
}
/**
 * Response from POST /attestations/{attestationId}/proof-token
 * @export
 * @interface ProofAccessTokenResponse
 */
export interface ProofAccessTokenResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ProofAccessTokenResponse
     */
    'success': boolean;
    /**
     * 
     * @type {ProofAccessTokenResponseData}
     * @memberof ProofAccessTokenResponse
     */
    'data': ProofAccessTokenResponseData;
}
/**
 * 
 * @export
 * @interface ProofAccessTokenResponseData
 */
export interface ProofAccessTokenResponseData {
    /**
     * JWT token for SDX API access
     * @type {string}
     * @memberof ProofAccessTokenResponseData
     */
    'sdxToken': string;
    /**
     * Base URL of the SDX service
     * @type {string}
     * @memberof ProofAccessTokenResponseData
     */
    'sdxUrl': string;
    /**
     * Token expiration in seconds
     * @type {number}
     * @memberof ProofAccessTokenResponseData
     */
    'expiresIn': number;
    /**
     * 
     * @type {ProofAccessTokenResponseDataUsage}
     * @memberof ProofAccessTokenResponseData
     */
    'usage': ProofAccessTokenResponseDataUsage;
}
/**
 * Instructions for using the token
 * @export
 * @interface ProofAccessTokenResponseDataUsage
 */
export interface ProofAccessTokenResponseDataUsage {
    /**
     * 
     * @type {string}
     * @memberof ProofAccessTokenResponseDataUsage
     */
    'endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProofAccessTokenResponseDataUsage
     */
    'method'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ProofAccessTokenResponseDataUsage
     */
    'headers'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface QueueApplication
 */
export interface QueueApplication {
    /**
     * Unique identifier for this route
     * @type {string}
     * @memberof QueueApplication
     */
    'routeId': string;
    /**
     * 
     * @type {string}
     * @memberof QueueApplication
     */
    'applicationId': string;
    /**
     * 
     * @type {string}
     * @memberof QueueApplication
     */
    'productType': QueueApplicationProductTypeEnum;
    /**
     * SDX handle for this lender\'s encrypted KYC blob
     * @type {string}
     * @memberof QueueApplication
     */
    'perLenderKycHandle'?: string;
    /**
     * SHA-256 checksum of original plaintext KYC doc for post-decrypt verification
     * @type {string}
     * @memberof QueueApplication
     */
    'kycChecksumSha256'?: string;
    /**
     * Handle to retrieve KYC document from SDX. DEPRECATED: Use encryptedKycPayload instead. 
     * @type {string}
     * @memberof QueueApplication
     * @deprecated
     */
    'kycDocumentHandle'?: string;
    /**
     * Non-PII metadata for processing
     * @type {{ [key: string]: any; }}
     * @memberof QueueApplication
     */
    'metadata'?: { [key: string]: any; };
    /**
     * When application entered the queue
     * @type {string}
     * @memberof QueueApplication
     */
    'sentAt': string;
    /**
     * When application will expire (60s from sentAt)
     * @type {string}
     * @memberof QueueApplication
     */
    'expiresAt': string;
    /**
     * Seconds until expiration
     * @type {number}
     * @memberof QueueApplication
     */
    'secondsRemaining': number;
}

export const QueueApplicationProductTypeEnum = {
    Consumer: 'consumer',
    Auto: 'auto',
    Mortgage: 'mortgage',
    Personal: 'personal',
    Business: 'business'
} as const;

export type QueueApplicationProductTypeEnum = typeof QueueApplicationProductTypeEnum[keyof typeof QueueApplicationProductTypeEnum];

/**
 * 
 * @export
 * @interface QueueResponse
 */
export interface QueueResponse {
    /**
     * 
     * @type {boolean}
     * @memberof QueueResponse
     */
    'success': boolean;
    /**
     * 
     * @type {QueueResponseData}
     * @memberof QueueResponse
     */
    'data': QueueResponseData;
}
/**
 * 
 * @export
 * @interface QueueResponseData
 */
export interface QueueResponseData {
    /**
     * Applications within the 60-second active window
     * @type {Array<QueueApplication>}
     * @memberof QueueResponseData
     */
    'queue': Array<QueueApplication>;
    /**
     * Total number of active applications
     * @type {number}
     * @memberof QueueResponseData
     */
    'count': number;
    /**
     * Duration of the queue window in seconds
     * @type {number}
     * @memberof QueueResponseData
     */
    'windowSeconds': number;
    /**
     * Server timestamp for queue state
     * @type {string}
     * @memberof QueueResponseData
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface QueueStatsResponse
 */
export interface QueueStatsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatsResponse
     */
    'success': boolean;
    /**
     * 
     * @type {QueueStatsResponseData}
     * @memberof QueueStatsResponse
     */
    'data': QueueStatsResponseData;
}
/**
 * 
 * @export
 * @interface QueueStatsResponseData
 */
export interface QueueStatsResponseData {
    /**
     * Current active applications in queue
     * @type {number}
     * @memberof QueueStatsResponseData
     */
    'activeCount': number;
    /**
     * Total applications ever routed to this lender
     * @type {number}
     * @memberof QueueStatsResponseData
     */
    'totalRoutedCount': number;
    /**
     * Total offers submitted by this lender
     * @type {number}
     * @memberof QueueStatsResponseData
     */
    'offersSubmittedCount': number;
    /**
     * Percentage of offers that were accepted (0-100)
     * @type {number}
     * @memberof QueueStatsResponseData
     */
    'acceptanceRate': number;
}
/**
 * Loan repayment transaction
 * @export
 * @interface Repayment
 */
export interface Repayment {
    /**
     * Unique repayment identifier
     * @type {string}
     * @memberof Repayment
     */
    'id': string;
    /**
     * Associated loan ID
     * @type {string}
     * @memberof Repayment
     */
    'loanId': string;
    /**
     * Bridge drain transaction ID
     * @type {string}
     * @memberof Repayment
     */
    'bridgeDrainId'?: string;
    /**
     * Payment amount
     * @type {string}
     * @memberof Repayment
     */
    'amount': string;
    /**
     * Payment currency
     * @type {string}
     * @memberof Repayment
     */
    'currency': string;
    /**
     * Source wallet address
     * @type {string}
     * @memberof Repayment
     */
    'sourceAddress'?: string;
    /**
     * Source blockchain
     * @type {string}
     * @memberof Repayment
     */
    'sourceChain'?: string;
    /**
     * Deposit transaction hash
     * @type {string}
     * @memberof Repayment
     */
    'depositTxHash'?: string;
    /**
     * Destination transaction hash (when completed)
     * @type {string}
     * @memberof Repayment
     */
    'destinationTxHash'?: string | null;
    /**
     * Amount applied to principal
     * @type {string}
     * @memberof Repayment
     */
    'principalPortion'?: string | null;
    /**
     * Amount applied to interest
     * @type {string}
     * @memberof Repayment
     */
    'interestPortion'?: string | null;
    /**
     * Principal balance before payment
     * @type {string}
     * @memberof Repayment
     */
    'balanceBefore'?: string | null;
    /**
     * Principal balance after payment
     * @type {string}
     * @memberof Repayment
     */
    'balanceAfter'?: string | null;
    /**
     * When payment was received
     * @type {string}
     * @memberof Repayment
     */
    'receivedAt': string;
    /**
     * When payment was fully processed
     * @type {string}
     * @memberof Repayment
     */
    'completedAt'?: string | null;
    /**
     * 
     * @type {RepaymentStatus}
     * @memberof Repayment
     */
    'status': RepaymentStatus;
    /**
     * 
     * @type {string}
     * @memberof Repayment
     */
    'createdAt': string;
}


/**
 * 
 * @export
 * @interface RepaymentListResponse
 */
export interface RepaymentListResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RepaymentListResponse
     */
    'success': boolean;
    /**
     * 
     * @type {RepaymentListResponseData}
     * @memberof RepaymentListResponse
     */
    'data': RepaymentListResponseData;
}
/**
 * 
 * @export
 * @interface RepaymentListResponseData
 */
export interface RepaymentListResponseData {
    /**
     * 
     * @type {Array<Repayment>}
     * @memberof RepaymentListResponseData
     */
    'repayments': Array<Repayment>;
    /**
     * 
     * @type {RepaymentListResponseDataPagination}
     * @memberof RepaymentListResponseData
     */
    'pagination': RepaymentListResponseDataPagination;
}
/**
 * 
 * @export
 * @interface RepaymentListResponseDataPagination
 */
export interface RepaymentListResponseDataPagination {
    /**
     * 
     * @type {number}
     * @memberof RepaymentListResponseDataPagination
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof RepaymentListResponseDataPagination
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof RepaymentListResponseDataPagination
     */
    'offset': number;
    /**
     * 
     * @type {boolean}
     * @memberof RepaymentListResponseDataPagination
     */
    'hasMore': boolean;
}
/**
 * Status of a repayment transaction
 * @export
 * @enum {string}
 */

export const RepaymentStatus = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Refunded: 'REFUNDED'
} as const;

export type RepaymentStatus = typeof RepaymentStatus[keyof typeof RepaymentStatus];


/**
 * 
 * @export
 * @interface RotateEntityKeyRequest
 */
export interface RotateEntityKeyRequest {
    /**
     * New RSA public key in PEM format
     * @type {string}
     * @memberof RotateEntityKeyRequest
     */
    'newPublicKey': string;
    /**
     * 
     * @type {string}
     * @memberof RotateEntityKeyRequest
     */
    'keyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof RotateEntityKeyRequest
     */
    'expiresAt'?: string;
    /**
     * Days for rotation period (1-90)
     * @type {number}
     * @memberof RotateEntityKeyRequest
     */
    'rotationPeriod'?: number;
}
/**
 * 
 * @export
 * @interface SDXTokenRequest
 */
export interface SDXTokenRequest {
    /**
     * Application ID for document context
     * @type {string}
     * @memberof SDXTokenRequest
     */
    'applicationId': string;
    /**
     * Action to perform with the token
     * @type {string}
     * @memberof SDXTokenRequest
     */
    'action': SDXTokenRequestActionEnum;
    /**
     * Type of document (optional, for context)
     * @type {string}
     * @memberof SDXTokenRequest
     */
    'documentType'?: SDXTokenRequestDocumentTypeEnum;
}

export const SDXTokenRequestActionEnum = {
    Upload: 'upload',
    Download: 'download'
} as const;

export type SDXTokenRequestActionEnum = typeof SDXTokenRequestActionEnum[keyof typeof SDXTokenRequestActionEnum];
export const SDXTokenRequestDocumentTypeEnum = {
    Kyc: 'kyc',
    Contract: 'contract',
    SignedContract: 'signed_contract'
} as const;

export type SDXTokenRequestDocumentTypeEnum = typeof SDXTokenRequestDocumentTypeEnum[keyof typeof SDXTokenRequestDocumentTypeEnum];

/**
 * 
 * @export
 * @interface SDXTokenResponse
 */
export interface SDXTokenResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SDXTokenResponse
     */
    'success': boolean;
    /**
     * 
     * @type {SDXTokenResponseData}
     * @memberof SDXTokenResponse
     */
    'data': SDXTokenResponseData;
}
/**
 * 
 * @export
 * @interface SDXTokenResponseData
 */
export interface SDXTokenResponseData {
    /**
     * JWT token for SDX API access
     * @type {string}
     * @memberof SDXTokenResponseData
     */
    'sdxToken': string;
    /**
     * Token expiration in seconds (600 = 10 minutes)
     * @type {number}
     * @memberof SDXTokenResponseData
     */
    'expiresIn': number;
    /**
     * Base URL of the SDX service for document operations
     * @type {string}
     * @memberof SDXTokenResponseData
     */
    'sdxUrl': string;
}
/**
 * Projected payment in the schedule
 * @export
 * @interface ScheduledPayment
 */
export interface ScheduledPayment {
    /**
     * Payment number in sequence
     * @type {number}
     * @memberof ScheduledPayment
     */
    'paymentNumber': number;
    /**
     * Payment due date
     * @type {string}
     * @memberof ScheduledPayment
     */
    'dueDate': string;
    /**
     * Total payment amount
     * @type {string}
     * @memberof ScheduledPayment
     */
    'payment': string;
    /**
     * Projected principal portion
     * @type {string}
     * @memberof ScheduledPayment
     */
    'principal': string;
    /**
     * Projected interest portion
     * @type {string}
     * @memberof ScheduledPayment
     */
    'interest': string;
    /**
     * Projected balance after payment
     * @type {string}
     * @memberof ScheduledPayment
     */
    'balanceAfter': string;
}
/**
 * Response from POST /signing-sessions/{sessionId}/complete
 * @export
 * @interface SigningSessionCompleteResponse
 */
export interface SigningSessionCompleteResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SigningSessionCompleteResponse
     */
    'success': boolean;
    /**
     * 
     * @type {SigningSessionCompleteResponseData}
     * @memberof SigningSessionCompleteResponse
     */
    'data': SigningSessionCompleteResponseData;
}
/**
 * 
 * @export
 * @interface SigningSessionCompleteResponseData
 */
export interface SigningSessionCompleteResponseData {
    /**
     * Unique identifier for the signing session
     * @type {string}
     * @memberof SigningSessionCompleteResponseData
     */
    'sessionId': string;
    /**
     * Application ID for this signing session
     * @type {string}
     * @memberof SigningSessionCompleteResponseData
     */
    'applicationId': string;
    /**
     * Session status (always COMPLETED after this call)
     * @type {string}
     * @memberof SigningSessionCompleteResponseData
     */
    'status': SigningSessionCompleteResponseDataStatusEnum;
    /**
     * When the signing was completed
     * @type {string}
     * @memberof SigningSessionCompleteResponseData
     */
    'completedAt'?: string;
    /**
     * SDX handle for lender\'s copy of signed document
     * @type {string}
     * @memberof SigningSessionCompleteResponseData
     */
    'signedDocHandleLender'?: string;
    /**
     * SDX handle for neobank\'s copy of signed document
     * @type {string}
     * @memberof SigningSessionCompleteResponseData
     */
    'signedDocHandleNeobank'?: string;
}

export const SigningSessionCompleteResponseDataStatusEnum = {
    Completed: 'COMPLETED'
} as const;

export type SigningSessionCompleteResponseDataStatusEnum = typeof SigningSessionCompleteResponseDataStatusEnum[keyof typeof SigningSessionCompleteResponseDataStatusEnum];

/**
 * Response from POST /applications/{id}/signing-sessions
 * @export
 * @interface SigningSessionCreateResponse
 */
export interface SigningSessionCreateResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SigningSessionCreateResponse
     */
    'success': boolean;
    /**
     * 
     * @type {SigningSessionCreateResponseData}
     * @memberof SigningSessionCreateResponse
     */
    'data': SigningSessionCreateResponseData;
}
/**
 * 
 * @export
 * @interface SigningSessionCreateResponseData
 */
export interface SigningSessionCreateResponseData {
    /**
     * Unique identifier for the signing session
     * @type {string}
     * @memberof SigningSessionCreateResponseData
     */
    'sessionId': string;
    /**
     * Application ID for this signing session
     * @type {string}
     * @memberof SigningSessionCreateResponseData
     */
    'applicationId': string;
    /**
     * URL to redirect borrower for document signing
     * @type {string}
     * @memberof SigningSessionCreateResponseData
     */
    'signingUrl': string;
    /**
     * When the signing session expires
     * @type {string}
     * @memberof SigningSessionCreateResponseData
     */
    'expiresAt': string;
    /**
     * Current status of the signing session
     * @type {string}
     * @memberof SigningSessionCreateResponseData
     */
    'status': SigningSessionCreateResponseDataStatusEnum;
}

export const SigningSessionCreateResponseDataStatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED'
} as const;

export type SigningSessionCreateResponseDataStatusEnum = typeof SigningSessionCreateResponseDataStatusEnum[keyof typeof SigningSessionCreateResponseDataStatusEnum];

/**
 * Response from GET /signing-sessions/{sessionId}
 * @export
 * @interface SigningSessionStatusResponse
 */
export interface SigningSessionStatusResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SigningSessionStatusResponse
     */
    'success': boolean;
    /**
     * 
     * @type {SigningSessionStatusResponseData}
     * @memberof SigningSessionStatusResponse
     */
    'data': SigningSessionStatusResponseData;
}
/**
 * 
 * @export
 * @interface SigningSessionStatusResponseData
 */
export interface SigningSessionStatusResponseData {
    /**
     * Unique identifier for the signing session
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'sessionId': string;
    /**
     * Application ID for this signing session
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'applicationId': string;
    /**
     * Current status of the signing session
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'status': SigningSessionStatusResponseDataStatusEnum;
    /**
     * Email address of the borrower
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'borrowerEmail': string;
    /**
     * Full name of the borrower
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'borrowerName': string;
    /**
     * When the signing session was initiated
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'initiatedAt': string;
    /**
     * When the signing session expires
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'expiresAt': string;
    /**
     * When the signing was completed (null if not completed)
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'completedAt'?: string | null;
    /**
     * When the signing session failed (null if not failed)
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'failedAt'?: string | null;
    /**
     * Reason for signing failure (null if not failed)
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'failureReason'?: string | null;
    /**
     * SDX handle for signed document (entity-specific)
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'signedDocHandle'?: string | null;
    /**
     * SDX handle for lender\'s copy (admin only)
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'signedDocHandleLender'?: string | null;
    /**
     * SDX handle for neobank\'s copy (admin only)
     * @type {string}
     * @memberof SigningSessionStatusResponseData
     */
    'signedDocHandleNeobank'?: string | null;
}

export const SigningSessionStatusResponseDataStatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED'
} as const;

export type SigningSessionStatusResponseDataStatusEnum = typeof SigningSessionStatusResponseDataStatusEnum[keyof typeof SigningSessionStatusResponseDataStatusEnum];

/**
 * Response from GET /applications/{applicationId}/signing-sessions
 * @export
 * @interface SigningSessionsListResponse
 */
export interface SigningSessionsListResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SigningSessionsListResponse
     */
    'success': boolean;
    /**
     * 
     * @type {SigningSessionsListResponseData}
     * @memberof SigningSessionsListResponse
     */
    'data': SigningSessionsListResponseData;
}
/**
 * 
 * @export
 * @interface SigningSessionsListResponseData
 */
export interface SigningSessionsListResponseData {
    /**
     * Application ID
     * @type {string}
     * @memberof SigningSessionsListResponseData
     */
    'applicationId': string;
    /**
     * 
     * @type {Array<SigningSessionsListResponseDataSessionsInner>}
     * @memberof SigningSessionsListResponseData
     */
    'sessions': Array<SigningSessionsListResponseDataSessionsInner>;
    /**
     * Number of signing sessions
     * @type {number}
     * @memberof SigningSessionsListResponseData
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface SigningSessionsListResponseDataSessionsInner
 */
export interface SigningSessionsListResponseDataSessionsInner {
    /**
     * Unique identifier for the signing session
     * @type {string}
     * @memberof SigningSessionsListResponseDataSessionsInner
     */
    'sessionId': string;
    /**
     * Application ID
     * @type {string}
     * @memberof SigningSessionsListResponseDataSessionsInner
     */
    'applicationId': string;
    /**
     * Lender ID for this session
     * @type {string}
     * @memberof SigningSessionsListResponseDataSessionsInner
     */
    'lenderId': string;
    /**
     * Current status of the signing session
     * @type {string}
     * @memberof SigningSessionsListResponseDataSessionsInner
     */
    'status': SigningSessionsListResponseDataSessionsInnerStatusEnum;
    /**
     * Email address of the borrower
     * @type {string}
     * @memberof SigningSessionsListResponseDataSessionsInner
     */
    'borrowerEmail': string;
    /**
     * Full name of the borrower
     * @type {string}
     * @memberof SigningSessionsListResponseDataSessionsInner
     */
    'borrowerName': string;
    /**
     * When the signing session was initiated
     * @type {string}
     * @memberof SigningSessionsListResponseDataSessionsInner
     */
    'initiatedAt': string;
    /**
     * When the signing session expires
     * @type {string}
     * @memberof SigningSessionsListResponseDataSessionsInner
     */
    'expiresAt': string;
    /**
     * When the signing was completed (null if not completed)
     * @type {string}
     * @memberof SigningSessionsListResponseDataSessionsInner
     */
    'completedAt'?: string | null;
    /**
     * When the signing session failed (null if not failed)
     * @type {string}
     * @memberof SigningSessionsListResponseDataSessionsInner
     */
    'failedAt'?: string | null;
    /**
     * Reason for signing failure (null if not failed)
     * @type {string}
     * @memberof SigningSessionsListResponseDataSessionsInner
     */
    'failureReason'?: string | null;
    /**
     * SDX handle for signed document (entity-specific)
     * @type {string}
     * @memberof SigningSessionsListResponseDataSessionsInner
     */
    'signedDocHandle'?: string | null;
}

export const SigningSessionsListResponseDataSessionsInnerStatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Expired: 'EXPIRED',
    Cancelled: 'CANCELLED'
} as const;

export type SigningSessionsListResponseDataSessionsInnerStatusEnum = typeof SigningSessionsListResponseDataSessionsInnerStatusEnum[keyof typeof SigningSessionsListResponseDataSessionsInnerStatusEnum];

/**
 * Sweep preview response
 * @export
 * @interface SweepPreviewResponse
 */
export interface SweepPreviewResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SweepPreviewResponse
     */
    'success': boolean;
    /**
     * 
     * @type {SweepPreviewResponseData}
     * @memberof SweepPreviewResponse
     */
    'data': SweepPreviewResponseData;
    /**
     * 
     * @type {string}
     * @memberof SweepPreviewResponse
     */
    'fetchedAt': string;
}
/**
 * 
 * @export
 * @interface SweepPreviewResponseData
 */
export interface SweepPreviewResponseData {
    /**
     * 
     * @type {Array<SweepableWallet>}
     * @memberof SweepPreviewResponseData
     */
    'wallets': Array<SweepableWallet>;
    /**
     * 
     * @type {SweepSummary}
     * @memberof SweepPreviewResponseData
     */
    'summary': SweepSummary;
    /**
     * 
     * @type {SweepPreviewResponseDataMasterWallet}
     * @memberof SweepPreviewResponseData
     */
    'masterWallet'?: SweepPreviewResponseDataMasterWallet | null;
}
/**
 * 
 * @export
 * @interface SweepPreviewResponseDataMasterWallet
 */
export interface SweepPreviewResponseDataMasterWallet {
    /**
     * Master wallet ID
     * @type {string}
     * @memberof SweepPreviewResponseDataMasterWallet
     */
    'id'?: string;
    /**
     * Master wallet address
     * @type {string}
     * @memberof SweepPreviewResponseDataMasterWallet
     */
    'address'?: string;
}
/**
 * Sweep execution request
 * @export
 * @interface SweepRequest
 */
export interface SweepRequest {
    /**
     * Specific loan IDs to sweep (sweeps all if omitted)
     * @type {Array<string>}
     * @memberof SweepRequest
     */
    'loanIds'?: Array<string>;
    /**
     * Minimum balance threshold (default \"0.01\")
     * @type {string}
     * @memberof SweepRequest
     */
    'minBalance'?: string;
    /**
     * If true, preview only without executing
     * @type {boolean}
     * @memberof SweepRequest
     */
    'dryRun'?: boolean;
}
/**
 * Sweep execution response
 * @export
 * @interface SweepResponse
 */
export interface SweepResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SweepResponse
     */
    'success': boolean;
    /**
     * Human-readable result message
     * @type {string}
     * @memberof SweepResponse
     */
    'message': string;
    /**
     * 
     * @type {Array<SweepResult>}
     * @memberof SweepResponse
     */
    'results': Array<SweepResult>;
    /**
     * 
     * @type {SweepResponseSummary}
     * @memberof SweepResponse
     */
    'summary': SweepResponseSummary;
    /**
     * Destination master wallet ID
     * @type {string}
     * @memberof SweepResponse
     */
    'masterWalletId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SweepResponse
     */
    'executedAt': string;
}
/**
 * 
 * @export
 * @interface SweepResponseSummary
 */
export interface SweepResponseSummary {
    /**
     * Total loans processed
     * @type {number}
     * @memberof SweepResponseSummary
     */
    'totalLoans': number;
    /**
     * Loans with wallets
     * @type {number}
     * @memberof SweepResponseSummary
     */
    'loansWithWallets': number;
    /**
     * Wallets successfully swept (or would be swept in dry-run)
     * @type {number}
     * @memberof SweepResponseSummary
     */
    'swept': number;
    /**
     * Wallets skipped (below threshold)
     * @type {number}
     * @memberof SweepResponseSummary
     */
    'skipped': number;
    /**
     * Wallets that failed to sweep
     * @type {number}
     * @memberof SweepResponseSummary
     */
    'failed': number;
    /**
     * Total amount swept (or would be swept)
     * @type {string}
     * @memberof SweepResponseSummary
     */
    'totalAmountSwept': string;
    /**
     * Whether this was a dry-run
     * @type {boolean}
     * @memberof SweepResponseSummary
     */
    'dryRun': boolean;
}
/**
 * Individual sweep result
 * @export
 * @interface SweepResult
 */
export interface SweepResult {
    /**
     * Loan ID
     * @type {string}
     * @memberof SweepResult
     */
    'loanId': string;
    /**
     * Source wallet ID
     * @type {string}
     * @memberof SweepResult
     */
    'walletId': string;
    /**
     * Source wallet address
     * @type {string}
     * @memberof SweepResult
     */
    'walletAddress': string;
    /**
     * Amount swept (or to be swept)
     * @type {string}
     * @memberof SweepResult
     */
    'amount': string;
    /**
     * Bridge transfer ID (if successful)
     * @type {string}
     * @memberof SweepResult
     */
    'transferId'?: string;
    /**
     * Result status (pending = would sweep in dry-run)
     * @type {string}
     * @memberof SweepResult
     */
    'status': SweepResultStatusEnum;
    /**
     * Error message if failed or skipped
     * @type {string}
     * @memberof SweepResult
     */
    'error'?: string;
}

export const SweepResultStatusEnum = {
    Success: 'success',
    Skipped: 'skipped',
    Failed: 'failed',
    Pending: 'pending'
} as const;

export type SweepResultStatusEnum = typeof SweepResultStatusEnum[keyof typeof SweepResultStatusEnum];

/**
 * Sweep summary statistics
 * @export
 * @interface SweepSummary
 */
export interface SweepSummary {
    /**
     * Total wallets checked
     * @type {number}
     * @memberof SweepSummary
     */
    'totalWallets'?: number;
    /**
     * Wallets meeting minimum balance threshold
     * @type {number}
     * @memberof SweepSummary
     */
    'sweepableWallets'?: number;
    /**
     * Total balance available to sweep
     * @type {string}
     * @memberof SweepSummary
     */
    'totalSweepableBalance'?: string;
    /**
     * Minimum balance threshold used
     * @type {string}
     * @memberof SweepSummary
     */
    'minBalanceThreshold'?: string;
}
/**
 * Wallet eligible for sweep
 * @export
 * @interface SweepableWallet
 */
export interface SweepableWallet {
    /**
     * Loan ID
     * @type {string}
     * @memberof SweepableWallet
     */
    'loanId'?: string;
    /**
     * Current loan status
     * @type {string}
     * @memberof SweepableWallet
     */
    'loanStatus'?: string;
    /**
     * Bridge wallet ID
     * @type {string}
     * @memberof SweepableWallet
     */
    'walletId'?: string;
    /**
     * Wallet blockchain address
     * @type {string}
     * @memberof SweepableWallet
     */
    'walletAddress'?: string;
    /**
     * USDC balance
     * @type {string}
     * @memberof SweepableWallet
     */
    'balance'?: string;
    /**
     * Blockchain chain
     * @type {string}
     * @memberof SweepableWallet
     */
    'chain'?: string;
    /**
     * Whether balance meets minimum threshold
     * @type {boolean}
     * @memberof SweepableWallet
     */
    'sweepable'?: boolean;
}
/**
 * Full transfer details
 * @export
 * @interface TransferDetail
 */
export interface TransferDetail {
    /**
     * Bridge transfer ID
     * @type {string}
     * @memberof TransferDetail
     */
    'id': string;
    /**
     * Current transfer state
     * @type {string}
     * @memberof TransferDetail
     */
    'state': TransferDetailStateEnum;
    /**
     * Transfer amount
     * @type {string}
     * @memberof TransferDetail
     */
    'amount': string;
    /**
     * Transfer currency
     * @type {string}
     * @memberof TransferDetail
     */
    'currency': string;
    /**
     * Developer fee amount
     * @type {string}
     * @memberof TransferDetail
     */
    'developerFee'?: string;
    /**
     * 
     * @type {TransferDetailSource}
     * @memberof TransferDetail
     */
    'source'?: TransferDetailSource;
    /**
     * 
     * @type {TransferDetailDestination}
     * @memberof TransferDetail
     */
    'destination'?: TransferDetailDestination;
    /**
     * 
     * @type {TransferDetailReceipt}
     * @memberof TransferDetail
     */
    'receipt'?: TransferDetailReceipt | null;
    /**
     * 
     * @type {TransferDetailReturnDetails}
     * @memberof TransferDetail
     */
    'returnDetails'?: TransferDetailReturnDetails | null;
    /**
     * Client reference ID
     * @type {string}
     * @memberof TransferDetail
     */
    'clientReferenceId'?: string | null;
    /**
     * When the transfer was created
     * @type {string}
     * @memberof TransferDetail
     */
    'createdAt': string;
    /**
     * When the transfer was last updated
     * @type {string}
     * @memberof TransferDetail
     */
    'updatedAt': string;
}

export const TransferDetailStateEnum = {
    AwaitingFunds: 'awaiting_funds',
    FundsReceived: 'funds_received',
    PaymentSubmitted: 'payment_submitted',
    PaymentProcessed: 'payment_processed',
    Canceled: 'canceled',
    Undeliverable: 'undeliverable',
    Returned: 'returned',
    Refunded: 'refunded'
} as const;

export type TransferDetailStateEnum = typeof TransferDetailStateEnum[keyof typeof TransferDetailStateEnum];

/**
 * Transfer destination details
 * @export
 * @interface TransferDetailDestination
 */
export interface TransferDetailDestination {
    /**
     * Destination payment rail
     * @type {string}
     * @memberof TransferDetailDestination
     */
    'paymentRail'?: string;
    /**
     * Destination Bridge wallet ID
     * @type {string}
     * @memberof TransferDetailDestination
     */
    'walletId'?: string | null;
    /**
     * Destination external account ID
     * @type {string}
     * @memberof TransferDetailDestination
     */
    'externalAccountId'?: string | null;
    /**
     * Destination blockchain address
     * @type {string}
     * @memberof TransferDetailDestination
     */
    'address'?: string | null;
    /**
     * Destination currency
     * @type {string}
     * @memberof TransferDetailDestination
     */
    'currency'?: string;
}
/**
 * Transfer receipt (populated on completion)
 * @export
 * @interface TransferDetailReceipt
 */
export interface TransferDetailReceipt {
    /**
     * Initial transfer amount
     * @type {string}
     * @memberof TransferDetailReceipt
     */
    'initialAmount'?: string;
    /**
     * Developer fee deducted
     * @type {string}
     * @memberof TransferDetailReceipt
     */
    'developerFee'?: string;
    /**
     * Exchange fee
     * @type {string}
     * @memberof TransferDetailReceipt
     */
    'exchangeFee'?: string;
    /**
     * Gas fee
     * @type {string}
     * @memberof TransferDetailReceipt
     */
    'gasFee'?: string;
    /**
     * Final amount received
     * @type {string}
     * @memberof TransferDetailReceipt
     */
    'finalAmount'?: string;
    /**
     * Source transaction hash
     * @type {string}
     * @memberof TransferDetailReceipt
     */
    'sourceTxHash'?: string | null;
    /**
     * Destination transaction hash
     * @type {string}
     * @memberof TransferDetailReceipt
     */
    'destinationTxHash'?: string | null;
}
/**
 * Return details if transfer was returned
 * @export
 * @interface TransferDetailReturnDetails
 */
export interface TransferDetailReturnDetails {
    /**
     * Reason for return
     * @type {string}
     * @memberof TransferDetailReturnDetails
     */
    'reason'?: string;
    /**
     * Return code
     * @type {string}
     * @memberof TransferDetailReturnDetails
     */
    'returnCode'?: string;
}
/**
 * Transfer source details
 * @export
 * @interface TransferDetailSource
 */
export interface TransferDetailSource {
    /**
     * Source payment rail
     * @type {string}
     * @memberof TransferDetailSource
     */
    'paymentRail'?: string;
    /**
     * Source Bridge wallet ID
     * @type {string}
     * @memberof TransferDetailSource
     */
    'walletId'?: string | null;
    /**
     * Source external account ID
     * @type {string}
     * @memberof TransferDetailSource
     */
    'externalAccountId'?: string | null;
    /**
     * Source blockchain address
     * @type {string}
     * @memberof TransferDetailSource
     */
    'address'?: string | null;
    /**
     * Source currency
     * @type {string}
     * @memberof TransferDetailSource
     */
    'currency'?: string;
}
/**
 * Transfer list response
 * @export
 * @interface TransferListResponse
 */
export interface TransferListResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TransferListResponse
     */
    'success': boolean;
    /**
     * 
     * @type {TransferListResponseData}
     * @memberof TransferListResponse
     */
    'data': TransferListResponseData;
    /**
     * When the data was fetched from Bridge
     * @type {string}
     * @memberof TransferListResponse
     */
    'fetchedAt': string;
}
/**
 * 
 * @export
 * @interface TransferListResponseData
 */
export interface TransferListResponseData {
    /**
     * 
     * @type {Array<TransferSummary>}
     * @memberof TransferListResponseData
     */
    'transfers': Array<TransferSummary>;
    /**
     * 
     * @type {TransferListResponseDataPagination}
     * @memberof TransferListResponseData
     */
    'pagination': TransferListResponseDataPagination;
}
/**
 * 
 * @export
 * @interface TransferListResponseDataPagination
 */
export interface TransferListResponseDataPagination {
    /**
     * Whether there are more results
     * @type {boolean}
     * @memberof TransferListResponseDataPagination
     */
    'hasMore': boolean;
    /**
     * Cursor for fetching next page
     * @type {string}
     * @memberof TransferListResponseDataPagination
     */
    'nextCursor'?: string | null;
}
/**
 * Single transfer details response
 * @export
 * @interface TransferResponse
 */
export interface TransferResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TransferResponse
     */
    'success': boolean;
    /**
     * 
     * @type {TransferDetail}
     * @memberof TransferResponse
     */
    'data': TransferDetail;
    /**
     * When the data was fetched from Bridge
     * @type {string}
     * @memberof TransferResponse
     */
    'fetchedAt': string;
}
/**
 * Transfer summary in list view
 * @export
 * @interface TransferSummary
 */
export interface TransferSummary {
    /**
     * Bridge transfer ID
     * @type {string}
     * @memberof TransferSummary
     */
    'id': string;
    /**
     * Current transfer state
     * @type {string}
     * @memberof TransferSummary
     */
    'state': TransferSummaryStateEnum;
    /**
     * Transfer amount
     * @type {string}
     * @memberof TransferSummary
     */
    'amount': string;
    /**
     * Transfer currency
     * @type {string}
     * @memberof TransferSummary
     */
    'currency': string;
    /**
     * 
     * @type {TransferSummarySource}
     * @memberof TransferSummary
     */
    'source'?: TransferSummarySource;
    /**
     * 
     * @type {TransferSummaryDestination}
     * @memberof TransferSummary
     */
    'destination'?: TransferSummaryDestination;
    /**
     * Client reference ID
     * @type {string}
     * @memberof TransferSummary
     */
    'clientReferenceId'?: string | null;
    /**
     * When the transfer was created
     * @type {string}
     * @memberof TransferSummary
     */
    'createdAt': string;
    /**
     * When the transfer was last updated
     * @type {string}
     * @memberof TransferSummary
     */
    'updatedAt': string;
}

export const TransferSummaryStateEnum = {
    AwaitingFunds: 'awaiting_funds',
    FundsReceived: 'funds_received',
    PaymentSubmitted: 'payment_submitted',
    PaymentProcessed: 'payment_processed',
    Canceled: 'canceled',
    Undeliverable: 'undeliverable',
    Returned: 'returned',
    Refunded: 'refunded'
} as const;

export type TransferSummaryStateEnum = typeof TransferSummaryStateEnum[keyof typeof TransferSummaryStateEnum];

/**
 * 
 * @export
 * @interface TransferSummaryDestination
 */
export interface TransferSummaryDestination {
    /**
     * Destination payment rail
     * @type {string}
     * @memberof TransferSummaryDestination
     */
    'paymentRail'?: string;
    /**
     * Destination wallet ID
     * @type {string}
     * @memberof TransferSummaryDestination
     */
    'walletId'?: string | null;
}
/**
 * 
 * @export
 * @interface TransferSummarySource
 */
export interface TransferSummarySource {
    /**
     * Source payment rail
     * @type {string}
     * @memberof TransferSummarySource
     */
    'paymentRail'?: string;
    /**
     * Source wallet ID
     * @type {string}
     * @memberof TransferSummarySource
     */
    'walletId'?: string | null;
}
/**
 * Bridge customer/KYB information
 * @export
 * @interface TreasuryCustomer
 */
export interface TreasuryCustomer {
    /**
     * Bridge customer ID
     * @type {string}
     * @memberof TreasuryCustomer
     */
    'id'?: string;
    /**
     * Customer type (business or individual)
     * @type {string}
     * @memberof TreasuryCustomer
     */
    'type'?: string;
    /**
     * KYB verification status
     * @type {string}
     * @memberof TreasuryCustomer
     */
    'kybStatus'?: TreasuryCustomerKybStatusEnum;
    /**
     * Customer email
     * @type {string}
     * @memberof TreasuryCustomer
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreasuryCustomer
     */
    'createdAt'?: string;
}

export const TreasuryCustomerKybStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected',
    Incomplete: 'incomplete',
    ManualReview: 'manual_review'
} as const;

export type TreasuryCustomerKybStatusEnum = typeof TreasuryCustomerKybStatusEnum[keyof typeof TreasuryCustomerKybStatusEnum];

/**
 * Treasury overview data
 * @export
 * @interface TreasuryOverviewData
 */
export interface TreasuryOverviewData {
    /**
     * 
     * @type {TreasuryWallet}
     * @memberof TreasuryOverviewData
     */
    'wallet'?: TreasuryWallet | null;
    /**
     * 
     * @type {Array<TreasuryVirtualAccount>}
     * @memberof TreasuryOverviewData
     */
    'virtualAccounts'?: Array<TreasuryVirtualAccount>;
    /**
     * 
     * @type {TreasuryCustomer}
     * @memberof TreasuryOverviewData
     */
    'customer'?: TreasuryCustomer;
    /**
     * Bridge customer ID
     * @type {string}
     * @memberof TreasuryOverviewData
     */
    'bridgeCustomerId'?: string;
    /**
     * Bridge wallet ID
     * @type {string}
     * @memberof TreasuryOverviewData
     */
    'bridgeWalletId'?: string;
}
/**
 * Treasury overview response
 * @export
 * @interface TreasuryOverviewResponse
 */
export interface TreasuryOverviewResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TreasuryOverviewResponse
     */
    'success': boolean;
    /**
     * 
     * @type {TreasuryOverviewData}
     * @memberof TreasuryOverviewResponse
     */
    'data': TreasuryOverviewData;
    /**
     * When the data was fetched from Bridge
     * @type {string}
     * @memberof TreasuryOverviewResponse
     */
    'fetchedAt': string;
}
/**
 * Individual treasury transaction
 * @export
 * @interface TreasuryTransaction
 */
export interface TreasuryTransaction {
    /**
     * Transaction ID
     * @type {string}
     * @memberof TreasuryTransaction
     */
    'id'?: string;
    /**
     * Transaction type
     * @type {string}
     * @memberof TreasuryTransaction
     */
    'type'?: TreasuryTransactionTypeEnum;
    /**
     * Transaction amount
     * @type {string}
     * @memberof TreasuryTransaction
     */
    'amount'?: string;
    /**
     * Currency code (e.g., USD, USDC)
     * @type {string}
     * @memberof TreasuryTransaction
     */
    'currency'?: string;
    /**
     * Source currency
     * @type {string}
     * @memberof TreasuryTransaction
     */
    'sourceCurrency'?: string;
    /**
     * Destination currency
     * @type {string}
     * @memberof TreasuryTransaction
     */
    'destinationCurrency'?: string;
    /**
     * Bridge event state
     * @type {string}
     * @memberof TreasuryTransaction
     */
    'state'?: string;
    /**
     * 
     * @type {TreasuryTransactionSource}
     * @memberof TreasuryTransaction
     */
    'source'?: TreasuryTransactionSource | null;
    /**
     * 
     * @type {TreasuryTransactionDestination}
     * @memberof TreasuryTransaction
     */
    'destination'?: TreasuryTransactionDestination;
    /**
     * 
     * @type {TreasuryTransactionFees}
     * @memberof TreasuryTransaction
     */
    'fees'?: TreasuryTransactionFees;
    /**
     * 
     * @type {TreasuryTransactionReceipt}
     * @memberof TreasuryTransaction
     */
    'receipt'?: TreasuryTransactionReceipt | null;
    /**
     * 
     * @type {string}
     * @memberof TreasuryTransaction
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreasuryTransaction
     */
    'updatedAt'?: string;
}

export const TreasuryTransactionTypeEnum = {
    Deposit: 'deposit',
    DepositPending: 'deposit_pending',
    Refund: 'refund',
    Unknown: 'unknown'
} as const;

export type TreasuryTransactionTypeEnum = typeof TreasuryTransactionTypeEnum[keyof typeof TreasuryTransactionTypeEnum];

/**
 * Destination details
 * @export
 * @interface TreasuryTransactionDestination
 */
export interface TreasuryTransactionDestination {
    /**
     * Destination chain/rail
     * @type {string}
     * @memberof TreasuryTransactionDestination
     */
    'paymentRail'?: string;
    /**
     * Destination wallet ID
     * @type {string}
     * @memberof TreasuryTransactionDestination
     */
    'walletId'?: string;
}
/**
 * Fee breakdown
 * @export
 * @interface TreasuryTransactionFees
 */
export interface TreasuryTransactionFees {
    /**
     * 
     * @type {string}
     * @memberof TreasuryTransactionFees
     */
    'developerFee'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreasuryTransactionFees
     */
    'exchangeFee'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreasuryTransactionFees
     */
    'gasFee'?: string;
}
/**
 * Receipt details
 * @export
 * @interface TreasuryTransactionReceipt
 */
export interface TreasuryTransactionReceipt {
    /**
     * 
     * @type {string}
     * @memberof TreasuryTransactionReceipt
     */
    'initialAmount'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreasuryTransactionReceipt
     */
    'finalAmount'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreasuryTransactionReceipt
     */
    'txHash'?: string;
}
/**
 * Source details
 * @export
 * @interface TreasuryTransactionSource
 */
export interface TreasuryTransactionSource {
    /**
     * Payment rail (e.g., wire, ach)
     * @type {string}
     * @memberof TreasuryTransactionSource
     */
    'paymentRail'?: string;
    /**
     * Sender name
     * @type {string}
     * @memberof TreasuryTransactionSource
     */
    'senderName'?: string;
    /**
     * Last 4 digits of sender account
     * @type {string}
     * @memberof TreasuryTransactionSource
     */
    'accountLast4'?: string;
}
/**
 * Treasury transaction history response
 * @export
 * @interface TreasuryTransactionsResponse
 */
export interface TreasuryTransactionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TreasuryTransactionsResponse
     */
    'success': boolean;
    /**
     * 
     * @type {TreasuryTransactionsResponseData}
     * @memberof TreasuryTransactionsResponse
     */
    'data': TreasuryTransactionsResponseData;
    /**
     * When the data was fetched from Bridge
     * @type {string}
     * @memberof TreasuryTransactionsResponse
     */
    'fetchedAt': string;
}
/**
 * 
 * @export
 * @interface TreasuryTransactionsResponseData
 */
export interface TreasuryTransactionsResponseData {
    /**
     * 
     * @type {Array<TreasuryTransaction>}
     * @memberof TreasuryTransactionsResponseData
     */
    'transactions': Array<TreasuryTransaction>;
    /**
     * 
     * @type {TransferListResponseDataPagination}
     * @memberof TreasuryTransactionsResponseData
     */
    'pagination': TransferListResponseDataPagination;
}
/**
 * Virtual bank account for deposits
 * @export
 * @interface TreasuryVirtualAccount
 */
export interface TreasuryVirtualAccount {
    /**
     * Virtual account ID
     * @type {string}
     * @memberof TreasuryVirtualAccount
     */
    'id'?: string;
    /**
     * Account status
     * @type {string}
     * @memberof TreasuryVirtualAccount
     */
    'status'?: TreasuryVirtualAccountStatusEnum;
    /**
     * Bank name
     * @type {string}
     * @memberof TreasuryVirtualAccount
     */
    'bankName'?: string;
    /**
     * Bank address
     * @type {string}
     * @memberof TreasuryVirtualAccount
     */
    'bankAddress'?: string;
    /**
     * Bank routing number
     * @type {string}
     * @memberof TreasuryVirtualAccount
     */
    'routingNumber'?: string;
    /**
     * Bank account number
     * @type {string}
     * @memberof TreasuryVirtualAccount
     */
    'accountNumber'?: string;
    /**
     * Beneficiary name for wire transfers
     * @type {string}
     * @memberof TreasuryVirtualAccount
     */
    'beneficiaryName'?: string;
    /**
     * Supported payment rails (e.g., ach_push, wire)
     * @type {Array<string>}
     * @memberof TreasuryVirtualAccount
     */
    'paymentRails'?: Array<string>;
    /**
     * Destination currency for deposits
     * @type {string}
     * @memberof TreasuryVirtualAccount
     */
    'destinationCurrency'?: string;
    /**
     * Destination blockchain chain
     * @type {string}
     * @memberof TreasuryVirtualAccount
     */
    'destinationChain'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreasuryVirtualAccount
     */
    'createdAt'?: string;
}

export const TreasuryVirtualAccountStatusEnum = {
    Pending: 'pending',
    Activated: 'activated'
} as const;

export type TreasuryVirtualAccountStatusEnum = typeof TreasuryVirtualAccountStatusEnum[keyof typeof TreasuryVirtualAccountStatusEnum];

/**
 * Treasury wallet with balances
 * @export
 * @interface TreasuryWallet
 */
export interface TreasuryWallet {
    /**
     * Bridge wallet ID
     * @type {string}
     * @memberof TreasuryWallet
     */
    'id'?: string;
    /**
     * Wallet blockchain address
     * @type {string}
     * @memberof TreasuryWallet
     */
    'address'?: string;
    /**
     * Blockchain chain (e.g., base, ethereum)
     * @type {string}
     * @memberof TreasuryWallet
     */
    'chain'?: string;
    /**
     * 
     * @type {Array<WalletBalance>}
     * @memberof TreasuryWallet
     */
    'balances'?: Array<WalletBalance>;
    /**
     * Primary USDC balance
     * @type {string}
     * @memberof TreasuryWallet
     */
    'usdcBalance'?: string;
    /**
     * Total USD-equivalent balance
     * @type {string}
     * @memberof TreasuryWallet
     */
    'totalUsdBalance'?: string;
}
/**
 * Response from GET /attestations/{attestationId}/trust
 * @export
 * @interface TrustEvaluationResponse
 */
export interface TrustEvaluationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TrustEvaluationResponse
     */
    'success': boolean;
    /**
     * 
     * @type {TrustEvaluationResponseData}
     * @memberof TrustEvaluationResponse
     */
    'data': TrustEvaluationResponseData;
}
/**
 * 
 * @export
 * @interface TrustEvaluationResponseData
 */
export interface TrustEvaluationResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof TrustEvaluationResponseData
     */
    'isTrusted': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrustEvaluationResponseData
     */
    'reasons'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof TrustEvaluationResponseData
     */
    'meetsRequirements'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TrustEvaluationResponseData
     */
    'attestationId'?: string;
}
/**
 * Response from GET /trust
 * @export
 * @interface TrustSettingsResponse
 */
export interface TrustSettingsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TrustSettingsResponse
     */
    'success': boolean;
    /**
     * 
     * @type {TrustSettingsResponseData}
     * @memberof TrustSettingsResponse
     */
    'data': TrustSettingsResponseData;
}
/**
 * 
 * @export
 * @interface TrustSettingsResponseData
 */
export interface TrustSettingsResponseData {
    /**
     * 
     * @type {Array<TrustSettingsResponseDataSettingsInner>}
     * @memberof TrustSettingsResponseData
     */
    'settings': Array<TrustSettingsResponseDataSettingsInner>;
}
/**
 * 
 * @export
 * @interface TrustSettingsResponseDataSettingsInner
 */
export interface TrustSettingsResponseDataSettingsInner {
    /**
     * 
     * @type {string}
     * @memberof TrustSettingsResponseDataSettingsInner
     */
    'providerCode'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TrustSettingsResponseDataSettingsInner
     */
    'isTrusted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TrustSettingsResponseDataSettingsInner
     */
    'minConfidenceScore'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TrustSettingsResponseDataSettingsInner
     */
    'requiresCipCompliance'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TrustSettingsResponseDataSettingsInner
     */
    'updatedAt'?: string;
}
/**
 * Response from PUT /trust/{provider_code}
 * @export
 * @interface TrustSettingsUpdateResponse
 */
export interface TrustSettingsUpdateResponse {
    /**
     * 
     * @type {boolean}
     * @memberof TrustSettingsUpdateResponse
     */
    'success': boolean;
    /**
     * 
     * @type {TrustSettingsUpdateResponseData}
     * @memberof TrustSettingsUpdateResponse
     */
    'data': TrustSettingsUpdateResponseData;
}
/**
 * 
 * @export
 * @interface TrustSettingsUpdateResponseData
 */
export interface TrustSettingsUpdateResponseData {
    /**
     * 
     * @type {string}
     * @memberof TrustSettingsUpdateResponseData
     */
    'providerCode': string;
    /**
     * 
     * @type {boolean}
     * @memberof TrustSettingsUpdateResponseData
     */
    'updated': boolean;
}
/**
 * Response from POST /sdx-tokens/document-handle
 * @export
 * @interface UnsignedDocHandleResponse
 */
export interface UnsignedDocHandleResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UnsignedDocHandleResponse
     */
    'success': boolean;
    /**
     * 
     * @type {UnsignedDocHandleResponseData}
     * @memberof UnsignedDocHandleResponse
     */
    'data': UnsignedDocHandleResponseData;
}
/**
 * 
 * @export
 * @interface UnsignedDocHandleResponseData
 */
export interface UnsignedDocHandleResponseData {
    /**
     * Application ID the handle was stored for
     * @type {string}
     * @memberof UnsignedDocHandleResponseData
     */
    'applicationId': string;
    /**
     * SDX handle for the unsigned document
     * @type {string}
     * @memberof UnsignedDocHandleResponseData
     */
    'unsignedDocHandle': string;
    /**
     * When the document was sent/stored
     * @type {string}
     * @memberof UnsignedDocHandleResponseData
     */
    'docsSentAt'?: string | null;
}
/**
 * 
 * @export
 * @interface UnsignedDocumentHandleRequest
 */
export interface UnsignedDocumentHandleRequest {
    /**
     * Application ID
     * @type {string}
     * @memberof UnsignedDocumentHandleRequest
     */
    'applicationId': string;
    /**
     * SDX handle for unsigned contract
     * @type {string}
     * @memberof UnsignedDocumentHandleRequest
     */
    'unsignedDocHandle': string;
    /**
     * Type of contract (e.g., loan_agreement, promissory_note)
     * @type {string}
     * @memberof UnsignedDocumentHandleRequest
     */
    'documentType': string;
    /**
     * Additional document metadata
     * @type {{ [key: string]: any; }}
     * @memberof UnsignedDocumentHandleRequest
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateApplicationStatusRequest
 */
export interface UpdateApplicationStatusRequest {
    /**
     * 
     * @type {ApplicationStatus}
     * @memberof UpdateApplicationStatusRequest
     */
    'status': ApplicationStatus;
}


/**
 * 
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorResponse
     */
    'error': ValidationErrorResponseErrorEnum;
    /**
     * Human-readable error description
     * @type {string}
     * @memberof ValidationErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ValidationErrorResponse
     */
    'status': ValidationErrorResponseStatusEnum;
    /**
     * Unique request identifier for debugging/support
     * @type {string}
     * @memberof ValidationErrorResponse
     */
    'requestId': string;
    /**
     * Detailed validation errors by field
     * @type {Array<ValidationErrorResponseAllOfDetails>}
     * @memberof ValidationErrorResponse
     */
    'details': Array<ValidationErrorResponseAllOfDetails>;
}

export const ValidationErrorResponseErrorEnum = {
    ValidationError: 'VALIDATION_ERROR'
} as const;

export type ValidationErrorResponseErrorEnum = typeof ValidationErrorResponseErrorEnum[keyof typeof ValidationErrorResponseErrorEnum];
export const ValidationErrorResponseStatusEnum = {
    NUMBER_400: 400
} as const;

export type ValidationErrorResponseStatusEnum = typeof ValidationErrorResponseStatusEnum[keyof typeof ValidationErrorResponseStatusEnum];

/**
 * 
 * @export
 * @interface ValidationErrorResponseAllOfDetails
 */
export interface ValidationErrorResponseAllOfDetails {
    /**
     * Field path that failed validation
     * @type {string}
     * @memberof ValidationErrorResponseAllOfDetails
     */
    'field': string;
    /**
     * Validation error message
     * @type {string}
     * @memberof ValidationErrorResponseAllOfDetails
     */
    'message': string;
}
/**
 * Aggregate wallet totals
 * @export
 * @interface WalletAggregate
 */
export interface WalletAggregate {
    /**
     * Total number of wallets
     * @type {number}
     * @memberof WalletAggregate
     */
    'totalWalletCount'?: number;
    /**
     * Main wallet balance
     * @type {string}
     * @memberof WalletAggregate
     */
    'mainWalletBalance'?: string;
    /**
     * Total loan wallets balance
     * @type {string}
     * @memberof WalletAggregate
     */
    'loanWalletsBalance'?: string;
    /**
     * Combined total balance
     * @type {string}
     * @memberof WalletAggregate
     */
    'totalBalance'?: string;
}
/**
 * Individual currency balance
 * @export
 * @interface WalletBalance
 */
export interface WalletBalance {
    /**
     * Currency code (e.g., USDC)
     * @type {string}
     * @memberof WalletBalance
     */
    'currency'?: string;
    /**
     * Balance amount
     * @type {string}
     * @memberof WalletBalance
     */
    'balance'?: string;
    /**
     * Blockchain chain
     * @type {string}
     * @memberof WalletBalance
     */
    'chain'?: string;
}
/**
 * Response from POST /webhook/{provider}
 * @export
 * @interface WebhookAckResponse
 */
export interface WebhookAckResponse {
    /**
     * 
     * @type {boolean}
     * @memberof WebhookAckResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof WebhookAckResponse
     */
    'message'?: string;
}
/**
 * Webhook configuration details
 * @export
 * @interface WebhookConfigResponse
 */
export interface WebhookConfigResponse {
    /**
     * 
     * @type {boolean}
     * @memberof WebhookConfigResponse
     */
    'success': boolean;
    /**
     * 
     * @type {WebhookConfigResponseData}
     * @memberof WebhookConfigResponse
     */
    'data': WebhookConfigResponseData;
}
/**
 * 
 * @export
 * @interface WebhookConfigResponseData
 */
export interface WebhookConfigResponseData {
    /**
     * Currently configured webhook URL
     * @type {string}
     * @memberof WebhookConfigResponseData
     */
    'webhookUrl'?: string | null;
    /**
     * Whether a webhook secret is configured
     * @type {boolean}
     * @memberof WebhookConfigResponseData
     */
    'webhookSecretSet': boolean;
    /**
     * Masked preview of the webhook secret (first 7 and last 4 chars)
     * @type {string}
     * @memberof WebhookConfigResponseData
     */
    'webhookSecretPreview'?: string | null;
}
/**
 * Result of rotating webhook secret (secret shown only once!)
 * @export
 * @interface WebhookSecretRotateResponse
 */
export interface WebhookSecretRotateResponse {
    /**
     * 
     * @type {boolean}
     * @memberof WebhookSecretRotateResponse
     */
    'success': boolean;
    /**
     * 
     * @type {WebhookSecretRotateResponseData}
     * @memberof WebhookSecretRotateResponse
     */
    'data': WebhookSecretRotateResponseData;
}
/**
 * 
 * @export
 * @interface WebhookSecretRotateResponseData
 */
export interface WebhookSecretRotateResponseData {
    /**
     * The new webhook secret. IMPORTANT: This is shown only once! Save it immediately - it cannot be retrieved again. 
     * @type {string}
     * @memberof WebhookSecretRotateResponseData
     */
    'webhookSecret': string;
    /**
     * Confirmation message
     * @type {string}
     * @memberof WebhookSecretRotateResponseData
     */
    'message': string;
    /**
     * Warning about updating webhook handler
     * @type {string}
     * @memberof WebhookSecretRotateResponseData
     */
    'warning': string;
}
/**
 * Result of sending a test webhook
 * @export
 * @interface WebhookTestResponse
 */
export interface WebhookTestResponse {
    /**
     * 
     * @type {boolean}
     * @memberof WebhookTestResponse
     */
    'success': boolean;
    /**
     * 
     * @type {WebhookTestResponseData}
     * @memberof WebhookTestResponse
     */
    'data': WebhookTestResponseData;
}
/**
 * 
 * @export
 * @interface WebhookTestResponseData
 */
export interface WebhookTestResponseData {
    /**
     * Whether the webhook was successfully delivered
     * @type {boolean}
     * @memberof WebhookTestResponseData
     */
    'delivered': boolean;
    /**
     * HTTP status code returned by the webhook endpoint
     * @type {number}
     * @memberof WebhookTestResponseData
     */
    'statusCode'?: number;
    /**
     * The webhook URL that was tested
     * @type {string}
     * @memberof WebhookTestResponseData
     */
    'webhookUrl': string;
    /**
     * Status message or error details
     * @type {string}
     * @memberof WebhookTestResponseData
     */
    'message': string;
    /**
     * Error message if delivery failed
     * @type {string}
     * @memberof WebhookTestResponseData
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface WebhookUrlUpdateRequest
 */
export interface WebhookUrlUpdateRequest {
    /**
     * New webhook URL (must be HTTPS) or null to disable webhooks
     * @type {string}
     * @memberof WebhookUrlUpdateRequest
     */
    'webhookUrl': string | null;
}
/**
 * Result of webhook URL update
 * @export
 * @interface WebhookUrlUpdateResponse
 */
export interface WebhookUrlUpdateResponse {
    /**
     * 
     * @type {boolean}
     * @memberof WebhookUrlUpdateResponse
     */
    'success': boolean;
    /**
     * 
     * @type {WebhookUrlUpdateResponseData}
     * @memberof WebhookUrlUpdateResponse
     */
    'data': WebhookUrlUpdateResponseData;
}
/**
 * 
 * @export
 * @interface WebhookUrlUpdateResponseData
 */
export interface WebhookUrlUpdateResponseData {
    /**
     * The updated webhook URL
     * @type {string}
     * @memberof WebhookUrlUpdateResponseData
     */
    'webhookUrl'?: string | null;
    /**
     * Status message
     * @type {string}
     * @memberof WebhookUrlUpdateResponseData
     */
    'message': string;
}

/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lender declines an application after performing a hard credit pull. Used for ECOA/Reg B adverse action notice tracking.  **Requirements:** - Application must be in ACCEPTED, PROCESSING, or APPROVED status - Lender must have been routed to this application - Records declinedAt timestamp for 30-day adverse action notice deadline  **Note:** Reason codes and adverse action notice content are the lender\'s responsibility. This endpoint only tracks the decline event for compliance. 
         * @summary Decline application after hard pull
         * @param {string} applicationId Unique identifier for the application
         * @param {DeclineApplicationRequest} [declineApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineApplication: async (applicationId: string, declineApplicationRequest?: DeclineApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('declineApplication', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/decline`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(declineApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application details. - Neobanks can access their own applications - Lenders can access applications routed to them 
         * @summary Get application details
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplication', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current status of a loan application (neobank only)
         * @summary Get application status
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationStatus', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/status`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get hard pull consent for an application (lender-only endpoint)
         * @summary Get hard pull consent
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardPullConsent: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getHardPullConsent', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/consent`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of applications. - Neobanks: Returns only their own applications - Lenders: Returns applications routed to them  Neobanks can filter by `externalId` (their user reference) or `borrowerWalletAddress` (wallet address) to efficiently retrieve applications for a specific borrower. 
         * @summary List applications
         * @param {ApplicationStatus} [status] Filter by application status
         * @param {ListApplicationsProductTypeEnum} [productType] Filter by product type
         * @param {string} [externalId] Filter by application\&#39;s external reference ID (neobank-only). Exact match. Use this when you have your own user ID system. 
         * @param {string} [borrowerWalletAddress] Filter by borrower\&#39;s wallet address (case-insensitive, neobank-only). Use this for wallet-first applications. 
         * @param {number} [limit] Number of results to return
         * @param {number} [offset] Number of results to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (status?: ApplicationStatus, productType?: ListApplicationsProductTypeEnum, externalId?: string, borrowerWalletAddress?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (productType !== undefined) {
                localVarQueryParameter['productType'] = productType;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['externalId'] = externalId;
            }

            if (borrowerWalletAddress !== undefined) {
                localVarQueryParameter['borrowerWalletAddress'] = borrowerWalletAddress;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Neobank submits an encrypted loan application packet. The application is broadcast to all configured lenders supporting the product type. 
         * @summary Submit loan application
         * @param {ApplicationRequest} applicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitApplication: async (applicationRequest: ApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationRequest' is not null or undefined
            assertParamExists('submitApplication', 'applicationRequest', applicationRequest)
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finalize a draft application by attaching per-lender KYC handles and routing to lenders.  **Prerequisites:** - Application must be in DRAFT status (created with draft: true) - KYC documents must be uploaded to SDX for each lender using their public key  **What this does:** 1. Validates perLenderKycHandles match the original encryptedPayloads lenders 2. Creates ApplicationRoutes with per-lender KYC handles attached 3. Transitions status from DRAFT to OFFERS_PENDING 4. Sends webhooks to notify lenders  **Idempotency:** This endpoint is naturally idempotent. Calling it on an already-submitted application returns 200 with current state and alreadySubmitted: true. 
         * @summary Submit draft application
         * @param {string} applicationId Unique identifier for the application
         * @param {DraftSubmitRequest} [draftSubmitRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitDraftApplication: async (applicationId: string, draftSubmitRequest?: DraftSubmitRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('submitDraftApplication', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/submit`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(draftSubmitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update application status (neobank only)
         * @summary Update application status
         * @param {string} applicationId Unique identifier for the application
         * @param {UpdateApplicationStatusRequest} updateApplicationStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationStatus: async (applicationId: string, updateApplicationStatusRequest: UpdateApplicationStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('updateApplicationStatus', 'applicationId', applicationId)
            // verify required parameter 'updateApplicationStatusRequest' is not null or undefined
            assertParamExists('updateApplicationStatus', 'updateApplicationStatusRequest', updateApplicationStatusRequest)
            const localVarPath = `/applications/{applicationId}/status`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApplicationStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Lender declines an application after performing a hard credit pull. Used for ECOA/Reg B adverse action notice tracking.  **Requirements:** - Application must be in ACCEPTED, PROCESSING, or APPROVED status - Lender must have been routed to this application - Records declinedAt timestamp for 30-day adverse action notice deadline  **Note:** Reason codes and adverse action notice content are the lender\'s responsibility. This endpoint only tracks the decline event for compliance. 
         * @summary Decline application after hard pull
         * @param {string} applicationId Unique identifier for the application
         * @param {DeclineApplicationRequest} [declineApplicationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineApplication(applicationId: string, declineApplicationRequest?: DeclineApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclineApplication200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineApplication(applicationId, declineApplicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.declineApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get application details. - Neobanks can access their own applications - Lenders can access applications routed to them 
         * @summary Get application details
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.getApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the current status of a loan application (neobank only)
         * @summary Get application status
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationStatus(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationStatus(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.getApplicationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get hard pull consent for an application (lender-only endpoint)
         * @summary Get hard pull consent
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHardPullConsent(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHardPullConsent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHardPullConsent(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.getHardPullConsent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve list of applications. - Neobanks: Returns only their own applications - Lenders: Returns applications routed to them  Neobanks can filter by `externalId` (their user reference) or `borrowerWalletAddress` (wallet address) to efficiently retrieve applications for a specific borrower. 
         * @summary List applications
         * @param {ApplicationStatus} [status] Filter by application status
         * @param {ListApplicationsProductTypeEnum} [productType] Filter by product type
         * @param {string} [externalId] Filter by application\&#39;s external reference ID (neobank-only). Exact match. Use this when you have your own user ID system. 
         * @param {string} [borrowerWalletAddress] Filter by borrower\&#39;s wallet address (case-insensitive, neobank-only). Use this for wallet-first applications. 
         * @param {number} [limit] Number of results to return
         * @param {number} [offset] Number of results to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(status?: ApplicationStatus, productType?: ListApplicationsProductTypeEnum, externalId?: string, borrowerWalletAddress?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplications200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(status, productType, externalId, borrowerWalletAddress, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.listApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Neobank submits an encrypted loan application packet. The application is broadcast to all configured lenders supporting the product type. 
         * @summary Submit loan application
         * @param {ApplicationRequest} applicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitApplication(applicationRequest: ApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationSubmitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitApplication(applicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.submitApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Finalize a draft application by attaching per-lender KYC handles and routing to lenders.  **Prerequisites:** - Application must be in DRAFT status (created with draft: true) - KYC documents must be uploaded to SDX for each lender using their public key  **What this does:** 1. Validates perLenderKycHandles match the original encryptedPayloads lenders 2. Creates ApplicationRoutes with per-lender KYC handles attached 3. Transitions status from DRAFT to OFFERS_PENDING 4. Sends webhooks to notify lenders  **Idempotency:** This endpoint is naturally idempotent. Calling it on an already-submitted application returns 200 with current state and alreadySubmitted: true. 
         * @summary Submit draft application
         * @param {string} applicationId Unique identifier for the application
         * @param {DraftSubmitRequest} [draftSubmitRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitDraftApplication(applicationId: string, draftSubmitRequest?: DraftSubmitRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DraftSubmitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitDraftApplication(applicationId, draftSubmitRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.submitDraftApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update application status (neobank only)
         * @summary Update application status
         * @param {string} applicationId Unique identifier for the application
         * @param {UpdateApplicationStatusRequest} updateApplicationStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplicationStatus(applicationId: string, updateApplicationStatusRequest: UpdateApplicationStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationStatusUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicationStatus(applicationId, updateApplicationStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.updateApplicationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * Lender declines an application after performing a hard credit pull. Used for ECOA/Reg B adverse action notice tracking.  **Requirements:** - Application must be in ACCEPTED, PROCESSING, or APPROVED status - Lender must have been routed to this application - Records declinedAt timestamp for 30-day adverse action notice deadline  **Note:** Reason codes and adverse action notice content are the lender\'s responsibility. This endpoint only tracks the decline event for compliance. 
         * @summary Decline application after hard pull
         * @param {ApplicationsApiDeclineApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineApplication(requestParameters: ApplicationsApiDeclineApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeclineApplication200Response> {
            return localVarFp.declineApplication(requestParameters.applicationId, requestParameters.declineApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application details. - Neobanks can access their own applications - Lenders can access applications routed to them 
         * @summary Get application details
         * @param {ApplicationsApiGetApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(requestParameters: ApplicationsApiGetApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationResponse> {
            return localVarFp.getApplication(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current status of a loan application (neobank only)
         * @summary Get application status
         * @param {ApplicationsApiGetApplicationStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus(requestParameters: ApplicationsApiGetApplicationStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationStatusResponse> {
            return localVarFp.getApplicationStatus(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get hard pull consent for an application (lender-only endpoint)
         * @summary Get hard pull consent
         * @param {ApplicationsApiGetHardPullConsentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardPullConsent(requestParameters: ApplicationsApiGetHardPullConsentRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetHardPullConsent200Response> {
            return localVarFp.getHardPullConsent(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of applications. - Neobanks: Returns only their own applications - Lenders: Returns applications routed to them  Neobanks can filter by `externalId` (their user reference) or `borrowerWalletAddress` (wallet address) to efficiently retrieve applications for a specific borrower. 
         * @summary List applications
         * @param {ApplicationsApiListApplicationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(requestParameters: ApplicationsApiListApplicationsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListApplications200Response> {
            return localVarFp.listApplications(requestParameters.status, requestParameters.productType, requestParameters.externalId, requestParameters.borrowerWalletAddress, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Neobank submits an encrypted loan application packet. The application is broadcast to all configured lenders supporting the product type. 
         * @summary Submit loan application
         * @param {ApplicationsApiSubmitApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitApplication(requestParameters: ApplicationsApiSubmitApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationSubmitResponse> {
            return localVarFp.submitApplication(requestParameters.applicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Finalize a draft application by attaching per-lender KYC handles and routing to lenders.  **Prerequisites:** - Application must be in DRAFT status (created with draft: true) - KYC documents must be uploaded to SDX for each lender using their public key  **What this does:** 1. Validates perLenderKycHandles match the original encryptedPayloads lenders 2. Creates ApplicationRoutes with per-lender KYC handles attached 3. Transitions status from DRAFT to OFFERS_PENDING 4. Sends webhooks to notify lenders  **Idempotency:** This endpoint is naturally idempotent. Calling it on an already-submitted application returns 200 with current state and alreadySubmitted: true. 
         * @summary Submit draft application
         * @param {ApplicationsApiSubmitDraftApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitDraftApplication(requestParameters: ApplicationsApiSubmitDraftApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<DraftSubmitResponse> {
            return localVarFp.submitDraftApplication(requestParameters.applicationId, requestParameters.draftSubmitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update application status (neobank only)
         * @summary Update application status
         * @param {ApplicationsApiUpdateApplicationStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationStatus(requestParameters: ApplicationsApiUpdateApplicationStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationStatusUpdateResponse> {
            return localVarFp.updateApplicationStatus(requestParameters.applicationId, requestParameters.updateApplicationStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - interface
 * @export
 * @interface ApplicationsApi
 */
export interface ApplicationsApiInterface {
    /**
     * Lender declines an application after performing a hard credit pull. Used for ECOA/Reg B adverse action notice tracking.  **Requirements:** - Application must be in ACCEPTED, PROCESSING, or APPROVED status - Lender must have been routed to this application - Records declinedAt timestamp for 30-day adverse action notice deadline  **Note:** Reason codes and adverse action notice content are the lender\'s responsibility. This endpoint only tracks the decline event for compliance. 
     * @summary Decline application after hard pull
     * @param {ApplicationsApiDeclineApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApiInterface
     */
    declineApplication(requestParameters: ApplicationsApiDeclineApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeclineApplication200Response>;

    /**
     * Get application details. - Neobanks can access their own applications - Lenders can access applications routed to them 
     * @summary Get application details
     * @param {ApplicationsApiGetApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApiInterface
     */
    getApplication(requestParameters: ApplicationsApiGetApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationResponse>;

    /**
     * Retrieve the current status of a loan application (neobank only)
     * @summary Get application status
     * @param {ApplicationsApiGetApplicationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApiInterface
     */
    getApplicationStatus(requestParameters: ApplicationsApiGetApplicationStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationStatusResponse>;

    /**
     * Get hard pull consent for an application (lender-only endpoint)
     * @summary Get hard pull consent
     * @param {ApplicationsApiGetHardPullConsentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApiInterface
     */
    getHardPullConsent(requestParameters: ApplicationsApiGetHardPullConsentRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetHardPullConsent200Response>;

    /**
     * Retrieve list of applications. - Neobanks: Returns only their own applications - Lenders: Returns applications routed to them  Neobanks can filter by `externalId` (their user reference) or `borrowerWalletAddress` (wallet address) to efficiently retrieve applications for a specific borrower. 
     * @summary List applications
     * @param {ApplicationsApiListApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApiInterface
     */
    listApplications(requestParameters?: ApplicationsApiListApplicationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListApplications200Response>;

    /**
     * Neobank submits an encrypted loan application packet. The application is broadcast to all configured lenders supporting the product type. 
     * @summary Submit loan application
     * @param {ApplicationsApiSubmitApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApiInterface
     */
    submitApplication(requestParameters: ApplicationsApiSubmitApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationSubmitResponse>;

    /**
     * Finalize a draft application by attaching per-lender KYC handles and routing to lenders.  **Prerequisites:** - Application must be in DRAFT status (created with draft: true) - KYC documents must be uploaded to SDX for each lender using their public key  **What this does:** 1. Validates perLenderKycHandles match the original encryptedPayloads lenders 2. Creates ApplicationRoutes with per-lender KYC handles attached 3. Transitions status from DRAFT to OFFERS_PENDING 4. Sends webhooks to notify lenders  **Idempotency:** This endpoint is naturally idempotent. Calling it on an already-submitted application returns 200 with current state and alreadySubmitted: true. 
     * @summary Submit draft application
     * @param {ApplicationsApiSubmitDraftApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApiInterface
     */
    submitDraftApplication(requestParameters: ApplicationsApiSubmitDraftApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<DraftSubmitResponse>;

    /**
     * Update application status (neobank only)
     * @summary Update application status
     * @param {ApplicationsApiUpdateApplicationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApiInterface
     */
    updateApplicationStatus(requestParameters: ApplicationsApiUpdateApplicationStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApplicationStatusUpdateResponse>;

}

/**
 * Request parameters for declineApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiDeclineApplicationRequest
 */
export interface ApplicationsApiDeclineApplicationRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof ApplicationsApiDeclineApplication
     */
    readonly applicationId: string

    /**
     * 
     * @type {DeclineApplicationRequest}
     * @memberof ApplicationsApiDeclineApplication
     */
    readonly declineApplicationRequest?: DeclineApplicationRequest
}

/**
 * Request parameters for getApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiGetApplicationRequest
 */
export interface ApplicationsApiGetApplicationRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof ApplicationsApiGetApplication
     */
    readonly applicationId: string
}

/**
 * Request parameters for getApplicationStatus operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiGetApplicationStatusRequest
 */
export interface ApplicationsApiGetApplicationStatusRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof ApplicationsApiGetApplicationStatus
     */
    readonly applicationId: string
}

/**
 * Request parameters for getHardPullConsent operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiGetHardPullConsentRequest
 */
export interface ApplicationsApiGetHardPullConsentRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof ApplicationsApiGetHardPullConsent
     */
    readonly applicationId: string
}

/**
 * Request parameters for listApplications operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiListApplicationsRequest
 */
export interface ApplicationsApiListApplicationsRequest {
    /**
     * Filter by application status
     * @type {ApplicationStatus}
     * @memberof ApplicationsApiListApplications
     */
    readonly status?: ApplicationStatus

    /**
     * Filter by product type
     * @type {'consumer' | 'auto' | 'mortgage' | 'personal' | 'business'}
     * @memberof ApplicationsApiListApplications
     */
    readonly productType?: ListApplicationsProductTypeEnum

    /**
     * Filter by application\&#39;s external reference ID (neobank-only). Exact match. Use this when you have your own user ID system. 
     * @type {string}
     * @memberof ApplicationsApiListApplications
     */
    readonly externalId?: string

    /**
     * Filter by borrower\&#39;s wallet address (case-insensitive, neobank-only). Use this for wallet-first applications. 
     * @type {string}
     * @memberof ApplicationsApiListApplications
     */
    readonly borrowerWalletAddress?: string

    /**
     * Number of results to return
     * @type {number}
     * @memberof ApplicationsApiListApplications
     */
    readonly limit?: number

    /**
     * Number of results to skip
     * @type {number}
     * @memberof ApplicationsApiListApplications
     */
    readonly offset?: number
}

/**
 * Request parameters for submitApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiSubmitApplicationRequest
 */
export interface ApplicationsApiSubmitApplicationRequest {
    /**
     * 
     * @type {ApplicationRequest}
     * @memberof ApplicationsApiSubmitApplication
     */
    readonly applicationRequest: ApplicationRequest
}

/**
 * Request parameters for submitDraftApplication operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiSubmitDraftApplicationRequest
 */
export interface ApplicationsApiSubmitDraftApplicationRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof ApplicationsApiSubmitDraftApplication
     */
    readonly applicationId: string

    /**
     * 
     * @type {DraftSubmitRequest}
     * @memberof ApplicationsApiSubmitDraftApplication
     */
    readonly draftSubmitRequest?: DraftSubmitRequest
}

/**
 * Request parameters for updateApplicationStatus operation in ApplicationsApi.
 * @export
 * @interface ApplicationsApiUpdateApplicationStatusRequest
 */
export interface ApplicationsApiUpdateApplicationStatusRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof ApplicationsApiUpdateApplicationStatus
     */
    readonly applicationId: string

    /**
     * 
     * @type {UpdateApplicationStatusRequest}
     * @memberof ApplicationsApiUpdateApplicationStatus
     */
    readonly updateApplicationStatusRequest: UpdateApplicationStatusRequest
}

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI implements ApplicationsApiInterface {
    /**
     * Lender declines an application after performing a hard credit pull. Used for ECOA/Reg B adverse action notice tracking.  **Requirements:** - Application must be in ACCEPTED, PROCESSING, or APPROVED status - Lender must have been routed to this application - Records declinedAt timestamp for 30-day adverse action notice deadline  **Note:** Reason codes and adverse action notice content are the lender\'s responsibility. This endpoint only tracks the decline event for compliance. 
     * @summary Decline application after hard pull
     * @param {ApplicationsApiDeclineApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public declineApplication(requestParameters: ApplicationsApiDeclineApplicationRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).declineApplication(requestParameters.applicationId, requestParameters.declineApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application details. - Neobanks can access their own applications - Lenders can access applications routed to them 
     * @summary Get application details
     * @param {ApplicationsApiGetApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplication(requestParameters: ApplicationsApiGetApplicationRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplication(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the current status of a loan application (neobank only)
     * @summary Get application status
     * @param {ApplicationsApiGetApplicationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplicationStatus(requestParameters: ApplicationsApiGetApplicationStatusRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplicationStatus(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get hard pull consent for an application (lender-only endpoint)
     * @summary Get hard pull consent
     * @param {ApplicationsApiGetHardPullConsentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getHardPullConsent(requestParameters: ApplicationsApiGetHardPullConsentRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getHardPullConsent(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of applications. - Neobanks: Returns only their own applications - Lenders: Returns applications routed to them  Neobanks can filter by `externalId` (their user reference) or `borrowerWalletAddress` (wallet address) to efficiently retrieve applications for a specific borrower. 
     * @summary List applications
     * @param {ApplicationsApiListApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplications(requestParameters: ApplicationsApiListApplicationsRequest = {}, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplications(requestParameters.status, requestParameters.productType, requestParameters.externalId, requestParameters.borrowerWalletAddress, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Neobank submits an encrypted loan application packet. The application is broadcast to all configured lenders supporting the product type. 
     * @summary Submit loan application
     * @param {ApplicationsApiSubmitApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public submitApplication(requestParameters: ApplicationsApiSubmitApplicationRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).submitApplication(requestParameters.applicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finalize a draft application by attaching per-lender KYC handles and routing to lenders.  **Prerequisites:** - Application must be in DRAFT status (created with draft: true) - KYC documents must be uploaded to SDX for each lender using their public key  **What this does:** 1. Validates perLenderKycHandles match the original encryptedPayloads lenders 2. Creates ApplicationRoutes with per-lender KYC handles attached 3. Transitions status from DRAFT to OFFERS_PENDING 4. Sends webhooks to notify lenders  **Idempotency:** This endpoint is naturally idempotent. Calling it on an already-submitted application returns 200 with current state and alreadySubmitted: true. 
     * @summary Submit draft application
     * @param {ApplicationsApiSubmitDraftApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public submitDraftApplication(requestParameters: ApplicationsApiSubmitDraftApplicationRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).submitDraftApplication(requestParameters.applicationId, requestParameters.draftSubmitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update application status (neobank only)
     * @summary Update application status
     * @param {ApplicationsApiUpdateApplicationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public updateApplicationStatus(requestParameters: ApplicationsApiUpdateApplicationStatusRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).updateApplicationStatus(requestParameters.applicationId, requestParameters.updateApplicationStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListApplicationsProductTypeEnum = {
    Consumer: 'consumer',
    Auto: 'auto',
    Mortgage: 'mortgage',
    Personal: 'personal',
    Business: 'business'
} as const;
export type ListApplicationsProductTypeEnum = typeof ListApplicationsProductTypeEnum[keyof typeof ListApplicationsProductTypeEnum];


/**
 * AttestationApi - axios parameter creator
 * @export
 */
export const AttestationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Configure lender\'s trust settings for a KYC provider
         * @summary Configure lender trust settings
         * @param {string} providerCode 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureLenderTrust: async (providerCode: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerCode' is not null or undefined
            assertParamExists('configureLenderTrust', 'providerCode', providerCode)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('configureLenderTrust', 'body', body)
            const localVarPath = `/trust/{provider_code}`
                .replace(`{${"provider_code"}}`, encodeURIComponent(String(providerCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if lender trusts a specific attestation
         * @summary Evaluate attestation trust
         * @param {string} attestationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateAttestationTrust: async (attestationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attestationId' is not null or undefined
            assertParamExists('evaluateAttestationTrust', 'attestationId', attestationId)
            const localVarPath = `/attestations/{attestationId}/trust`
                .replace(`{${"attestationId"}}`, encodeURIComponent(String(attestationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get attestations for an application (lender only)
         * @summary Get attestations for application
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttestations: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getAttestations', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/attestations`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of supported KYC providers
         * @summary Get supported KYC providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKYCProviders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get KYC verification status for an application (neobank only)
         * @summary Get KYC status
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKYCStatus: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getKYCStatus', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/kyc/status`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get lender\'s current trust settings for all providers
         * @summary Get lender trust settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLenderTrustSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/trust`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SDX access token for proof retrieval (if lender trusts attestation)
         * @summary Get proof access token
         * @param {string} attestationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProofAccessToken: async (attestationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attestationId' is not null or undefined
            assertParamExists('getProofAccessToken', 'attestationId', attestationId)
            const localVarPath = `/attestations/{attestationId}/proof-token`
                .replace(`{${"attestationId"}}`, encodeURIComponent(String(attestationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate KYC verification for an application (neobank only)
         * @summary Initiate KYC verification
         * @param {string} applicationId Unique identifier for the application
         * @param {InitiateKYCRequest} initiateKYCRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateKYC: async (applicationId: string, initiateKYCRequest: InitiateKYCRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('initiateKYC', 'applicationId', applicationId)
            // verify required parameter 'initiateKYCRequest' is not null or undefined
            assertParamExists('initiateKYC', 'initiateKYCRequest', initiateKYCRequest)
            const localVarPath = `/applications/{applicationId}/kyc/initiate`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiateKYCRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Webhook endpoint for KYC providers to post results
         * @summary KYC provider webhook
         * @param {string} provider 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycProviderWebhook: async (provider: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('kycProviderWebhook', 'provider', provider)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('kycProviderWebhook', 'body', body)
            const localVarPath = `/webhook/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store KYC attestation for an application (KYC provider endpoint)
         * @summary Store attestation
         * @param {string} applicationId Unique identifier for the application
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAttestation: async (applicationId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('storeAttestation', 'applicationId', applicationId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('storeAttestation', 'body', body)
            const localVarPath = `/applications/{applicationId}/attestations`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttestationApi - functional programming interface
 * @export
 */
export const AttestationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttestationApiAxiosParamCreator(configuration)
    return {
        /**
         * Configure lender\'s trust settings for a KYC provider
         * @summary Configure lender trust settings
         * @param {string} providerCode 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureLenderTrust(providerCode: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrustSettingsUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureLenderTrust(providerCode, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttestationApi.configureLenderTrust']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if lender trusts a specific attestation
         * @summary Evaluate attestation trust
         * @param {string} attestationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateAttestationTrust(attestationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrustEvaluationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateAttestationTrust(attestationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttestationApi.evaluateAttestationTrust']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get attestations for an application (lender only)
         * @summary Get attestations for application
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttestations(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttestationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttestations(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttestationApi.getAttestations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of supported KYC providers
         * @summary Get supported KYC providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKYCProviders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KYCProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKYCProviders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttestationApi.getKYCProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get KYC verification status for an application (neobank only)
         * @summary Get KYC status
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKYCStatus(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KYCStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKYCStatus(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttestationApi.getKYCStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get lender\'s current trust settings for all providers
         * @summary Get lender trust settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLenderTrustSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrustSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLenderTrustSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttestationApi.getLenderTrustSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SDX access token for proof retrieval (if lender trusts attestation)
         * @summary Get proof access token
         * @param {string} attestationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProofAccessToken(attestationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProofAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProofAccessToken(attestationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttestationApi.getProofAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiate KYC verification for an application (neobank only)
         * @summary Initiate KYC verification
         * @param {string} applicationId Unique identifier for the application
         * @param {InitiateKYCRequest} initiateKYCRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateKYC(applicationId: string, initiateKYCRequest: InitiateKYCRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KYCInitiateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateKYC(applicationId, initiateKYCRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttestationApi.initiateKYC']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Webhook endpoint for KYC providers to post results
         * @summary KYC provider webhook
         * @param {string} provider 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kycProviderWebhook(provider: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookAckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kycProviderWebhook(provider, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttestationApi.kycProviderWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Store KYC attestation for an application (KYC provider endpoint)
         * @summary Store attestation
         * @param {string} applicationId Unique identifier for the application
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeAttestation(applicationId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeAttestation(applicationId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttestationApi.storeAttestation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AttestationApi - factory interface
 * @export
 */
export const AttestationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttestationApiFp(configuration)
    return {
        /**
         * Configure lender\'s trust settings for a KYC provider
         * @summary Configure lender trust settings
         * @param {AttestationApiConfigureLenderTrustRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureLenderTrust(requestParameters: AttestationApiConfigureLenderTrustRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrustSettingsUpdateResponse> {
            return localVarFp.configureLenderTrust(requestParameters.providerCode, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if lender trusts a specific attestation
         * @summary Evaluate attestation trust
         * @param {AttestationApiEvaluateAttestationTrustRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateAttestationTrust(requestParameters: AttestationApiEvaluateAttestationTrustRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrustEvaluationResponse> {
            return localVarFp.evaluateAttestationTrust(requestParameters.attestationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get attestations for an application (lender only)
         * @summary Get attestations for application
         * @param {AttestationApiGetAttestationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttestations(requestParameters: AttestationApiGetAttestationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AttestationsResponse> {
            return localVarFp.getAttestations(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of supported KYC providers
         * @summary Get supported KYC providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKYCProviders(options?: RawAxiosRequestConfig): AxiosPromise<KYCProvidersResponse> {
            return localVarFp.getKYCProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * Get KYC verification status for an application (neobank only)
         * @summary Get KYC status
         * @param {AttestationApiGetKYCStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKYCStatus(requestParameters: AttestationApiGetKYCStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<KYCStatusResponse> {
            return localVarFp.getKYCStatus(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get lender\'s current trust settings for all providers
         * @summary Get lender trust settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLenderTrustSettings(options?: RawAxiosRequestConfig): AxiosPromise<TrustSettingsResponse> {
            return localVarFp.getLenderTrustSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Get SDX access token for proof retrieval (if lender trusts attestation)
         * @summary Get proof access token
         * @param {AttestationApiGetProofAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProofAccessToken(requestParameters: AttestationApiGetProofAccessTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProofAccessTokenResponse> {
            return localVarFp.getProofAccessToken(requestParameters.attestationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate KYC verification for an application (neobank only)
         * @summary Initiate KYC verification
         * @param {AttestationApiInitiateKYCRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateKYC(requestParameters: AttestationApiInitiateKYCRequest, options?: RawAxiosRequestConfig): AxiosPromise<KYCInitiateResponse> {
            return localVarFp.initiateKYC(requestParameters.applicationId, requestParameters.initiateKYCRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Webhook endpoint for KYC providers to post results
         * @summary KYC provider webhook
         * @param {AttestationApiKycProviderWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kycProviderWebhook(requestParameters: AttestationApiKycProviderWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookAckResponse> {
            return localVarFp.kycProviderWebhook(requestParameters.provider, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Store KYC attestation for an application (KYC provider endpoint)
         * @summary Store attestation
         * @param {AttestationApiStoreAttestationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAttestation(requestParameters: AttestationApiStoreAttestationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.storeAttestation(requestParameters.applicationId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttestationApi - interface
 * @export
 * @interface AttestationApi
 */
export interface AttestationApiInterface {
    /**
     * Configure lender\'s trust settings for a KYC provider
     * @summary Configure lender trust settings
     * @param {AttestationApiConfigureLenderTrustRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApiInterface
     */
    configureLenderTrust(requestParameters: AttestationApiConfigureLenderTrustRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrustSettingsUpdateResponse>;

    /**
     * Check if lender trusts a specific attestation
     * @summary Evaluate attestation trust
     * @param {AttestationApiEvaluateAttestationTrustRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApiInterface
     */
    evaluateAttestationTrust(requestParameters: AttestationApiEvaluateAttestationTrustRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrustEvaluationResponse>;

    /**
     * Get attestations for an application (lender only)
     * @summary Get attestations for application
     * @param {AttestationApiGetAttestationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApiInterface
     */
    getAttestations(requestParameters: AttestationApiGetAttestationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AttestationsResponse>;

    /**
     * Get list of supported KYC providers
     * @summary Get supported KYC providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApiInterface
     */
    getKYCProviders(options?: RawAxiosRequestConfig): AxiosPromise<KYCProvidersResponse>;

    /**
     * Get KYC verification status for an application (neobank only)
     * @summary Get KYC status
     * @param {AttestationApiGetKYCStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApiInterface
     */
    getKYCStatus(requestParameters: AttestationApiGetKYCStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<KYCStatusResponse>;

    /**
     * Get lender\'s current trust settings for all providers
     * @summary Get lender trust settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApiInterface
     */
    getLenderTrustSettings(options?: RawAxiosRequestConfig): AxiosPromise<TrustSettingsResponse>;

    /**
     * Get SDX access token for proof retrieval (if lender trusts attestation)
     * @summary Get proof access token
     * @param {AttestationApiGetProofAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApiInterface
     */
    getProofAccessToken(requestParameters: AttestationApiGetProofAccessTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProofAccessTokenResponse>;

    /**
     * Initiate KYC verification for an application (neobank only)
     * @summary Initiate KYC verification
     * @param {AttestationApiInitiateKYCRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApiInterface
     */
    initiateKYC(requestParameters: AttestationApiInitiateKYCRequest, options?: RawAxiosRequestConfig): AxiosPromise<KYCInitiateResponse>;

    /**
     * Webhook endpoint for KYC providers to post results
     * @summary KYC provider webhook
     * @param {AttestationApiKycProviderWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApiInterface
     */
    kycProviderWebhook(requestParameters: AttestationApiKycProviderWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookAckResponse>;

    /**
     * Store KYC attestation for an application (KYC provider endpoint)
     * @summary Store attestation
     * @param {AttestationApiStoreAttestationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApiInterface
     */
    storeAttestation(requestParameters: AttestationApiStoreAttestationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for configureLenderTrust operation in AttestationApi.
 * @export
 * @interface AttestationApiConfigureLenderTrustRequest
 */
export interface AttestationApiConfigureLenderTrustRequest {
    /**
     * 
     * @type {string}
     * @memberof AttestationApiConfigureLenderTrust
     */
    readonly providerCode: string

    /**
     * 
     * @type {object}
     * @memberof AttestationApiConfigureLenderTrust
     */
    readonly body: object
}

/**
 * Request parameters for evaluateAttestationTrust operation in AttestationApi.
 * @export
 * @interface AttestationApiEvaluateAttestationTrustRequest
 */
export interface AttestationApiEvaluateAttestationTrustRequest {
    /**
     * 
     * @type {string}
     * @memberof AttestationApiEvaluateAttestationTrust
     */
    readonly attestationId: string
}

/**
 * Request parameters for getAttestations operation in AttestationApi.
 * @export
 * @interface AttestationApiGetAttestationsRequest
 */
export interface AttestationApiGetAttestationsRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof AttestationApiGetAttestations
     */
    readonly applicationId: string
}

/**
 * Request parameters for getKYCStatus operation in AttestationApi.
 * @export
 * @interface AttestationApiGetKYCStatusRequest
 */
export interface AttestationApiGetKYCStatusRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof AttestationApiGetKYCStatus
     */
    readonly applicationId: string
}

/**
 * Request parameters for getProofAccessToken operation in AttestationApi.
 * @export
 * @interface AttestationApiGetProofAccessTokenRequest
 */
export interface AttestationApiGetProofAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof AttestationApiGetProofAccessToken
     */
    readonly attestationId: string
}

/**
 * Request parameters for initiateKYC operation in AttestationApi.
 * @export
 * @interface AttestationApiInitiateKYCRequest
 */
export interface AttestationApiInitiateKYCRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof AttestationApiInitiateKYC
     */
    readonly applicationId: string

    /**
     * 
     * @type {InitiateKYCRequest}
     * @memberof AttestationApiInitiateKYC
     */
    readonly initiateKYCRequest: InitiateKYCRequest
}

/**
 * Request parameters for kycProviderWebhook operation in AttestationApi.
 * @export
 * @interface AttestationApiKycProviderWebhookRequest
 */
export interface AttestationApiKycProviderWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof AttestationApiKycProviderWebhook
     */
    readonly provider: string

    /**
     * 
     * @type {object}
     * @memberof AttestationApiKycProviderWebhook
     */
    readonly body: object
}

/**
 * Request parameters for storeAttestation operation in AttestationApi.
 * @export
 * @interface AttestationApiStoreAttestationRequest
 */
export interface AttestationApiStoreAttestationRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof AttestationApiStoreAttestation
     */
    readonly applicationId: string

    /**
     * 
     * @type {object}
     * @memberof AttestationApiStoreAttestation
     */
    readonly body: object
}

/**
 * AttestationApi - object-oriented interface
 * @export
 * @class AttestationApi
 * @extends {BaseAPI}
 */
export class AttestationApi extends BaseAPI implements AttestationApiInterface {
    /**
     * Configure lender\'s trust settings for a KYC provider
     * @summary Configure lender trust settings
     * @param {AttestationApiConfigureLenderTrustRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApi
     */
    public configureLenderTrust(requestParameters: AttestationApiConfigureLenderTrustRequest, options?: RawAxiosRequestConfig) {
        return AttestationApiFp(this.configuration).configureLenderTrust(requestParameters.providerCode, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if lender trusts a specific attestation
     * @summary Evaluate attestation trust
     * @param {AttestationApiEvaluateAttestationTrustRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApi
     */
    public evaluateAttestationTrust(requestParameters: AttestationApiEvaluateAttestationTrustRequest, options?: RawAxiosRequestConfig) {
        return AttestationApiFp(this.configuration).evaluateAttestationTrust(requestParameters.attestationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get attestations for an application (lender only)
     * @summary Get attestations for application
     * @param {AttestationApiGetAttestationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApi
     */
    public getAttestations(requestParameters: AttestationApiGetAttestationsRequest, options?: RawAxiosRequestConfig) {
        return AttestationApiFp(this.configuration).getAttestations(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of supported KYC providers
     * @summary Get supported KYC providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApi
     */
    public getKYCProviders(options?: RawAxiosRequestConfig) {
        return AttestationApiFp(this.configuration).getKYCProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get KYC verification status for an application (neobank only)
     * @summary Get KYC status
     * @param {AttestationApiGetKYCStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApi
     */
    public getKYCStatus(requestParameters: AttestationApiGetKYCStatusRequest, options?: RawAxiosRequestConfig) {
        return AttestationApiFp(this.configuration).getKYCStatus(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get lender\'s current trust settings for all providers
     * @summary Get lender trust settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApi
     */
    public getLenderTrustSettings(options?: RawAxiosRequestConfig) {
        return AttestationApiFp(this.configuration).getLenderTrustSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SDX access token for proof retrieval (if lender trusts attestation)
     * @summary Get proof access token
     * @param {AttestationApiGetProofAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApi
     */
    public getProofAccessToken(requestParameters: AttestationApiGetProofAccessTokenRequest, options?: RawAxiosRequestConfig) {
        return AttestationApiFp(this.configuration).getProofAccessToken(requestParameters.attestationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate KYC verification for an application (neobank only)
     * @summary Initiate KYC verification
     * @param {AttestationApiInitiateKYCRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApi
     */
    public initiateKYC(requestParameters: AttestationApiInitiateKYCRequest, options?: RawAxiosRequestConfig) {
        return AttestationApiFp(this.configuration).initiateKYC(requestParameters.applicationId, requestParameters.initiateKYCRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Webhook endpoint for KYC providers to post results
     * @summary KYC provider webhook
     * @param {AttestationApiKycProviderWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApi
     */
    public kycProviderWebhook(requestParameters: AttestationApiKycProviderWebhookRequest, options?: RawAxiosRequestConfig) {
        return AttestationApiFp(this.configuration).kycProviderWebhook(requestParameters.provider, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Store KYC attestation for an application (KYC provider endpoint)
     * @summary Store attestation
     * @param {AttestationApiStoreAttestationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttestationApi
     */
    public storeAttestation(requestParameters: AttestationApiStoreAttestationRequest, options?: RawAxiosRequestConfig) {
        return AttestationApiFp(this.configuration).storeAttestation(requestParameters.applicationId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntityDiscoveryApi - axios parameter creator
 * @export
 */
export const EntityDiscoveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Batch retrieve public keys for multiple lenders (bootstrap)
         * @summary Batch get lender public keys
         * @param {BatchGetLenderPublicKeysRequest} batchGetLenderPublicKeysRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetLenderPublicKeys: async (batchGetLenderPublicKeysRequest: BatchGetLenderPublicKeysRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchGetLenderPublicKeysRequest' is not null or undefined
            assertParamExists('batchGetLenderPublicKeys', 'batchGetLenderPublicKeysRequest', batchGetLenderPublicKeysRequest)
            const localVarPath = `/lenders/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchGetLenderPublicKeysRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Batch retrieve public keys for multiple neobanks (lender-only bootstrap)
         * @summary Batch get neobank public keys
         * @param {BatchGetNeobankPublicKeysRequest} batchGetNeobankPublicKeysRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetNeobankPublicKeys: async (batchGetNeobankPublicKeysRequest: BatchGetNeobankPublicKeysRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchGetNeobankPublicKeysRequest' is not null or undefined
            assertParamExists('batchGetNeobankPublicKeys', 'batchGetNeobankPublicKeysRequest', batchGetNeobankPublicKeysRequest)
            const localVarPath = `/neobanks/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchGetNeobankPublicKeysRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a specific lender
         * @summary Get lender details
         * @param {string} lenderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLenderDetails: async (lenderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lenderId' is not null or undefined
            assertParamExists('getLenderDetails', 'lenderId', lenderId)
            const localVarPath = `/lenders/{lenderId}`
                .replace(`{${"lenderId"}}`, encodeURIComponent(String(lenderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get encryption public key for a specific lender
         * @summary Get lender public key
         * @param {string} lenderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLenderPublicKey: async (lenderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lenderId' is not null or undefined
            assertParamExists('getLenderPublicKey', 'lenderId', lenderId)
            const localVarPath = `/lenders/{lenderId}/public-key`
                .replace(`{${"lenderId"}}`, encodeURIComponent(String(lenderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a specific neobank (lender-only)
         * @summary Get neobank details
         * @param {string} neobankId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNeobankDetails: async (neobankId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'neobankId' is not null or undefined
            assertParamExists('getNeobankDetails', 'neobankId', neobankId)
            const localVarPath = `/neobanks/{neobankId}`
                .replace(`{${"neobankId"}}`, encodeURIComponent(String(neobankId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get encryption public key for a specific neobank (lender-only)
         * @summary Get neobank public key
         * @param {string} neobankId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNeobankPublicKey: async (neobankId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'neobankId' is not null or undefined
            assertParamExists('getNeobankPublicKey', 'neobankId', neobankId)
            const localVarPath = `/neobanks/{neobankId}/public-key`
                .replace(`{${"neobankId"}}`, encodeURIComponent(String(neobankId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all active lenders (optionally filtered by product type)
         * @summary List lenders
         * @param {string} [productType] 
         * @param {string} [stateCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLenders: async (productType?: string, stateCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lenders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (productType !== undefined) {
                localVarQueryParameter['productType'] = productType;
            }

            if (stateCode !== undefined) {
                localVarQueryParameter['stateCode'] = stateCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all active neobanks (lender-only endpoint)
         * @summary List neobanks
         * @param {string} [productType] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNeobanksForLenders: async (productType?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/neobanks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (productType !== undefined) {
                localVarQueryParameter['productType'] = productType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityDiscoveryApi - functional programming interface
 * @export
 */
export const EntityDiscoveryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityDiscoveryApiAxiosParamCreator(configuration)
    return {
        /**
         * Batch retrieve public keys for multiple lenders (bootstrap)
         * @summary Batch get lender public keys
         * @param {BatchGetLenderPublicKeysRequest} batchGetLenderPublicKeysRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchGetLenderPublicKeys(batchGetLenderPublicKeysRequest: BatchGetLenderPublicKeysRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchLenderKeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchGetLenderPublicKeys(batchGetLenderPublicKeysRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityDiscoveryApi.batchGetLenderPublicKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Batch retrieve public keys for multiple neobanks (lender-only bootstrap)
         * @summary Batch get neobank public keys
         * @param {BatchGetNeobankPublicKeysRequest} batchGetNeobankPublicKeysRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchGetNeobankPublicKeys(batchGetNeobankPublicKeysRequest: BatchGetNeobankPublicKeysRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchNeobankKeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchGetNeobankPublicKeys(batchGetNeobankPublicKeysRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityDiscoveryApi.batchGetNeobankPublicKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get detailed information about a specific lender
         * @summary Get lender details
         * @param {string} lenderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLenderDetails(lenderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LenderDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLenderDetails(lenderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityDiscoveryApi.getLenderDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get encryption public key for a specific lender
         * @summary Get lender public key
         * @param {string} lenderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLenderPublicKey(lenderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LenderPublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLenderPublicKey(lenderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityDiscoveryApi.getLenderPublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get detailed information about a specific neobank (lender-only)
         * @summary Get neobank details
         * @param {string} neobankId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNeobankDetails(neobankId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NeobankDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNeobankDetails(neobankId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityDiscoveryApi.getNeobankDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get encryption public key for a specific neobank (lender-only)
         * @summary Get neobank public key
         * @param {string} neobankId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNeobankPublicKey(neobankId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NeobankPublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNeobankPublicKey(neobankId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityDiscoveryApi.getNeobankPublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all active lenders (optionally filtered by product type)
         * @summary List lenders
         * @param {string} [productType] 
         * @param {string} [stateCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLenders(productType?: string, stateCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LenderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLenders(productType, stateCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityDiscoveryApi.listLenders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all active neobanks (lender-only endpoint)
         * @summary List neobanks
         * @param {string} [productType] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNeobanksForLenders(productType?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NeobankListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNeobanksForLenders(productType, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityDiscoveryApi.listNeobanksForLenders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EntityDiscoveryApi - factory interface
 * @export
 */
export const EntityDiscoveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityDiscoveryApiFp(configuration)
    return {
        /**
         * Batch retrieve public keys for multiple lenders (bootstrap)
         * @summary Batch get lender public keys
         * @param {EntityDiscoveryApiBatchGetLenderPublicKeysRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetLenderPublicKeys(requestParameters: EntityDiscoveryApiBatchGetLenderPublicKeysRequest, options?: RawAxiosRequestConfig): AxiosPromise<BatchLenderKeysResponse> {
            return localVarFp.batchGetLenderPublicKeys(requestParameters.batchGetLenderPublicKeysRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Batch retrieve public keys for multiple neobanks (lender-only bootstrap)
         * @summary Batch get neobank public keys
         * @param {EntityDiscoveryApiBatchGetNeobankPublicKeysRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetNeobankPublicKeys(requestParameters: EntityDiscoveryApiBatchGetNeobankPublicKeysRequest, options?: RawAxiosRequestConfig): AxiosPromise<BatchNeobankKeysResponse> {
            return localVarFp.batchGetNeobankPublicKeys(requestParameters.batchGetNeobankPublicKeysRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a specific lender
         * @summary Get lender details
         * @param {EntityDiscoveryApiGetLenderDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLenderDetails(requestParameters: EntityDiscoveryApiGetLenderDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<LenderDetailResponse> {
            return localVarFp.getLenderDetails(requestParameters.lenderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get encryption public key for a specific lender
         * @summary Get lender public key
         * @param {EntityDiscoveryApiGetLenderPublicKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLenderPublicKey(requestParameters: EntityDiscoveryApiGetLenderPublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<LenderPublicKeyResponse> {
            return localVarFp.getLenderPublicKey(requestParameters.lenderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a specific neobank (lender-only)
         * @summary Get neobank details
         * @param {EntityDiscoveryApiGetNeobankDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNeobankDetails(requestParameters: EntityDiscoveryApiGetNeobankDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<NeobankDetailResponse> {
            return localVarFp.getNeobankDetails(requestParameters.neobankId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get encryption public key for a specific neobank (lender-only)
         * @summary Get neobank public key
         * @param {EntityDiscoveryApiGetNeobankPublicKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNeobankPublicKey(requestParameters: EntityDiscoveryApiGetNeobankPublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<NeobankPublicKeyResponse> {
            return localVarFp.getNeobankPublicKey(requestParameters.neobankId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all active lenders (optionally filtered by product type)
         * @summary List lenders
         * @param {EntityDiscoveryApiListLendersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLenders(requestParameters: EntityDiscoveryApiListLendersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<LenderListResponse> {
            return localVarFp.listLenders(requestParameters.productType, requestParameters.stateCode, options).then((request) => request(axios, basePath));
        },
        /**
         * List all active neobanks (lender-only endpoint)
         * @summary List neobanks
         * @param {EntityDiscoveryApiListNeobanksForLendersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNeobanksForLenders(requestParameters: EntityDiscoveryApiListNeobanksForLendersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<NeobankListResponse> {
            return localVarFp.listNeobanksForLenders(requestParameters.productType, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityDiscoveryApi - interface
 * @export
 * @interface EntityDiscoveryApi
 */
export interface EntityDiscoveryApiInterface {
    /**
     * Batch retrieve public keys for multiple lenders (bootstrap)
     * @summary Batch get lender public keys
     * @param {EntityDiscoveryApiBatchGetLenderPublicKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApiInterface
     */
    batchGetLenderPublicKeys(requestParameters: EntityDiscoveryApiBatchGetLenderPublicKeysRequest, options?: RawAxiosRequestConfig): AxiosPromise<BatchLenderKeysResponse>;

    /**
     * Batch retrieve public keys for multiple neobanks (lender-only bootstrap)
     * @summary Batch get neobank public keys
     * @param {EntityDiscoveryApiBatchGetNeobankPublicKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApiInterface
     */
    batchGetNeobankPublicKeys(requestParameters: EntityDiscoveryApiBatchGetNeobankPublicKeysRequest, options?: RawAxiosRequestConfig): AxiosPromise<BatchNeobankKeysResponse>;

    /**
     * Get detailed information about a specific lender
     * @summary Get lender details
     * @param {EntityDiscoveryApiGetLenderDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApiInterface
     */
    getLenderDetails(requestParameters: EntityDiscoveryApiGetLenderDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<LenderDetailResponse>;

    /**
     * Get encryption public key for a specific lender
     * @summary Get lender public key
     * @param {EntityDiscoveryApiGetLenderPublicKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApiInterface
     */
    getLenderPublicKey(requestParameters: EntityDiscoveryApiGetLenderPublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<LenderPublicKeyResponse>;

    /**
     * Get detailed information about a specific neobank (lender-only)
     * @summary Get neobank details
     * @param {EntityDiscoveryApiGetNeobankDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApiInterface
     */
    getNeobankDetails(requestParameters: EntityDiscoveryApiGetNeobankDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<NeobankDetailResponse>;

    /**
     * Get encryption public key for a specific neobank (lender-only)
     * @summary Get neobank public key
     * @param {EntityDiscoveryApiGetNeobankPublicKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApiInterface
     */
    getNeobankPublicKey(requestParameters: EntityDiscoveryApiGetNeobankPublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<NeobankPublicKeyResponse>;

    /**
     * List all active lenders (optionally filtered by product type)
     * @summary List lenders
     * @param {EntityDiscoveryApiListLendersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApiInterface
     */
    listLenders(requestParameters?: EntityDiscoveryApiListLendersRequest, options?: RawAxiosRequestConfig): AxiosPromise<LenderListResponse>;

    /**
     * List all active neobanks (lender-only endpoint)
     * @summary List neobanks
     * @param {EntityDiscoveryApiListNeobanksForLendersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApiInterface
     */
    listNeobanksForLenders(requestParameters?: EntityDiscoveryApiListNeobanksForLendersRequest, options?: RawAxiosRequestConfig): AxiosPromise<NeobankListResponse>;

}

/**
 * Request parameters for batchGetLenderPublicKeys operation in EntityDiscoveryApi.
 * @export
 * @interface EntityDiscoveryApiBatchGetLenderPublicKeysRequest
 */
export interface EntityDiscoveryApiBatchGetLenderPublicKeysRequest {
    /**
     * 
     * @type {BatchGetLenderPublicKeysRequest}
     * @memberof EntityDiscoveryApiBatchGetLenderPublicKeys
     */
    readonly batchGetLenderPublicKeysRequest: BatchGetLenderPublicKeysRequest
}

/**
 * Request parameters for batchGetNeobankPublicKeys operation in EntityDiscoveryApi.
 * @export
 * @interface EntityDiscoveryApiBatchGetNeobankPublicKeysRequest
 */
export interface EntityDiscoveryApiBatchGetNeobankPublicKeysRequest {
    /**
     * 
     * @type {BatchGetNeobankPublicKeysRequest}
     * @memberof EntityDiscoveryApiBatchGetNeobankPublicKeys
     */
    readonly batchGetNeobankPublicKeysRequest: BatchGetNeobankPublicKeysRequest
}

/**
 * Request parameters for getLenderDetails operation in EntityDiscoveryApi.
 * @export
 * @interface EntityDiscoveryApiGetLenderDetailsRequest
 */
export interface EntityDiscoveryApiGetLenderDetailsRequest {
    /**
     * 
     * @type {string}
     * @memberof EntityDiscoveryApiGetLenderDetails
     */
    readonly lenderId: string
}

/**
 * Request parameters for getLenderPublicKey operation in EntityDiscoveryApi.
 * @export
 * @interface EntityDiscoveryApiGetLenderPublicKeyRequest
 */
export interface EntityDiscoveryApiGetLenderPublicKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof EntityDiscoveryApiGetLenderPublicKey
     */
    readonly lenderId: string
}

/**
 * Request parameters for getNeobankDetails operation in EntityDiscoveryApi.
 * @export
 * @interface EntityDiscoveryApiGetNeobankDetailsRequest
 */
export interface EntityDiscoveryApiGetNeobankDetailsRequest {
    /**
     * 
     * @type {string}
     * @memberof EntityDiscoveryApiGetNeobankDetails
     */
    readonly neobankId: string
}

/**
 * Request parameters for getNeobankPublicKey operation in EntityDiscoveryApi.
 * @export
 * @interface EntityDiscoveryApiGetNeobankPublicKeyRequest
 */
export interface EntityDiscoveryApiGetNeobankPublicKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof EntityDiscoveryApiGetNeobankPublicKey
     */
    readonly neobankId: string
}

/**
 * Request parameters for listLenders operation in EntityDiscoveryApi.
 * @export
 * @interface EntityDiscoveryApiListLendersRequest
 */
export interface EntityDiscoveryApiListLendersRequest {
    /**
     * 
     * @type {string}
     * @memberof EntityDiscoveryApiListLenders
     */
    readonly productType?: string

    /**
     * 
     * @type {string}
     * @memberof EntityDiscoveryApiListLenders
     */
    readonly stateCode?: string
}

/**
 * Request parameters for listNeobanksForLenders operation in EntityDiscoveryApi.
 * @export
 * @interface EntityDiscoveryApiListNeobanksForLendersRequest
 */
export interface EntityDiscoveryApiListNeobanksForLendersRequest {
    /**
     * 
     * @type {string}
     * @memberof EntityDiscoveryApiListNeobanksForLenders
     */
    readonly productType?: string

    /**
     * 
     * @type {number}
     * @memberof EntityDiscoveryApiListNeobanksForLenders
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof EntityDiscoveryApiListNeobanksForLenders
     */
    readonly offset?: number
}

/**
 * EntityDiscoveryApi - object-oriented interface
 * @export
 * @class EntityDiscoveryApi
 * @extends {BaseAPI}
 */
export class EntityDiscoveryApi extends BaseAPI implements EntityDiscoveryApiInterface {
    /**
     * Batch retrieve public keys for multiple lenders (bootstrap)
     * @summary Batch get lender public keys
     * @param {EntityDiscoveryApiBatchGetLenderPublicKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApi
     */
    public batchGetLenderPublicKeys(requestParameters: EntityDiscoveryApiBatchGetLenderPublicKeysRequest, options?: RawAxiosRequestConfig) {
        return EntityDiscoveryApiFp(this.configuration).batchGetLenderPublicKeys(requestParameters.batchGetLenderPublicKeysRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Batch retrieve public keys for multiple neobanks (lender-only bootstrap)
     * @summary Batch get neobank public keys
     * @param {EntityDiscoveryApiBatchGetNeobankPublicKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApi
     */
    public batchGetNeobankPublicKeys(requestParameters: EntityDiscoveryApiBatchGetNeobankPublicKeysRequest, options?: RawAxiosRequestConfig) {
        return EntityDiscoveryApiFp(this.configuration).batchGetNeobankPublicKeys(requestParameters.batchGetNeobankPublicKeysRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a specific lender
     * @summary Get lender details
     * @param {EntityDiscoveryApiGetLenderDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApi
     */
    public getLenderDetails(requestParameters: EntityDiscoveryApiGetLenderDetailsRequest, options?: RawAxiosRequestConfig) {
        return EntityDiscoveryApiFp(this.configuration).getLenderDetails(requestParameters.lenderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get encryption public key for a specific lender
     * @summary Get lender public key
     * @param {EntityDiscoveryApiGetLenderPublicKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApi
     */
    public getLenderPublicKey(requestParameters: EntityDiscoveryApiGetLenderPublicKeyRequest, options?: RawAxiosRequestConfig) {
        return EntityDiscoveryApiFp(this.configuration).getLenderPublicKey(requestParameters.lenderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a specific neobank (lender-only)
     * @summary Get neobank details
     * @param {EntityDiscoveryApiGetNeobankDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApi
     */
    public getNeobankDetails(requestParameters: EntityDiscoveryApiGetNeobankDetailsRequest, options?: RawAxiosRequestConfig) {
        return EntityDiscoveryApiFp(this.configuration).getNeobankDetails(requestParameters.neobankId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get encryption public key for a specific neobank (lender-only)
     * @summary Get neobank public key
     * @param {EntityDiscoveryApiGetNeobankPublicKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApi
     */
    public getNeobankPublicKey(requestParameters: EntityDiscoveryApiGetNeobankPublicKeyRequest, options?: RawAxiosRequestConfig) {
        return EntityDiscoveryApiFp(this.configuration).getNeobankPublicKey(requestParameters.neobankId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all active lenders (optionally filtered by product type)
     * @summary List lenders
     * @param {EntityDiscoveryApiListLendersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApi
     */
    public listLenders(requestParameters: EntityDiscoveryApiListLendersRequest = {}, options?: RawAxiosRequestConfig) {
        return EntityDiscoveryApiFp(this.configuration).listLenders(requestParameters.productType, requestParameters.stateCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all active neobanks (lender-only endpoint)
     * @summary List neobanks
     * @param {EntityDiscoveryApiListNeobanksForLendersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityDiscoveryApi
     */
    public listNeobanksForLenders(requestParameters: EntityDiscoveryApiListNeobanksForLendersRequest = {}, options?: RawAxiosRequestConfig) {
        return EntityDiscoveryApiFp(this.configuration).listNeobanksForLenders(requestParameters.productType, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FundingApi - axios parameter creator
 * @export
 */
export const FundingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lender agrees to fund the loan. Triggers instant disbursement via Bridge if wallet balance is sufficient. Records lender consent with IP address and user agent for audit trail. Lender-only endpoint. 
         * @summary Consent to funding
         * @param {string} fundingId Unique identifier for the funding request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentToFunding: async (fundingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingId' is not null or undefined
            assertParamExists('consentToFunding', 'fundingId', fundingId)
            const localVarPath = `/funding/{fundingId}/consent`
                .replace(`{${"fundingId"}}`, encodeURIComponent(String(fundingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lender declines to fund the loan. This cancels the funding request and notifies relevant parties. Lender-only endpoint. 
         * @summary Decline funding
         * @param {string} fundingId Unique identifier for the funding request
         * @param {DeclineFundingRequest} [declineFundingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineFunding: async (fundingId: string, declineFundingRequest?: DeclineFundingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingId' is not null or undefined
            assertParamExists('declineFunding', 'fundingId', fundingId)
            const localVarPath = `/funding/{fundingId}/decline`
                .replace(`{${"fundingId"}}`, encodeURIComponent(String(fundingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(declineFundingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a specific funding request. Both lenders and neobanks can access their own fundings. 
         * @summary Get funding details
         * @param {string} fundingId Unique identifier for the funding request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingById: async (fundingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingId' is not null or undefined
            assertParamExists('getFundingById', 'fundingId', fundingId)
            const localVarPath = `/funding/{fundingId}`
                .replace(`{${"fundingId"}}`, encodeURIComponent(String(fundingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all funding requests awaiting lender consent. Returns fundings that are ready for lender review and approval. Lender-only endpoint. 
         * @summary Get pending funding requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingFundings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/funding/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FundingApi - functional programming interface
 * @export
 */
export const FundingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FundingApiAxiosParamCreator(configuration)
    return {
        /**
         * Lender agrees to fund the loan. Triggers instant disbursement via Bridge if wallet balance is sufficient. Records lender consent with IP address and user agent for audit trail. Lender-only endpoint. 
         * @summary Consent to funding
         * @param {string} fundingId Unique identifier for the funding request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consentToFunding(fundingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsentToFunding200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consentToFunding(fundingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingApi.consentToFunding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lender declines to fund the loan. This cancels the funding request and notifies relevant parties. Lender-only endpoint. 
         * @summary Decline funding
         * @param {string} fundingId Unique identifier for the funding request
         * @param {DeclineFundingRequest} [declineFundingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineFunding(fundingId: string, declineFundingRequest?: DeclineFundingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclineFunding200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineFunding(fundingId, declineFundingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingApi.declineFunding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get detailed information about a specific funding request. Both lenders and neobanks can access their own fundings. 
         * @summary Get funding details
         * @param {string} fundingId Unique identifier for the funding request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingById(fundingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFundingById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingById(fundingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingApi.getFundingById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all funding requests awaiting lender consent. Returns fundings that are ready for lender review and approval. Lender-only endpoint. 
         * @summary Get pending funding requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingFundings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPendingFundings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingFundings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingApi.getPendingFundings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FundingApi - factory interface
 * @export
 */
export const FundingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FundingApiFp(configuration)
    return {
        /**
         * Lender agrees to fund the loan. Triggers instant disbursement via Bridge if wallet balance is sufficient. Records lender consent with IP address and user agent for audit trail. Lender-only endpoint. 
         * @summary Consent to funding
         * @param {FundingApiConsentToFundingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consentToFunding(requestParameters: FundingApiConsentToFundingRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConsentToFunding200Response> {
            return localVarFp.consentToFunding(requestParameters.fundingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lender declines to fund the loan. This cancels the funding request and notifies relevant parties. Lender-only endpoint. 
         * @summary Decline funding
         * @param {FundingApiDeclineFundingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineFunding(requestParameters: FundingApiDeclineFundingRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeclineFunding200Response> {
            return localVarFp.declineFunding(requestParameters.fundingId, requestParameters.declineFundingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a specific funding request. Both lenders and neobanks can access their own fundings. 
         * @summary Get funding details
         * @param {FundingApiGetFundingByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingById(requestParameters: FundingApiGetFundingByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetFundingById200Response> {
            return localVarFp.getFundingById(requestParameters.fundingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all funding requests awaiting lender consent. Returns fundings that are ready for lender review and approval. Lender-only endpoint. 
         * @summary Get pending funding requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingFundings(options?: RawAxiosRequestConfig): AxiosPromise<GetPendingFundings200Response> {
            return localVarFp.getPendingFundings(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FundingApi - interface
 * @export
 * @interface FundingApi
 */
export interface FundingApiInterface {
    /**
     * Lender agrees to fund the loan. Triggers instant disbursement via Bridge if wallet balance is sufficient. Records lender consent with IP address and user agent for audit trail. Lender-only endpoint. 
     * @summary Consent to funding
     * @param {FundingApiConsentToFundingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingApiInterface
     */
    consentToFunding(requestParameters: FundingApiConsentToFundingRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConsentToFunding200Response>;

    /**
     * Lender declines to fund the loan. This cancels the funding request and notifies relevant parties. Lender-only endpoint. 
     * @summary Decline funding
     * @param {FundingApiDeclineFundingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingApiInterface
     */
    declineFunding(requestParameters: FundingApiDeclineFundingRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeclineFunding200Response>;

    /**
     * Get detailed information about a specific funding request. Both lenders and neobanks can access their own fundings. 
     * @summary Get funding details
     * @param {FundingApiGetFundingByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingApiInterface
     */
    getFundingById(requestParameters: FundingApiGetFundingByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetFundingById200Response>;

    /**
     * Get all funding requests awaiting lender consent. Returns fundings that are ready for lender review and approval. Lender-only endpoint. 
     * @summary Get pending funding requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingApiInterface
     */
    getPendingFundings(options?: RawAxiosRequestConfig): AxiosPromise<GetPendingFundings200Response>;

}

/**
 * Request parameters for consentToFunding operation in FundingApi.
 * @export
 * @interface FundingApiConsentToFundingRequest
 */
export interface FundingApiConsentToFundingRequest {
    /**
     * Unique identifier for the funding request
     * @type {string}
     * @memberof FundingApiConsentToFunding
     */
    readonly fundingId: string
}

/**
 * Request parameters for declineFunding operation in FundingApi.
 * @export
 * @interface FundingApiDeclineFundingRequest
 */
export interface FundingApiDeclineFundingRequest {
    /**
     * Unique identifier for the funding request
     * @type {string}
     * @memberof FundingApiDeclineFunding
     */
    readonly fundingId: string

    /**
     * 
     * @type {DeclineFundingRequest}
     * @memberof FundingApiDeclineFunding
     */
    readonly declineFundingRequest?: DeclineFundingRequest
}

/**
 * Request parameters for getFundingById operation in FundingApi.
 * @export
 * @interface FundingApiGetFundingByIdRequest
 */
export interface FundingApiGetFundingByIdRequest {
    /**
     * Unique identifier for the funding request
     * @type {string}
     * @memberof FundingApiGetFundingById
     */
    readonly fundingId: string
}

/**
 * FundingApi - object-oriented interface
 * @export
 * @class FundingApi
 * @extends {BaseAPI}
 */
export class FundingApi extends BaseAPI implements FundingApiInterface {
    /**
     * Lender agrees to fund the loan. Triggers instant disbursement via Bridge if wallet balance is sufficient. Records lender consent with IP address and user agent for audit trail. Lender-only endpoint. 
     * @summary Consent to funding
     * @param {FundingApiConsentToFundingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingApi
     */
    public consentToFunding(requestParameters: FundingApiConsentToFundingRequest, options?: RawAxiosRequestConfig) {
        return FundingApiFp(this.configuration).consentToFunding(requestParameters.fundingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lender declines to fund the loan. This cancels the funding request and notifies relevant parties. Lender-only endpoint. 
     * @summary Decline funding
     * @param {FundingApiDeclineFundingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingApi
     */
    public declineFunding(requestParameters: FundingApiDeclineFundingRequest, options?: RawAxiosRequestConfig) {
        return FundingApiFp(this.configuration).declineFunding(requestParameters.fundingId, requestParameters.declineFundingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a specific funding request. Both lenders and neobanks can access their own fundings. 
     * @summary Get funding details
     * @param {FundingApiGetFundingByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingApi
     */
    public getFundingById(requestParameters: FundingApiGetFundingByIdRequest, options?: RawAxiosRequestConfig) {
        return FundingApiFp(this.configuration).getFundingById(requestParameters.fundingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all funding requests awaiting lender consent. Returns fundings that are ready for lender review and approval. Lender-only endpoint. 
     * @summary Get pending funding requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingApi
     */
    public getPendingFundings(options?: RawAxiosRequestConfig) {
        return FundingApiFp(this.configuration).getPendingFundings(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KeyManagementApi - axios parameter creator
 * @export
 */
export const KeyManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Emergency revocation of compromised key
         * @summary Revoke compromised key
         * @param {string} keyId 
         * @param {EmergencyRevokeKeyRequest} emergencyRevokeKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emergencyRevokeKey: async (keyId: string, emergencyRevokeKeyRequest: EmergencyRevokeKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('emergencyRevokeKey', 'keyId', keyId)
            // verify required parameter 'emergencyRevokeKeyRequest' is not null or undefined
            assertParamExists('emergencyRevokeKey', 'emergencyRevokeKeyRequest', emergencyRevokeKeyRequest)
            const localVarPath = `/keys/{keyId}/revoke`
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emergencyRevokeKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View key rotation history for audit purposes
         * @summary Get key rotation history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeyRotationHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keys/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rotate entity\'s public key with overlap period
         * @summary Rotate encryption key
         * @param {RotateEntityKeyRequest} rotateEntityKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateEntityKey: async (rotateEntityKeyRequest: RotateEntityKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rotateEntityKeyRequest' is not null or undefined
            assertParamExists('rotateEntityKey', 'rotateEntityKeyRequest', rotateEntityKeyRequest)
            const localVarPath = `/keys/rotate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rotateEntityKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeyManagementApi - functional programming interface
 * @export
 */
export const KeyManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeyManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Emergency revocation of compromised key
         * @summary Revoke compromised key
         * @param {string} keyId 
         * @param {EmergencyRevokeKeyRequest} emergencyRevokeKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emergencyRevokeKey(keyId: string, emergencyRevokeKeyRequest: EmergencyRevokeKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyRevokeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emergencyRevokeKey(keyId, emergencyRevokeKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeyManagementApi.emergencyRevokeKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * View key rotation history for audit purposes
         * @summary Get key rotation history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeyRotationHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeyRotationHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeyManagementApi.getKeyRotationHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rotate entity\'s public key with overlap period
         * @summary Rotate encryption key
         * @param {RotateEntityKeyRequest} rotateEntityKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rotateEntityKey(rotateEntityKeyRequest: RotateEntityKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyRotationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rotateEntityKey(rotateEntityKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeyManagementApi.rotateEntityKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KeyManagementApi - factory interface
 * @export
 */
export const KeyManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeyManagementApiFp(configuration)
    return {
        /**
         * Emergency revocation of compromised key
         * @summary Revoke compromised key
         * @param {KeyManagementApiEmergencyRevokeKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emergencyRevokeKey(requestParameters: KeyManagementApiEmergencyRevokeKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<KeyRevokeResponse> {
            return localVarFp.emergencyRevokeKey(requestParameters.keyId, requestParameters.emergencyRevokeKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * View key rotation history for audit purposes
         * @summary Get key rotation history
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeyRotationHistory(options?: RawAxiosRequestConfig): AxiosPromise<KeyHistoryResponse> {
            return localVarFp.getKeyRotationHistory(options).then((request) => request(axios, basePath));
        },
        /**
         * Rotate entity\'s public key with overlap period
         * @summary Rotate encryption key
         * @param {KeyManagementApiRotateEntityKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateEntityKey(requestParameters: KeyManagementApiRotateEntityKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<KeyRotationResponse> {
            return localVarFp.rotateEntityKey(requestParameters.rotateEntityKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KeyManagementApi - interface
 * @export
 * @interface KeyManagementApi
 */
export interface KeyManagementApiInterface {
    /**
     * Emergency revocation of compromised key
     * @summary Revoke compromised key
     * @param {KeyManagementApiEmergencyRevokeKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyManagementApiInterface
     */
    emergencyRevokeKey(requestParameters: KeyManagementApiEmergencyRevokeKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<KeyRevokeResponse>;

    /**
     * View key rotation history for audit purposes
     * @summary Get key rotation history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyManagementApiInterface
     */
    getKeyRotationHistory(options?: RawAxiosRequestConfig): AxiosPromise<KeyHistoryResponse>;

    /**
     * Rotate entity\'s public key with overlap period
     * @summary Rotate encryption key
     * @param {KeyManagementApiRotateEntityKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyManagementApiInterface
     */
    rotateEntityKey(requestParameters: KeyManagementApiRotateEntityKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<KeyRotationResponse>;

}

/**
 * Request parameters for emergencyRevokeKey operation in KeyManagementApi.
 * @export
 * @interface KeyManagementApiEmergencyRevokeKeyRequest
 */
export interface KeyManagementApiEmergencyRevokeKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof KeyManagementApiEmergencyRevokeKey
     */
    readonly keyId: string

    /**
     * 
     * @type {EmergencyRevokeKeyRequest}
     * @memberof KeyManagementApiEmergencyRevokeKey
     */
    readonly emergencyRevokeKeyRequest: EmergencyRevokeKeyRequest
}

/**
 * Request parameters for rotateEntityKey operation in KeyManagementApi.
 * @export
 * @interface KeyManagementApiRotateEntityKeyRequest
 */
export interface KeyManagementApiRotateEntityKeyRequest {
    /**
     * 
     * @type {RotateEntityKeyRequest}
     * @memberof KeyManagementApiRotateEntityKey
     */
    readonly rotateEntityKeyRequest: RotateEntityKeyRequest
}

/**
 * KeyManagementApi - object-oriented interface
 * @export
 * @class KeyManagementApi
 * @extends {BaseAPI}
 */
export class KeyManagementApi extends BaseAPI implements KeyManagementApiInterface {
    /**
     * Emergency revocation of compromised key
     * @summary Revoke compromised key
     * @param {KeyManagementApiEmergencyRevokeKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyManagementApi
     */
    public emergencyRevokeKey(requestParameters: KeyManagementApiEmergencyRevokeKeyRequest, options?: RawAxiosRequestConfig) {
        return KeyManagementApiFp(this.configuration).emergencyRevokeKey(requestParameters.keyId, requestParameters.emergencyRevokeKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View key rotation history for audit purposes
     * @summary Get key rotation history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyManagementApi
     */
    public getKeyRotationHistory(options?: RawAxiosRequestConfig) {
        return KeyManagementApiFp(this.configuration).getKeyRotationHistory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rotate entity\'s public key with overlap period
     * @summary Rotate encryption key
     * @param {KeyManagementApiRotateEntityKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyManagementApi
     */
    public rotateEntityKey(requestParameters: KeyManagementApiRotateEntityKeyRequest, options?: RawAxiosRequestConfig) {
        return KeyManagementApiFp(this.configuration).rotateEntityKey(requestParameters.rotateEntityKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LoansApi - axios parameter creator
 * @export
 */
export const LoansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Apply lender override to loan state (e.g., mark as defaulted). Lender-only endpoint. 
         * @summary Apply lender override
         * @param {string} loanId Unique identifier for the loan
         * @param {LoanStateOverrideRequest} loanStateOverrideRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyLenderOverride: async (loanId: string, loanStateOverrideRequest: LoanStateOverrideRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loanId' is not null or undefined
            assertParamExists('applyLenderOverride', 'loanId', loanId)
            // verify required parameter 'loanStateOverrideRequest' is not null or undefined
            assertParamExists('applyLenderOverride', 'loanStateOverrideRequest', loanStateOverrideRequest)
            const localVarPath = `/loans/{loanId}/state`
                .replace(`{${"loanId"}}`, encodeURIComponent(String(loanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loanStateOverrideRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed loan information. Both lenders and neobanks can access their own loans. 
         * @summary Get loan details
         * @param {string} loanId Unique identifier for the loan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoan: async (loanId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loanId' is not null or undefined
            assertParamExists('getLoan', 'loanId', loanId)
            const localVarPath = `/loans/{loanId}`
                .replace(`{${"loanId"}}`, encodeURIComponent(String(loanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get loan details by application ID. Convenience endpoint for neobanks to retrieve loan information including the repayment address (Bridge liquidation address). Neobank-only endpoint. 
         * @summary Get loan by application
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoanByApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getLoanByApplication', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/loan`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Bridge wallet and liquidation address details for a loan. Returns real-time wallet balance and liquidation address status. Lender-only endpoint. 
         * @summary Get loan wallet details
         * @param {string} loanId Unique identifier for the loan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoanWallet: async (loanId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loanId' is not null or undefined
            assertParamExists('getLoanWallet', 'loanId', loanId)
            const localVarPath = `/loans/{loanId}/wallet`
                .replace(`{${"loanId"}}`, encodeURIComponent(String(loanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get projected payment schedule based on current loan state. Both lenders and neobanks can access their own loans. 
         * @summary Get payment schedule
         * @param {string} loanId Unique identifier for the loan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentSchedule: async (loanId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loanId' is not null or undefined
            assertParamExists('getPaymentSchedule', 'loanId', loanId)
            const localVarPath = `/loans/{loanId}/schedule`
                .replace(`{${"loanId"}}`, encodeURIComponent(String(loanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List repayments for a loan with pagination and filtering. Both lenders and neobanks can access their own loans.  Use `source=bridge` (lender-only) to fetch live data directly from Bridge API instead of the local database. This shows raw liquidation address drains with summary information. 
         * @summary List loan repayments
         * @param {string} loanId Unique identifier for the loan
         * @param {RepaymentStatus} [status] Filter by repayment status
         * @param {number} [limit] Maximum number of results (default 50, max 100)
         * @param {number} [offset] Pagination offset
         * @param {ListLoanRepaymentsSourceEnum} [source] Data source for repayments. - &#x60;database&#x60; (default): Fetch from local database (includes principal/interest allocation) - &#x60;bridge&#x60;: Fetch live from Bridge API (lender-only, shows raw drain data) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoanRepayments: async (loanId: string, status?: RepaymentStatus, limit?: number, offset?: number, source?: ListLoanRepaymentsSourceEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loanId' is not null or undefined
            assertParamExists('listLoanRepayments', 'loanId', loanId)
            const localVarPath = `/loans/{loanId}/repayments`
                .replace(`{${"loanId"}}`, encodeURIComponent(String(loanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List loans for the authenticated entity with pagination and filtering.  **For Lenders:** Returns loans they funded. **For Neobanks:** Returns loans from applications they originated.  Neobanks can filter by `externalId` (their user reference) or `borrowerAddress` (wallet address) to efficiently retrieve loans for a specific borrower. 
         * @summary List loans
         * @param {LoanStatus} [status] Filter by loan status
         * @param {string} [externalId] Filter by application\&#39;s external reference ID (neobank-only). Exact match. Use this when you have your own user ID system. 
         * @param {string} [borrowerAddress] Filter by borrower\&#39;s wallet address (case-insensitive, neobank-only). Use this for wallet-first applications. 
         * @param {number} [limit] Maximum number of results (default 50, max 100)
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoans: async (status?: LoanStatus, externalId?: string, borrowerAddress?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/loans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['externalId'] = externalId;
            }

            if (borrowerAddress !== undefined) {
                localVarQueryParameter['borrowerAddress'] = borrowerAddress;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sweep balance from a loan\'s wallet to the master treasury wallet. Supports sweeping a specific amount or the full balance. Uses idempotency keys to prevent duplicate transfers. Lender-only endpoint. 
         * @summary Sweep loan wallet
         * @param {string} loanId Unique identifier for the loan
         * @param {LoanSweepRequest} [loanSweepRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sweepLoanWallet: async (loanId: string, loanSweepRequest?: LoanSweepRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loanId' is not null or undefined
            assertParamExists('sweepLoanWallet', 'loanId', loanId)
            const localVarPath = `/loans/{loanId}/sweep`
                .replace(`{${"loanId"}}`, encodeURIComponent(String(loanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loanSweepRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update loan terms for corrections after origination. Lender-only endpoint. 
         * @summary Update loan terms
         * @param {string} loanId Unique identifier for the loan
         * @param {LoanTermsUpdateRequest} loanTermsUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoanTerms: async (loanId: string, loanTermsUpdateRequest: LoanTermsUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loanId' is not null or undefined
            assertParamExists('updateLoanTerms', 'loanId', loanId)
            // verify required parameter 'loanTermsUpdateRequest' is not null or undefined
            assertParamExists('updateLoanTerms', 'loanTermsUpdateRequest', loanTermsUpdateRequest)
            const localVarPath = `/loans/{loanId}/terms`
                .replace(`{${"loanId"}}`, encodeURIComponent(String(loanId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loanTermsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoansApi - functional programming interface
 * @export
 */
export const LoansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoansApiAxiosParamCreator(configuration)
    return {
        /**
         * Apply lender override to loan state (e.g., mark as defaulted). Lender-only endpoint. 
         * @summary Apply lender override
         * @param {string} loanId Unique identifier for the loan
         * @param {LoanStateOverrideRequest} loanStateOverrideRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyLenderOverride(loanId: string, loanStateOverrideRequest: LoanStateOverrideRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyLenderOverride(loanId, loanStateOverrideRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoansApi.applyLenderOverride']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get detailed loan information. Both lenders and neobanks can access their own loans. 
         * @summary Get loan details
         * @param {string} loanId Unique identifier for the loan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoan(loanId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoan(loanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoansApi.getLoan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get loan details by application ID. Convenience endpoint for neobanks to retrieve loan information including the repayment address (Bridge liquidation address). Neobank-only endpoint. 
         * @summary Get loan by application
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoanByApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoanByApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoansApi.getLoanByApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Bridge wallet and liquidation address details for a loan. Returns real-time wallet balance and liquidation address status. Lender-only endpoint. 
         * @summary Get loan wallet details
         * @param {string} loanId Unique identifier for the loan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoanWallet(loanId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoanWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoanWallet(loanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoansApi.getLoanWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get projected payment schedule based on current loan state. Both lenders and neobanks can access their own loans. 
         * @summary Get payment schedule
         * @param {string} loanId Unique identifier for the loan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentSchedule(loanId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentSchedule(loanId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoansApi.getPaymentSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List repayments for a loan with pagination and filtering. Both lenders and neobanks can access their own loans.  Use `source=bridge` (lender-only) to fetch live data directly from Bridge API instead of the local database. This shows raw liquidation address drains with summary information. 
         * @summary List loan repayments
         * @param {string} loanId Unique identifier for the loan
         * @param {RepaymentStatus} [status] Filter by repayment status
         * @param {number} [limit] Maximum number of results (default 50, max 100)
         * @param {number} [offset] Pagination offset
         * @param {ListLoanRepaymentsSourceEnum} [source] Data source for repayments. - &#x60;database&#x60; (default): Fetch from local database (includes principal/interest allocation) - &#x60;bridge&#x60;: Fetch live from Bridge API (lender-only, shows raw drain data) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLoanRepayments(loanId: string, status?: RepaymentStatus, limit?: number, offset?: number, source?: ListLoanRepaymentsSourceEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListLoanRepayments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLoanRepayments(loanId, status, limit, offset, source, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoansApi.listLoanRepayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List loans for the authenticated entity with pagination and filtering.  **For Lenders:** Returns loans they funded. **For Neobanks:** Returns loans from applications they originated.  Neobanks can filter by `externalId` (their user reference) or `borrowerAddress` (wallet address) to efficiently retrieve loans for a specific borrower. 
         * @summary List loans
         * @param {LoanStatus} [status] Filter by loan status
         * @param {string} [externalId] Filter by application\&#39;s external reference ID (neobank-only). Exact match. Use this when you have your own user ID system. 
         * @param {string} [borrowerAddress] Filter by borrower\&#39;s wallet address (case-insensitive, neobank-only). Use this for wallet-first applications. 
         * @param {number} [limit] Maximum number of results (default 50, max 100)
         * @param {number} [offset] Pagination offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLoans(status?: LoanStatus, externalId?: string, borrowerAddress?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoanListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLoans(status, externalId, borrowerAddress, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoansApi.listLoans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sweep balance from a loan\'s wallet to the master treasury wallet. Supports sweeping a specific amount or the full balance. Uses idempotency keys to prevent duplicate transfers. Lender-only endpoint. 
         * @summary Sweep loan wallet
         * @param {string} loanId Unique identifier for the loan
         * @param {LoanSweepRequest} [loanSweepRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sweepLoanWallet(loanId: string, loanSweepRequest?: LoanSweepRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoanSweepResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sweepLoanWallet(loanId, loanSweepRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoansApi.sweepLoanWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update loan terms for corrections after origination. Lender-only endpoint. 
         * @summary Update loan terms
         * @param {string} loanId Unique identifier for the loan
         * @param {LoanTermsUpdateRequest} loanTermsUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoanTerms(loanId: string, loanTermsUpdateRequest: LoanTermsUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLoanTerms(loanId, loanTermsUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LoansApi.updateLoanTerms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LoansApi - factory interface
 * @export
 */
export const LoansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoansApiFp(configuration)
    return {
        /**
         * Apply lender override to loan state (e.g., mark as defaulted). Lender-only endpoint. 
         * @summary Apply lender override
         * @param {LoansApiApplyLenderOverrideRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyLenderOverride(requestParameters: LoansApiApplyLenderOverrideRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanResponse> {
            return localVarFp.applyLenderOverride(requestParameters.loanId, requestParameters.loanStateOverrideRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed loan information. Both lenders and neobanks can access their own loans. 
         * @summary Get loan details
         * @param {LoansApiGetLoanRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoan(requestParameters: LoansApiGetLoanRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanResponse> {
            return localVarFp.getLoan(requestParameters.loanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get loan details by application ID. Convenience endpoint for neobanks to retrieve loan information including the repayment address (Bridge liquidation address). Neobank-only endpoint. 
         * @summary Get loan by application
         * @param {LoansApiGetLoanByApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoanByApplication(requestParameters: LoansApiGetLoanByApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanResponse> {
            return localVarFp.getLoanByApplication(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Bridge wallet and liquidation address details for a loan. Returns real-time wallet balance and liquidation address status. Lender-only endpoint. 
         * @summary Get loan wallet details
         * @param {LoansApiGetLoanWalletRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoanWallet(requestParameters: LoansApiGetLoanWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanWalletResponse> {
            return localVarFp.getLoanWallet(requestParameters.loanId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get projected payment schedule based on current loan state. Both lenders and neobanks can access their own loans. 
         * @summary Get payment schedule
         * @param {LoansApiGetPaymentScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentSchedule(requestParameters: LoansApiGetPaymentScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentScheduleResponse> {
            return localVarFp.getPaymentSchedule(requestParameters.loanId, options).then((request) => request(axios, basePath));
        },
        /**
         * List repayments for a loan with pagination and filtering. Both lenders and neobanks can access their own loans.  Use `source=bridge` (lender-only) to fetch live data directly from Bridge API instead of the local database. This shows raw liquidation address drains with summary information. 
         * @summary List loan repayments
         * @param {LoansApiListLoanRepaymentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoanRepayments(requestParameters: LoansApiListLoanRepaymentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListLoanRepayments200Response> {
            return localVarFp.listLoanRepayments(requestParameters.loanId, requestParameters.status, requestParameters.limit, requestParameters.offset, requestParameters.source, options).then((request) => request(axios, basePath));
        },
        /**
         * List loans for the authenticated entity with pagination and filtering.  **For Lenders:** Returns loans they funded. **For Neobanks:** Returns loans from applications they originated.  Neobanks can filter by `externalId` (their user reference) or `borrowerAddress` (wallet address) to efficiently retrieve loans for a specific borrower. 
         * @summary List loans
         * @param {LoansApiListLoansRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLoans(requestParameters: LoansApiListLoansRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<LoanListResponse> {
            return localVarFp.listLoans(requestParameters.status, requestParameters.externalId, requestParameters.borrowerAddress, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Sweep balance from a loan\'s wallet to the master treasury wallet. Supports sweeping a specific amount or the full balance. Uses idempotency keys to prevent duplicate transfers. Lender-only endpoint. 
         * @summary Sweep loan wallet
         * @param {LoansApiSweepLoanWalletRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sweepLoanWallet(requestParameters: LoansApiSweepLoanWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanSweepResponse> {
            return localVarFp.sweepLoanWallet(requestParameters.loanId, requestParameters.loanSweepRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update loan terms for corrections after origination. Lender-only endpoint. 
         * @summary Update loan terms
         * @param {LoansApiUpdateLoanTermsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoanTerms(requestParameters: LoansApiUpdateLoanTermsRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanResponse> {
            return localVarFp.updateLoanTerms(requestParameters.loanId, requestParameters.loanTermsUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoansApi - interface
 * @export
 * @interface LoansApi
 */
export interface LoansApiInterface {
    /**
     * Apply lender override to loan state (e.g., mark as defaulted). Lender-only endpoint. 
     * @summary Apply lender override
     * @param {LoansApiApplyLenderOverrideRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApiInterface
     */
    applyLenderOverride(requestParameters: LoansApiApplyLenderOverrideRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanResponse>;

    /**
     * Get detailed loan information. Both lenders and neobanks can access their own loans. 
     * @summary Get loan details
     * @param {LoansApiGetLoanRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApiInterface
     */
    getLoan(requestParameters: LoansApiGetLoanRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanResponse>;

    /**
     * Get loan details by application ID. Convenience endpoint for neobanks to retrieve loan information including the repayment address (Bridge liquidation address). Neobank-only endpoint. 
     * @summary Get loan by application
     * @param {LoansApiGetLoanByApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApiInterface
     */
    getLoanByApplication(requestParameters: LoansApiGetLoanByApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanResponse>;

    /**
     * Get Bridge wallet and liquidation address details for a loan. Returns real-time wallet balance and liquidation address status. Lender-only endpoint. 
     * @summary Get loan wallet details
     * @param {LoansApiGetLoanWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApiInterface
     */
    getLoanWallet(requestParameters: LoansApiGetLoanWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanWalletResponse>;

    /**
     * Get projected payment schedule based on current loan state. Both lenders and neobanks can access their own loans. 
     * @summary Get payment schedule
     * @param {LoansApiGetPaymentScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApiInterface
     */
    getPaymentSchedule(requestParameters: LoansApiGetPaymentScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentScheduleResponse>;

    /**
     * List repayments for a loan with pagination and filtering. Both lenders and neobanks can access their own loans.  Use `source=bridge` (lender-only) to fetch live data directly from Bridge API instead of the local database. This shows raw liquidation address drains with summary information. 
     * @summary List loan repayments
     * @param {LoansApiListLoanRepaymentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApiInterface
     */
    listLoanRepayments(requestParameters: LoansApiListLoanRepaymentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListLoanRepayments200Response>;

    /**
     * List loans for the authenticated entity with pagination and filtering.  **For Lenders:** Returns loans they funded. **For Neobanks:** Returns loans from applications they originated.  Neobanks can filter by `externalId` (their user reference) or `borrowerAddress` (wallet address) to efficiently retrieve loans for a specific borrower. 
     * @summary List loans
     * @param {LoansApiListLoansRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApiInterface
     */
    listLoans(requestParameters?: LoansApiListLoansRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanListResponse>;

    /**
     * Sweep balance from a loan\'s wallet to the master treasury wallet. Supports sweeping a specific amount or the full balance. Uses idempotency keys to prevent duplicate transfers. Lender-only endpoint. 
     * @summary Sweep loan wallet
     * @param {LoansApiSweepLoanWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApiInterface
     */
    sweepLoanWallet(requestParameters: LoansApiSweepLoanWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanSweepResponse>;

    /**
     * Update loan terms for corrections after origination. Lender-only endpoint. 
     * @summary Update loan terms
     * @param {LoansApiUpdateLoanTermsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApiInterface
     */
    updateLoanTerms(requestParameters: LoansApiUpdateLoanTermsRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoanResponse>;

}

/**
 * Request parameters for applyLenderOverride operation in LoansApi.
 * @export
 * @interface LoansApiApplyLenderOverrideRequest
 */
export interface LoansApiApplyLenderOverrideRequest {
    /**
     * Unique identifier for the loan
     * @type {string}
     * @memberof LoansApiApplyLenderOverride
     */
    readonly loanId: string

    /**
     * 
     * @type {LoanStateOverrideRequest}
     * @memberof LoansApiApplyLenderOverride
     */
    readonly loanStateOverrideRequest: LoanStateOverrideRequest
}

/**
 * Request parameters for getLoan operation in LoansApi.
 * @export
 * @interface LoansApiGetLoanRequest
 */
export interface LoansApiGetLoanRequest {
    /**
     * Unique identifier for the loan
     * @type {string}
     * @memberof LoansApiGetLoan
     */
    readonly loanId: string
}

/**
 * Request parameters for getLoanByApplication operation in LoansApi.
 * @export
 * @interface LoansApiGetLoanByApplicationRequest
 */
export interface LoansApiGetLoanByApplicationRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof LoansApiGetLoanByApplication
     */
    readonly applicationId: string
}

/**
 * Request parameters for getLoanWallet operation in LoansApi.
 * @export
 * @interface LoansApiGetLoanWalletRequest
 */
export interface LoansApiGetLoanWalletRequest {
    /**
     * Unique identifier for the loan
     * @type {string}
     * @memberof LoansApiGetLoanWallet
     */
    readonly loanId: string
}

/**
 * Request parameters for getPaymentSchedule operation in LoansApi.
 * @export
 * @interface LoansApiGetPaymentScheduleRequest
 */
export interface LoansApiGetPaymentScheduleRequest {
    /**
     * Unique identifier for the loan
     * @type {string}
     * @memberof LoansApiGetPaymentSchedule
     */
    readonly loanId: string
}

/**
 * Request parameters for listLoanRepayments operation in LoansApi.
 * @export
 * @interface LoansApiListLoanRepaymentsRequest
 */
export interface LoansApiListLoanRepaymentsRequest {
    /**
     * Unique identifier for the loan
     * @type {string}
     * @memberof LoansApiListLoanRepayments
     */
    readonly loanId: string

    /**
     * Filter by repayment status
     * @type {RepaymentStatus}
     * @memberof LoansApiListLoanRepayments
     */
    readonly status?: RepaymentStatus

    /**
     * Maximum number of results (default 50, max 100)
     * @type {number}
     * @memberof LoansApiListLoanRepayments
     */
    readonly limit?: number

    /**
     * Pagination offset
     * @type {number}
     * @memberof LoansApiListLoanRepayments
     */
    readonly offset?: number

    /**
     * Data source for repayments. - &#x60;database&#x60; (default): Fetch from local database (includes principal/interest allocation) - &#x60;bridge&#x60;: Fetch live from Bridge API (lender-only, shows raw drain data) 
     * @type {'database' | 'bridge'}
     * @memberof LoansApiListLoanRepayments
     */
    readonly source?: ListLoanRepaymentsSourceEnum
}

/**
 * Request parameters for listLoans operation in LoansApi.
 * @export
 * @interface LoansApiListLoansRequest
 */
export interface LoansApiListLoansRequest {
    /**
     * Filter by loan status
     * @type {LoanStatus}
     * @memberof LoansApiListLoans
     */
    readonly status?: LoanStatus

    /**
     * Filter by application\&#39;s external reference ID (neobank-only). Exact match. Use this when you have your own user ID system. 
     * @type {string}
     * @memberof LoansApiListLoans
     */
    readonly externalId?: string

    /**
     * Filter by borrower\&#39;s wallet address (case-insensitive, neobank-only). Use this for wallet-first applications. 
     * @type {string}
     * @memberof LoansApiListLoans
     */
    readonly borrowerAddress?: string

    /**
     * Maximum number of results (default 50, max 100)
     * @type {number}
     * @memberof LoansApiListLoans
     */
    readonly limit?: number

    /**
     * Pagination offset
     * @type {number}
     * @memberof LoansApiListLoans
     */
    readonly offset?: number
}

/**
 * Request parameters for sweepLoanWallet operation in LoansApi.
 * @export
 * @interface LoansApiSweepLoanWalletRequest
 */
export interface LoansApiSweepLoanWalletRequest {
    /**
     * Unique identifier for the loan
     * @type {string}
     * @memberof LoansApiSweepLoanWallet
     */
    readonly loanId: string

    /**
     * 
     * @type {LoanSweepRequest}
     * @memberof LoansApiSweepLoanWallet
     */
    readonly loanSweepRequest?: LoanSweepRequest
}

/**
 * Request parameters for updateLoanTerms operation in LoansApi.
 * @export
 * @interface LoansApiUpdateLoanTermsRequest
 */
export interface LoansApiUpdateLoanTermsRequest {
    /**
     * Unique identifier for the loan
     * @type {string}
     * @memberof LoansApiUpdateLoanTerms
     */
    readonly loanId: string

    /**
     * 
     * @type {LoanTermsUpdateRequest}
     * @memberof LoansApiUpdateLoanTerms
     */
    readonly loanTermsUpdateRequest: LoanTermsUpdateRequest
}

/**
 * LoansApi - object-oriented interface
 * @export
 * @class LoansApi
 * @extends {BaseAPI}
 */
export class LoansApi extends BaseAPI implements LoansApiInterface {
    /**
     * Apply lender override to loan state (e.g., mark as defaulted). Lender-only endpoint. 
     * @summary Apply lender override
     * @param {LoansApiApplyLenderOverrideRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApi
     */
    public applyLenderOverride(requestParameters: LoansApiApplyLenderOverrideRequest, options?: RawAxiosRequestConfig) {
        return LoansApiFp(this.configuration).applyLenderOverride(requestParameters.loanId, requestParameters.loanStateOverrideRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed loan information. Both lenders and neobanks can access their own loans. 
     * @summary Get loan details
     * @param {LoansApiGetLoanRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApi
     */
    public getLoan(requestParameters: LoansApiGetLoanRequest, options?: RawAxiosRequestConfig) {
        return LoansApiFp(this.configuration).getLoan(requestParameters.loanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get loan details by application ID. Convenience endpoint for neobanks to retrieve loan information including the repayment address (Bridge liquidation address). Neobank-only endpoint. 
     * @summary Get loan by application
     * @param {LoansApiGetLoanByApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApi
     */
    public getLoanByApplication(requestParameters: LoansApiGetLoanByApplicationRequest, options?: RawAxiosRequestConfig) {
        return LoansApiFp(this.configuration).getLoanByApplication(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Bridge wallet and liquidation address details for a loan. Returns real-time wallet balance and liquidation address status. Lender-only endpoint. 
     * @summary Get loan wallet details
     * @param {LoansApiGetLoanWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApi
     */
    public getLoanWallet(requestParameters: LoansApiGetLoanWalletRequest, options?: RawAxiosRequestConfig) {
        return LoansApiFp(this.configuration).getLoanWallet(requestParameters.loanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get projected payment schedule based on current loan state. Both lenders and neobanks can access their own loans. 
     * @summary Get payment schedule
     * @param {LoansApiGetPaymentScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApi
     */
    public getPaymentSchedule(requestParameters: LoansApiGetPaymentScheduleRequest, options?: RawAxiosRequestConfig) {
        return LoansApiFp(this.configuration).getPaymentSchedule(requestParameters.loanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List repayments for a loan with pagination and filtering. Both lenders and neobanks can access their own loans.  Use `source=bridge` (lender-only) to fetch live data directly from Bridge API instead of the local database. This shows raw liquidation address drains with summary information. 
     * @summary List loan repayments
     * @param {LoansApiListLoanRepaymentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApi
     */
    public listLoanRepayments(requestParameters: LoansApiListLoanRepaymentsRequest, options?: RawAxiosRequestConfig) {
        return LoansApiFp(this.configuration).listLoanRepayments(requestParameters.loanId, requestParameters.status, requestParameters.limit, requestParameters.offset, requestParameters.source, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List loans for the authenticated entity with pagination and filtering.  **For Lenders:** Returns loans they funded. **For Neobanks:** Returns loans from applications they originated.  Neobanks can filter by `externalId` (their user reference) or `borrowerAddress` (wallet address) to efficiently retrieve loans for a specific borrower. 
     * @summary List loans
     * @param {LoansApiListLoansRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApi
     */
    public listLoans(requestParameters: LoansApiListLoansRequest = {}, options?: RawAxiosRequestConfig) {
        return LoansApiFp(this.configuration).listLoans(requestParameters.status, requestParameters.externalId, requestParameters.borrowerAddress, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sweep balance from a loan\'s wallet to the master treasury wallet. Supports sweeping a specific amount or the full balance. Uses idempotency keys to prevent duplicate transfers. Lender-only endpoint. 
     * @summary Sweep loan wallet
     * @param {LoansApiSweepLoanWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApi
     */
    public sweepLoanWallet(requestParameters: LoansApiSweepLoanWalletRequest, options?: RawAxiosRequestConfig) {
        return LoansApiFp(this.configuration).sweepLoanWallet(requestParameters.loanId, requestParameters.loanSweepRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update loan terms for corrections after origination. Lender-only endpoint. 
     * @summary Update loan terms
     * @param {LoansApiUpdateLoanTermsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoansApi
     */
    public updateLoanTerms(requestParameters: LoansApiUpdateLoanTermsRequest, options?: RawAxiosRequestConfig) {
        return LoansApiFp(this.configuration).updateLoanTerms(requestParameters.loanId, requestParameters.loanTermsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListLoanRepaymentsSourceEnum = {
    Database: 'database',
    Bridge: 'bridge'
} as const;
export type ListLoanRepaymentsSourceEnum = typeof ListLoanRepaymentsSourceEnum[keyof typeof ListLoanRepaymentsSourceEnum];


/**
 * NeobankSelfServiceApi - axios parameter creator
 * @export
 */
export const NeobankSelfServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get current neobank account information including configuration and status. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Get account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get aggregated statistics for the authenticated entity. Works for both lenders and neobanks - returns relevant metrics based on entity type.  **For Neobanks:** Returns application counts by status, loan statistics, and borrower counts. **For Lenders:** Returns loan portfolio statistics including funded amounts and repayment totals.  Response includes Cache-Control header (60 second TTL) for performance. 
         * @summary Get account statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current webhook configuration including URL and whether a secret is set. The webhook secret is never returned in full - only a masked preview. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Get webhook configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a new webhook secret. The new secret is returned ONLY ONCE in this response - save it immediately. The old secret is immediately invalidated. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Rotate webhook secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateWebhookSecret: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/webhook/rotate-secret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a test webhook to verify your endpoint is working correctly. The test webhook will include a signature for verification. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Send test webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testWebhook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/webhook/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the webhook URL for receiving notifications. Set to null to disable webhooks. URL must use HTTPS protocol. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Update webhook URL
         * @param {WebhookUrlUpdateRequest} webhookUrlUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookUrl: async (webhookUrlUpdateRequest: WebhookUrlUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookUrlUpdateRequest' is not null or undefined
            assertParamExists('updateWebhookUrl', 'webhookUrlUpdateRequest', webhookUrlUpdateRequest)
            const localVarPath = `/me/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookUrlUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NeobankSelfServiceApi - functional programming interface
 * @export
 */
export const NeobankSelfServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NeobankSelfServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get current neobank account information including configuration and status. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Get account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NeobankAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NeobankSelfServiceApi.getAccountInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get aggregated statistics for the authenticated entity. Works for both lenders and neobanks - returns relevant metrics based on entity type.  **For Neobanks:** Returns application counts by status, loan statistics, and borrower counts. **For Lenders:** Returns loan portfolio statistics including funded amounts and repayment totals.  Response includes Cache-Control header (60 second TTL) for performance. 
         * @summary Get account statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NeobankSelfServiceApi.getAccountStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current webhook configuration including URL and whether a secret is set. The webhook secret is never returned in full - only a masked preview. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Get webhook configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhookConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhookConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NeobankSelfServiceApi.getWebhookConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a new webhook secret. The new secret is returned ONLY ONCE in this response - save it immediately. The old secret is immediately invalidated. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Rotate webhook secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rotateWebhookSecret(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSecretRotateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rotateWebhookSecret(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NeobankSelfServiceApi.rotateWebhookSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a test webhook to verify your endpoint is working correctly. The test webhook will include a signature for verification. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Send test webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testWebhook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testWebhook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NeobankSelfServiceApi.testWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the webhook URL for receiving notifications. Set to null to disable webhooks. URL must use HTTPS protocol. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Update webhook URL
         * @param {WebhookUrlUpdateRequest} webhookUrlUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhookUrl(webhookUrlUpdateRequest: WebhookUrlUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookUrlUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhookUrl(webhookUrlUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NeobankSelfServiceApi.updateWebhookUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NeobankSelfServiceApi - factory interface
 * @export
 */
export const NeobankSelfServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NeobankSelfServiceApiFp(configuration)
    return {
        /**
         * Get current neobank account information including configuration and status. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Get account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInfo(options?: RawAxiosRequestConfig): AxiosPromise<NeobankAccountResponse> {
            return localVarFp.getAccountInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Get aggregated statistics for the authenticated entity. Works for both lenders and neobanks - returns relevant metrics based on entity type.  **For Neobanks:** Returns application counts by status, loan statistics, and borrower counts. **For Lenders:** Returns loan portfolio statistics including funded amounts and repayment totals.  Response includes Cache-Control header (60 second TTL) for performance. 
         * @summary Get account statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountStats(options?: RawAxiosRequestConfig): AxiosPromise<GetAccountStats200Response> {
            return localVarFp.getAccountStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Get current webhook configuration including URL and whether a secret is set. The webhook secret is never returned in full - only a masked preview. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Get webhook configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookConfig(options?: RawAxiosRequestConfig): AxiosPromise<WebhookConfigResponse> {
            return localVarFp.getWebhookConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a new webhook secret. The new secret is returned ONLY ONCE in this response - save it immediately. The old secret is immediately invalidated. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Rotate webhook secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateWebhookSecret(options?: RawAxiosRequestConfig): AxiosPromise<WebhookSecretRotateResponse> {
            return localVarFp.rotateWebhookSecret(options).then((request) => request(axios, basePath));
        },
        /**
         * Send a test webhook to verify your endpoint is working correctly. The test webhook will include a signature for verification. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Send test webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testWebhook(options?: RawAxiosRequestConfig): AxiosPromise<WebhookTestResponse> {
            return localVarFp.testWebhook(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the webhook URL for receiving notifications. Set to null to disable webhooks. URL must use HTTPS protocol. NEOBANK ONLY - Requires neobank API key authentication. 
         * @summary Update webhook URL
         * @param {NeobankSelfServiceApiUpdateWebhookUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookUrl(requestParameters: NeobankSelfServiceApiUpdateWebhookUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookUrlUpdateResponse> {
            return localVarFp.updateWebhookUrl(requestParameters.webhookUrlUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NeobankSelfServiceApi - interface
 * @export
 * @interface NeobankSelfServiceApi
 */
export interface NeobankSelfServiceApiInterface {
    /**
     * Get current neobank account information including configuration and status. NEOBANK ONLY - Requires neobank API key authentication. 
     * @summary Get account information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeobankSelfServiceApiInterface
     */
    getAccountInfo(options?: RawAxiosRequestConfig): AxiosPromise<NeobankAccountResponse>;

    /**
     * Get aggregated statistics for the authenticated entity. Works for both lenders and neobanks - returns relevant metrics based on entity type.  **For Neobanks:** Returns application counts by status, loan statistics, and borrower counts. **For Lenders:** Returns loan portfolio statistics including funded amounts and repayment totals.  Response includes Cache-Control header (60 second TTL) for performance. 
     * @summary Get account statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeobankSelfServiceApiInterface
     */
    getAccountStats(options?: RawAxiosRequestConfig): AxiosPromise<GetAccountStats200Response>;

    /**
     * Get current webhook configuration including URL and whether a secret is set. The webhook secret is never returned in full - only a masked preview. NEOBANK ONLY - Requires neobank API key authentication. 
     * @summary Get webhook configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeobankSelfServiceApiInterface
     */
    getWebhookConfig(options?: RawAxiosRequestConfig): AxiosPromise<WebhookConfigResponse>;

    /**
     * Generate a new webhook secret. The new secret is returned ONLY ONCE in this response - save it immediately. The old secret is immediately invalidated. NEOBANK ONLY - Requires neobank API key authentication. 
     * @summary Rotate webhook secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeobankSelfServiceApiInterface
     */
    rotateWebhookSecret(options?: RawAxiosRequestConfig): AxiosPromise<WebhookSecretRotateResponse>;

    /**
     * Send a test webhook to verify your endpoint is working correctly. The test webhook will include a signature for verification. NEOBANK ONLY - Requires neobank API key authentication. 
     * @summary Send test webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeobankSelfServiceApiInterface
     */
    testWebhook(options?: RawAxiosRequestConfig): AxiosPromise<WebhookTestResponse>;

    /**
     * Update the webhook URL for receiving notifications. Set to null to disable webhooks. URL must use HTTPS protocol. NEOBANK ONLY - Requires neobank API key authentication. 
     * @summary Update webhook URL
     * @param {NeobankSelfServiceApiUpdateWebhookUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeobankSelfServiceApiInterface
     */
    updateWebhookUrl(requestParameters: NeobankSelfServiceApiUpdateWebhookUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookUrlUpdateResponse>;

}

/**
 * Request parameters for updateWebhookUrl operation in NeobankSelfServiceApi.
 * @export
 * @interface NeobankSelfServiceApiUpdateWebhookUrlRequest
 */
export interface NeobankSelfServiceApiUpdateWebhookUrlRequest {
    /**
     * 
     * @type {WebhookUrlUpdateRequest}
     * @memberof NeobankSelfServiceApiUpdateWebhookUrl
     */
    readonly webhookUrlUpdateRequest: WebhookUrlUpdateRequest
}

/**
 * NeobankSelfServiceApi - object-oriented interface
 * @export
 * @class NeobankSelfServiceApi
 * @extends {BaseAPI}
 */
export class NeobankSelfServiceApi extends BaseAPI implements NeobankSelfServiceApiInterface {
    /**
     * Get current neobank account information including configuration and status. NEOBANK ONLY - Requires neobank API key authentication. 
     * @summary Get account information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeobankSelfServiceApi
     */
    public getAccountInfo(options?: RawAxiosRequestConfig) {
        return NeobankSelfServiceApiFp(this.configuration).getAccountInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get aggregated statistics for the authenticated entity. Works for both lenders and neobanks - returns relevant metrics based on entity type.  **For Neobanks:** Returns application counts by status, loan statistics, and borrower counts. **For Lenders:** Returns loan portfolio statistics including funded amounts and repayment totals.  Response includes Cache-Control header (60 second TTL) for performance. 
     * @summary Get account statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeobankSelfServiceApi
     */
    public getAccountStats(options?: RawAxiosRequestConfig) {
        return NeobankSelfServiceApiFp(this.configuration).getAccountStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current webhook configuration including URL and whether a secret is set. The webhook secret is never returned in full - only a masked preview. NEOBANK ONLY - Requires neobank API key authentication. 
     * @summary Get webhook configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeobankSelfServiceApi
     */
    public getWebhookConfig(options?: RawAxiosRequestConfig) {
        return NeobankSelfServiceApiFp(this.configuration).getWebhookConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a new webhook secret. The new secret is returned ONLY ONCE in this response - save it immediately. The old secret is immediately invalidated. NEOBANK ONLY - Requires neobank API key authentication. 
     * @summary Rotate webhook secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeobankSelfServiceApi
     */
    public rotateWebhookSecret(options?: RawAxiosRequestConfig) {
        return NeobankSelfServiceApiFp(this.configuration).rotateWebhookSecret(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a test webhook to verify your endpoint is working correctly. The test webhook will include a signature for verification. NEOBANK ONLY - Requires neobank API key authentication. 
     * @summary Send test webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeobankSelfServiceApi
     */
    public testWebhook(options?: RawAxiosRequestConfig) {
        return NeobankSelfServiceApiFp(this.configuration).testWebhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the webhook URL for receiving notifications. Set to null to disable webhooks. URL must use HTTPS protocol. NEOBANK ONLY - Requires neobank API key authentication. 
     * @summary Update webhook URL
     * @param {NeobankSelfServiceApiUpdateWebhookUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NeobankSelfServiceApi
     */
    public updateWebhookUrl(requestParameters: NeobankSelfServiceApiUpdateWebhookUrlRequest, options?: RawAxiosRequestConfig) {
        return NeobankSelfServiceApiFp(this.configuration).updateWebhookUrl(requestParameters.webhookUrlUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OffersApi - axios parameter creator
 * @export
 */
export const OffersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Neobank accepts a final offer (triggers document signing). This triggers: - Status update to ACCEPTED for selected offer - Rejection of all other pending final offers - Webhook notification to winning lender - Document signing workflow initiation 
         * @summary Accept final offer
         * @param {string} offerId Unique identifier for the offer
         * @param {OfferAcceptanceRequest} offerAcceptanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFinalOffer: async (offerId: string, offerAcceptanceRequest: OfferAcceptanceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offerId' is not null or undefined
            assertParamExists('acceptFinalOffer', 'offerId', offerId)
            // verify required parameter 'offerAcceptanceRequest' is not null or undefined
            assertParamExists('acceptFinalOffer', 'offerAcceptanceRequest', offerAcceptanceRequest)
            const localVarPath = `/final-offers/{offerId}/accept`
                .replace(`{${"offerId"}}`, encodeURIComponent(String(offerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerAcceptanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Neobank accepts a prequalified offer with hard pull consent. This triggers: - Status update to ACCEPTED for selected offer - Rejection of all other pending prequalified offers - Webhook notification to winning lender (with consent details) - Lender proceeds with hard pull and submits final offer 
         * @summary Accept prequalified offer
         * @param {string} offerId Unique identifier for the offer
         * @param {OfferAcceptanceRequest} offerAcceptanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptPrequalOffer: async (offerId: string, offerAcceptanceRequest: OfferAcceptanceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offerId' is not null or undefined
            assertParamExists('acceptPrequalOffer', 'offerId', offerId)
            // verify required parameter 'offerAcceptanceRequest' is not null or undefined
            assertParamExists('acceptPrequalOffer', 'offerAcceptanceRequest', offerAcceptanceRequest)
            const localVarPath = `/prequal-offers/{offerId}/accept`
                .replace(`{${"offerId"}}`, encodeURIComponent(String(offerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerAcceptanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm that e-signature has been completed (neobank only)
         * @summary Confirm e-signature completion
         * @param {string} applicationId Unique identifier for the application
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmESignComplete: async (applicationId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('confirmESignComplete', 'applicationId', applicationId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('confirmESignComplete', 'body', body)
            const localVarPath = `/applications/{applicationId}/esign-complete`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get e-signature URL for approved application (neobank only)
         * @summary Get e-signature URL
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getESignUrl: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getESignUrl', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/esign-url`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Neobank retrieves all final offers for their application. Returns encrypted offers grouped by lender. 
         * @summary Get final offers
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinalOffers: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getFinalOffers', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/final-offers`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lender retrieves details of a specific offer by ID. Must specify offerType query parameter (prequalified or final). 
         * @summary Get specific offer
         * @param {string} offerId Unique identifier for the offer
         * @param {GetLenderOfferByIdOfferTypeEnum} offerType Type of offer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLenderOfferById: async (offerId: string, offerType: GetLenderOfferByIdOfferTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offerId' is not null or undefined
            assertParamExists('getLenderOfferById', 'offerId', offerId)
            // verify required parameter 'offerType' is not null or undefined
            assertParamExists('getLenderOfferById', 'offerType', offerType)
            const localVarPath = `/offers/{offerId}`
                .replace(`{${"offerId"}}`, encodeURIComponent(String(offerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (offerType !== undefined) {
                localVarQueryParameter['offerType'] = offerType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Neobank retrieves all prequalified offers for their application. Returns encrypted offers grouped by lender. 
         * @summary Get prequalified offers
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrequalOffers: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getPrequalOffers', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/prequal-offers`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lender retrieves all their offers (prequalified and/or final) with pagination. Supports filtering by offer type, status, and application ID. 
         * @summary List lender\'s offers
         * @param {ListLenderOffersOfferTypeEnum} [offerType] Filter by offer type
         * @param {OfferStatus} [status] Filter by offer status
         * @param {string} [applicationId] Filter by application ID
         * @param {number} [page] Page number (1-indexed)
         * @param {number} [limit] Number of results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLenderOffers: async (offerType?: ListLenderOffersOfferTypeEnum, status?: OfferStatus, applicationId?: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (offerType !== undefined) {
                localVarQueryParameter['offerType'] = offerType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lender submits 1-10 final offers after hard pull credit check. All sensitive offer details are encrypted with the neobank\'s public key. Each final offer must reference a previously accepted prequalified offer.  **Workflow:** 1. Lender receives acceptance webhook for prequalified offer 2. Lender performs hard pull credit check 3. Lender creates final offer(s) based on hard pull results 4. Lender encrypts offer details with neobank\'s RSA public key 5. Lender submits encrypted final offers via this endpoint 6. Neobank retrieves and decrypts offers with their private key 
         * @summary Submit final offers
         * @param {string} applicationId Unique identifier for the application
         * @param {FinalOfferSubmission} finalOfferSubmission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFinalOffers: async (applicationId: string, finalOfferSubmission: FinalOfferSubmission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('submitFinalOffers', 'applicationId', applicationId)
            // verify required parameter 'finalOfferSubmission' is not null or undefined
            assertParamExists('submitFinalOffers', 'finalOfferSubmission', finalOfferSubmission)
            const localVarPath = `/applications/{applicationId}/final-offers`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(finalOfferSubmission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lender submits 1-10 prequalified offers for an application (soft pull only). All sensitive offer details are encrypted with the neobank\'s public key.  **Workflow:** 1. Lender performs soft pull credit check 2. Lender encrypts offer details with neobank\'s RSA public key 3. Lender submits encrypted offers via this endpoint 4. Neobank receives webhook notification 5. Neobank retrieves and decrypts offers with their private key 
         * @summary Submit prequalified offers
         * @param {string} applicationId Unique identifier for the application
         * @param {PrequalOfferSubmission} prequalOfferSubmission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrequalOffers: async (applicationId: string, prequalOfferSubmission: PrequalOfferSubmission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('submitPrequalOffers', 'applicationId', applicationId)
            // verify required parameter 'prequalOfferSubmission' is not null or undefined
            assertParamExists('submitPrequalOffers', 'prequalOfferSubmission', prequalOfferSubmission)
            const localVarPath = `/applications/{applicationId}/prequal-offers`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prequalOfferSubmission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OffersApi - functional programming interface
 * @export
 */
export const OffersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OffersApiAxiosParamCreator(configuration)
    return {
        /**
         * Neobank accepts a final offer (triggers document signing). This triggers: - Status update to ACCEPTED for selected offer - Rejection of all other pending final offers - Webhook notification to winning lender - Document signing workflow initiation 
         * @summary Accept final offer
         * @param {string} offerId Unique identifier for the offer
         * @param {OfferAcceptanceRequest} offerAcceptanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptFinalOffer(offerId: string, offerAcceptanceRequest: OfferAcceptanceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferAcceptanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptFinalOffer(offerId, offerAcceptanceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.acceptFinalOffer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Neobank accepts a prequalified offer with hard pull consent. This triggers: - Status update to ACCEPTED for selected offer - Rejection of all other pending prequalified offers - Webhook notification to winning lender (with consent details) - Lender proceeds with hard pull and submits final offer 
         * @summary Accept prequalified offer
         * @param {string} offerId Unique identifier for the offer
         * @param {OfferAcceptanceRequest} offerAcceptanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptPrequalOffer(offerId: string, offerAcceptanceRequest: OfferAcceptanceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferAcceptanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptPrequalOffer(offerId, offerAcceptanceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.acceptPrequalOffer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Confirm that e-signature has been completed (neobank only)
         * @summary Confirm e-signature completion
         * @param {string} applicationId Unique identifier for the application
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmESignComplete(applicationId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfirmESignComplete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmESignComplete(applicationId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.confirmESignComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get e-signature URL for approved application (neobank only)
         * @summary Get e-signature URL
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getESignUrl(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetESignUrl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getESignUrl(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.getESignUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Neobank retrieves all final offers for their application. Returns encrypted offers grouped by lender. 
         * @summary Get final offers
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinalOffers(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EncryptedOffersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinalOffers(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.getFinalOffers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lender retrieves details of a specific offer by ID. Must specify offerType query parameter (prequalified or final). 
         * @summary Get specific offer
         * @param {string} offerId Unique identifier for the offer
         * @param {GetLenderOfferByIdOfferTypeEnum} offerType Type of offer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLenderOfferById(offerId: string, offerType: GetLenderOfferByIdOfferTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLenderOfferById(offerId, offerType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.getLenderOfferById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Neobank retrieves all prequalified offers for their application. Returns encrypted offers grouped by lender. 
         * @summary Get prequalified offers
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrequalOffers(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EncryptedOffersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrequalOffers(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.getPrequalOffers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lender retrieves all their offers (prequalified and/or final) with pagination. Supports filtering by offer type, status, and application ID. 
         * @summary List lender\'s offers
         * @param {ListLenderOffersOfferTypeEnum} [offerType] Filter by offer type
         * @param {OfferStatus} [status] Filter by offer status
         * @param {string} [applicationId] Filter by application ID
         * @param {number} [page] Page number (1-indexed)
         * @param {number} [limit] Number of results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLenderOffers(offerType?: ListLenderOffersOfferTypeEnum, status?: OfferStatus, applicationId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LenderOffersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLenderOffers(offerType, status, applicationId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.listLenderOffers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lender submits 1-10 final offers after hard pull credit check. All sensitive offer details are encrypted with the neobank\'s public key. Each final offer must reference a previously accepted prequalified offer.  **Workflow:** 1. Lender receives acceptance webhook for prequalified offer 2. Lender performs hard pull credit check 3. Lender creates final offer(s) based on hard pull results 4. Lender encrypts offer details with neobank\'s RSA public key 5. Lender submits encrypted final offers via this endpoint 6. Neobank retrieves and decrypts offers with their private key 
         * @summary Submit final offers
         * @param {string} applicationId Unique identifier for the application
         * @param {FinalOfferSubmission} finalOfferSubmission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitFinalOffers(applicationId: string, finalOfferSubmission: FinalOfferSubmission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferSubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitFinalOffers(applicationId, finalOfferSubmission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.submitFinalOffers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lender submits 1-10 prequalified offers for an application (soft pull only). All sensitive offer details are encrypted with the neobank\'s public key.  **Workflow:** 1. Lender performs soft pull credit check 2. Lender encrypts offer details with neobank\'s RSA public key 3. Lender submits encrypted offers via this endpoint 4. Neobank receives webhook notification 5. Neobank retrieves and decrypts offers with their private key 
         * @summary Submit prequalified offers
         * @param {string} applicationId Unique identifier for the application
         * @param {PrequalOfferSubmission} prequalOfferSubmission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitPrequalOffers(applicationId: string, prequalOfferSubmission: PrequalOfferSubmission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferSubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitPrequalOffers(applicationId, prequalOfferSubmission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OffersApi.submitPrequalOffers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OffersApi - factory interface
 * @export
 */
export const OffersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OffersApiFp(configuration)
    return {
        /**
         * Neobank accepts a final offer (triggers document signing). This triggers: - Status update to ACCEPTED for selected offer - Rejection of all other pending final offers - Webhook notification to winning lender - Document signing workflow initiation 
         * @summary Accept final offer
         * @param {OffersApiAcceptFinalOfferRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFinalOffer(requestParameters: OffersApiAcceptFinalOfferRequest, options?: RawAxiosRequestConfig): AxiosPromise<OfferAcceptanceResponse> {
            return localVarFp.acceptFinalOffer(requestParameters.offerId, requestParameters.offerAcceptanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Neobank accepts a prequalified offer with hard pull consent. This triggers: - Status update to ACCEPTED for selected offer - Rejection of all other pending prequalified offers - Webhook notification to winning lender (with consent details) - Lender proceeds with hard pull and submits final offer 
         * @summary Accept prequalified offer
         * @param {OffersApiAcceptPrequalOfferRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptPrequalOffer(requestParameters: OffersApiAcceptPrequalOfferRequest, options?: RawAxiosRequestConfig): AxiosPromise<OfferAcceptanceResponse> {
            return localVarFp.acceptPrequalOffer(requestParameters.offerId, requestParameters.offerAcceptanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirm that e-signature has been completed (neobank only)
         * @summary Confirm e-signature completion
         * @param {OffersApiConfirmESignCompleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmESignComplete(requestParameters: OffersApiConfirmESignCompleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConfirmESignComplete200Response> {
            return localVarFp.confirmESignComplete(requestParameters.applicationId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get e-signature URL for approved application (neobank only)
         * @summary Get e-signature URL
         * @param {OffersApiGetESignUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getESignUrl(requestParameters: OffersApiGetESignUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetESignUrl200Response> {
            return localVarFp.getESignUrl(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Neobank retrieves all final offers for their application. Returns encrypted offers grouped by lender. 
         * @summary Get final offers
         * @param {OffersApiGetFinalOffersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinalOffers(requestParameters: OffersApiGetFinalOffersRequest, options?: RawAxiosRequestConfig): AxiosPromise<EncryptedOffersResponse> {
            return localVarFp.getFinalOffers(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lender retrieves details of a specific offer by ID. Must specify offerType query parameter (prequalified or final). 
         * @summary Get specific offer
         * @param {OffersApiGetLenderOfferByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLenderOfferById(requestParameters: OffersApiGetLenderOfferByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<OfferDetailResponse> {
            return localVarFp.getLenderOfferById(requestParameters.offerId, requestParameters.offerType, options).then((request) => request(axios, basePath));
        },
        /**
         * Neobank retrieves all prequalified offers for their application. Returns encrypted offers grouped by lender. 
         * @summary Get prequalified offers
         * @param {OffersApiGetPrequalOffersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrequalOffers(requestParameters: OffersApiGetPrequalOffersRequest, options?: RawAxiosRequestConfig): AxiosPromise<EncryptedOffersResponse> {
            return localVarFp.getPrequalOffers(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lender retrieves all their offers (prequalified and/or final) with pagination. Supports filtering by offer type, status, and application ID. 
         * @summary List lender\'s offers
         * @param {OffersApiListLenderOffersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLenderOffers(requestParameters: OffersApiListLenderOffersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<LenderOffersResponse> {
            return localVarFp.listLenderOffers(requestParameters.offerType, requestParameters.status, requestParameters.applicationId, requestParameters.page, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Lender submits 1-10 final offers after hard pull credit check. All sensitive offer details are encrypted with the neobank\'s public key. Each final offer must reference a previously accepted prequalified offer.  **Workflow:** 1. Lender receives acceptance webhook for prequalified offer 2. Lender performs hard pull credit check 3. Lender creates final offer(s) based on hard pull results 4. Lender encrypts offer details with neobank\'s RSA public key 5. Lender submits encrypted final offers via this endpoint 6. Neobank retrieves and decrypts offers with their private key 
         * @summary Submit final offers
         * @param {OffersApiSubmitFinalOffersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFinalOffers(requestParameters: OffersApiSubmitFinalOffersRequest, options?: RawAxiosRequestConfig): AxiosPromise<OfferSubmissionResponse> {
            return localVarFp.submitFinalOffers(requestParameters.applicationId, requestParameters.finalOfferSubmission, options).then((request) => request(axios, basePath));
        },
        /**
         * Lender submits 1-10 prequalified offers for an application (soft pull only). All sensitive offer details are encrypted with the neobank\'s public key.  **Workflow:** 1. Lender performs soft pull credit check 2. Lender encrypts offer details with neobank\'s RSA public key 3. Lender submits encrypted offers via this endpoint 4. Neobank receives webhook notification 5. Neobank retrieves and decrypts offers with their private key 
         * @summary Submit prequalified offers
         * @param {OffersApiSubmitPrequalOffersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrequalOffers(requestParameters: OffersApiSubmitPrequalOffersRequest, options?: RawAxiosRequestConfig): AxiosPromise<OfferSubmissionResponse> {
            return localVarFp.submitPrequalOffers(requestParameters.applicationId, requestParameters.prequalOfferSubmission, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OffersApi - interface
 * @export
 * @interface OffersApi
 */
export interface OffersApiInterface {
    /**
     * Neobank accepts a final offer (triggers document signing). This triggers: - Status update to ACCEPTED for selected offer - Rejection of all other pending final offers - Webhook notification to winning lender - Document signing workflow initiation 
     * @summary Accept final offer
     * @param {OffersApiAcceptFinalOfferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApiInterface
     */
    acceptFinalOffer(requestParameters: OffersApiAcceptFinalOfferRequest, options?: RawAxiosRequestConfig): AxiosPromise<OfferAcceptanceResponse>;

    /**
     * Neobank accepts a prequalified offer with hard pull consent. This triggers: - Status update to ACCEPTED for selected offer - Rejection of all other pending prequalified offers - Webhook notification to winning lender (with consent details) - Lender proceeds with hard pull and submits final offer 
     * @summary Accept prequalified offer
     * @param {OffersApiAcceptPrequalOfferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApiInterface
     */
    acceptPrequalOffer(requestParameters: OffersApiAcceptPrequalOfferRequest, options?: RawAxiosRequestConfig): AxiosPromise<OfferAcceptanceResponse>;

    /**
     * Confirm that e-signature has been completed (neobank only)
     * @summary Confirm e-signature completion
     * @param {OffersApiConfirmESignCompleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApiInterface
     */
    confirmESignComplete(requestParameters: OffersApiConfirmESignCompleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConfirmESignComplete200Response>;

    /**
     * Get e-signature URL for approved application (neobank only)
     * @summary Get e-signature URL
     * @param {OffersApiGetESignUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApiInterface
     */
    getESignUrl(requestParameters: OffersApiGetESignUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetESignUrl200Response>;

    /**
     * Neobank retrieves all final offers for their application. Returns encrypted offers grouped by lender. 
     * @summary Get final offers
     * @param {OffersApiGetFinalOffersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApiInterface
     */
    getFinalOffers(requestParameters: OffersApiGetFinalOffersRequest, options?: RawAxiosRequestConfig): AxiosPromise<EncryptedOffersResponse>;

    /**
     * Lender retrieves details of a specific offer by ID. Must specify offerType query parameter (prequalified or final). 
     * @summary Get specific offer
     * @param {OffersApiGetLenderOfferByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApiInterface
     */
    getLenderOfferById(requestParameters: OffersApiGetLenderOfferByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<OfferDetailResponse>;

    /**
     * Neobank retrieves all prequalified offers for their application. Returns encrypted offers grouped by lender. 
     * @summary Get prequalified offers
     * @param {OffersApiGetPrequalOffersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApiInterface
     */
    getPrequalOffers(requestParameters: OffersApiGetPrequalOffersRequest, options?: RawAxiosRequestConfig): AxiosPromise<EncryptedOffersResponse>;

    /**
     * Lender retrieves all their offers (prequalified and/or final) with pagination. Supports filtering by offer type, status, and application ID. 
     * @summary List lender\'s offers
     * @param {OffersApiListLenderOffersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApiInterface
     */
    listLenderOffers(requestParameters?: OffersApiListLenderOffersRequest, options?: RawAxiosRequestConfig): AxiosPromise<LenderOffersResponse>;

    /**
     * Lender submits 1-10 final offers after hard pull credit check. All sensitive offer details are encrypted with the neobank\'s public key. Each final offer must reference a previously accepted prequalified offer.  **Workflow:** 1. Lender receives acceptance webhook for prequalified offer 2. Lender performs hard pull credit check 3. Lender creates final offer(s) based on hard pull results 4. Lender encrypts offer details with neobank\'s RSA public key 5. Lender submits encrypted final offers via this endpoint 6. Neobank retrieves and decrypts offers with their private key 
     * @summary Submit final offers
     * @param {OffersApiSubmitFinalOffersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApiInterface
     */
    submitFinalOffers(requestParameters: OffersApiSubmitFinalOffersRequest, options?: RawAxiosRequestConfig): AxiosPromise<OfferSubmissionResponse>;

    /**
     * Lender submits 1-10 prequalified offers for an application (soft pull only). All sensitive offer details are encrypted with the neobank\'s public key.  **Workflow:** 1. Lender performs soft pull credit check 2. Lender encrypts offer details with neobank\'s RSA public key 3. Lender submits encrypted offers via this endpoint 4. Neobank receives webhook notification 5. Neobank retrieves and decrypts offers with their private key 
     * @summary Submit prequalified offers
     * @param {OffersApiSubmitPrequalOffersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApiInterface
     */
    submitPrequalOffers(requestParameters: OffersApiSubmitPrequalOffersRequest, options?: RawAxiosRequestConfig): AxiosPromise<OfferSubmissionResponse>;

}

/**
 * Request parameters for acceptFinalOffer operation in OffersApi.
 * @export
 * @interface OffersApiAcceptFinalOfferRequest
 */
export interface OffersApiAcceptFinalOfferRequest {
    /**
     * Unique identifier for the offer
     * @type {string}
     * @memberof OffersApiAcceptFinalOffer
     */
    readonly offerId: string

    /**
     * 
     * @type {OfferAcceptanceRequest}
     * @memberof OffersApiAcceptFinalOffer
     */
    readonly offerAcceptanceRequest: OfferAcceptanceRequest
}

/**
 * Request parameters for acceptPrequalOffer operation in OffersApi.
 * @export
 * @interface OffersApiAcceptPrequalOfferRequest
 */
export interface OffersApiAcceptPrequalOfferRequest {
    /**
     * Unique identifier for the offer
     * @type {string}
     * @memberof OffersApiAcceptPrequalOffer
     */
    readonly offerId: string

    /**
     * 
     * @type {OfferAcceptanceRequest}
     * @memberof OffersApiAcceptPrequalOffer
     */
    readonly offerAcceptanceRequest: OfferAcceptanceRequest
}

/**
 * Request parameters for confirmESignComplete operation in OffersApi.
 * @export
 * @interface OffersApiConfirmESignCompleteRequest
 */
export interface OffersApiConfirmESignCompleteRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof OffersApiConfirmESignComplete
     */
    readonly applicationId: string

    /**
     * 
     * @type {object}
     * @memberof OffersApiConfirmESignComplete
     */
    readonly body: object
}

/**
 * Request parameters for getESignUrl operation in OffersApi.
 * @export
 * @interface OffersApiGetESignUrlRequest
 */
export interface OffersApiGetESignUrlRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof OffersApiGetESignUrl
     */
    readonly applicationId: string
}

/**
 * Request parameters for getFinalOffers operation in OffersApi.
 * @export
 * @interface OffersApiGetFinalOffersRequest
 */
export interface OffersApiGetFinalOffersRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof OffersApiGetFinalOffers
     */
    readonly applicationId: string
}

/**
 * Request parameters for getLenderOfferById operation in OffersApi.
 * @export
 * @interface OffersApiGetLenderOfferByIdRequest
 */
export interface OffersApiGetLenderOfferByIdRequest {
    /**
     * Unique identifier for the offer
     * @type {string}
     * @memberof OffersApiGetLenderOfferById
     */
    readonly offerId: string

    /**
     * Type of offer
     * @type {'prequalified' | 'final'}
     * @memberof OffersApiGetLenderOfferById
     */
    readonly offerType: GetLenderOfferByIdOfferTypeEnum
}

/**
 * Request parameters for getPrequalOffers operation in OffersApi.
 * @export
 * @interface OffersApiGetPrequalOffersRequest
 */
export interface OffersApiGetPrequalOffersRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof OffersApiGetPrequalOffers
     */
    readonly applicationId: string
}

/**
 * Request parameters for listLenderOffers operation in OffersApi.
 * @export
 * @interface OffersApiListLenderOffersRequest
 */
export interface OffersApiListLenderOffersRequest {
    /**
     * Filter by offer type
     * @type {'prequalified' | 'final' | 'all'}
     * @memberof OffersApiListLenderOffers
     */
    readonly offerType?: ListLenderOffersOfferTypeEnum

    /**
     * Filter by offer status
     * @type {OfferStatus}
     * @memberof OffersApiListLenderOffers
     */
    readonly status?: OfferStatus

    /**
     * Filter by application ID
     * @type {string}
     * @memberof OffersApiListLenderOffers
     */
    readonly applicationId?: string

    /**
     * Page number (1-indexed)
     * @type {number}
     * @memberof OffersApiListLenderOffers
     */
    readonly page?: number

    /**
     * Number of results per page
     * @type {number}
     * @memberof OffersApiListLenderOffers
     */
    readonly limit?: number
}

/**
 * Request parameters for submitFinalOffers operation in OffersApi.
 * @export
 * @interface OffersApiSubmitFinalOffersRequest
 */
export interface OffersApiSubmitFinalOffersRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof OffersApiSubmitFinalOffers
     */
    readonly applicationId: string

    /**
     * 
     * @type {FinalOfferSubmission}
     * @memberof OffersApiSubmitFinalOffers
     */
    readonly finalOfferSubmission: FinalOfferSubmission
}

/**
 * Request parameters for submitPrequalOffers operation in OffersApi.
 * @export
 * @interface OffersApiSubmitPrequalOffersRequest
 */
export interface OffersApiSubmitPrequalOffersRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof OffersApiSubmitPrequalOffers
     */
    readonly applicationId: string

    /**
     * 
     * @type {PrequalOfferSubmission}
     * @memberof OffersApiSubmitPrequalOffers
     */
    readonly prequalOfferSubmission: PrequalOfferSubmission
}

/**
 * OffersApi - object-oriented interface
 * @export
 * @class OffersApi
 * @extends {BaseAPI}
 */
export class OffersApi extends BaseAPI implements OffersApiInterface {
    /**
     * Neobank accepts a final offer (triggers document signing). This triggers: - Status update to ACCEPTED for selected offer - Rejection of all other pending final offers - Webhook notification to winning lender - Document signing workflow initiation 
     * @summary Accept final offer
     * @param {OffersApiAcceptFinalOfferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public acceptFinalOffer(requestParameters: OffersApiAcceptFinalOfferRequest, options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).acceptFinalOffer(requestParameters.offerId, requestParameters.offerAcceptanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Neobank accepts a prequalified offer with hard pull consent. This triggers: - Status update to ACCEPTED for selected offer - Rejection of all other pending prequalified offers - Webhook notification to winning lender (with consent details) - Lender proceeds with hard pull and submits final offer 
     * @summary Accept prequalified offer
     * @param {OffersApiAcceptPrequalOfferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public acceptPrequalOffer(requestParameters: OffersApiAcceptPrequalOfferRequest, options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).acceptPrequalOffer(requestParameters.offerId, requestParameters.offerAcceptanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirm that e-signature has been completed (neobank only)
     * @summary Confirm e-signature completion
     * @param {OffersApiConfirmESignCompleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public confirmESignComplete(requestParameters: OffersApiConfirmESignCompleteRequest, options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).confirmESignComplete(requestParameters.applicationId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get e-signature URL for approved application (neobank only)
     * @summary Get e-signature URL
     * @param {OffersApiGetESignUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public getESignUrl(requestParameters: OffersApiGetESignUrlRequest, options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).getESignUrl(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Neobank retrieves all final offers for their application. Returns encrypted offers grouped by lender. 
     * @summary Get final offers
     * @param {OffersApiGetFinalOffersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public getFinalOffers(requestParameters: OffersApiGetFinalOffersRequest, options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).getFinalOffers(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lender retrieves details of a specific offer by ID. Must specify offerType query parameter (prequalified or final). 
     * @summary Get specific offer
     * @param {OffersApiGetLenderOfferByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public getLenderOfferById(requestParameters: OffersApiGetLenderOfferByIdRequest, options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).getLenderOfferById(requestParameters.offerId, requestParameters.offerType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Neobank retrieves all prequalified offers for their application. Returns encrypted offers grouped by lender. 
     * @summary Get prequalified offers
     * @param {OffersApiGetPrequalOffersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public getPrequalOffers(requestParameters: OffersApiGetPrequalOffersRequest, options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).getPrequalOffers(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lender retrieves all their offers (prequalified and/or final) with pagination. Supports filtering by offer type, status, and application ID. 
     * @summary List lender\'s offers
     * @param {OffersApiListLenderOffersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public listLenderOffers(requestParameters: OffersApiListLenderOffersRequest = {}, options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).listLenderOffers(requestParameters.offerType, requestParameters.status, requestParameters.applicationId, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lender submits 1-10 final offers after hard pull credit check. All sensitive offer details are encrypted with the neobank\'s public key. Each final offer must reference a previously accepted prequalified offer.  **Workflow:** 1. Lender receives acceptance webhook for prequalified offer 2. Lender performs hard pull credit check 3. Lender creates final offer(s) based on hard pull results 4. Lender encrypts offer details with neobank\'s RSA public key 5. Lender submits encrypted final offers via this endpoint 6. Neobank retrieves and decrypts offers with their private key 
     * @summary Submit final offers
     * @param {OffersApiSubmitFinalOffersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public submitFinalOffers(requestParameters: OffersApiSubmitFinalOffersRequest, options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).submitFinalOffers(requestParameters.applicationId, requestParameters.finalOfferSubmission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lender submits 1-10 prequalified offers for an application (soft pull only). All sensitive offer details are encrypted with the neobank\'s public key.  **Workflow:** 1. Lender performs soft pull credit check 2. Lender encrypts offer details with neobank\'s RSA public key 3. Lender submits encrypted offers via this endpoint 4. Neobank receives webhook notification 5. Neobank retrieves and decrypts offers with their private key 
     * @summary Submit prequalified offers
     * @param {OffersApiSubmitPrequalOffersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OffersApi
     */
    public submitPrequalOffers(requestParameters: OffersApiSubmitPrequalOffersRequest, options?: RawAxiosRequestConfig) {
        return OffersApiFp(this.configuration).submitPrequalOffers(requestParameters.applicationId, requestParameters.prequalOfferSubmission, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetLenderOfferByIdOfferTypeEnum = {
    Prequalified: 'prequalified',
    Final: 'final'
} as const;
export type GetLenderOfferByIdOfferTypeEnum = typeof GetLenderOfferByIdOfferTypeEnum[keyof typeof GetLenderOfferByIdOfferTypeEnum];
/**
 * @export
 */
export const ListLenderOffersOfferTypeEnum = {
    Prequalified: 'prequalified',
    Final: 'final',
    All: 'all'
} as const;
export type ListLenderOffersOfferTypeEnum = typeof ListLenderOffersOfferTypeEnum[keyof typeof ListLenderOffersOfferTypeEnum];


/**
 * PlatformApi - axios parameter creator
 * @export
 */
export const PlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get current active platform public key for document encryption. PUBLIC ENDPOINT - No authentication required. Used by lenders to encrypt unsigned documents before SDX upload. 
         * @summary Get platform public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformPublicKey: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/platform/public-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlatformApi - functional programming interface
 * @export
 */
export const PlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * Get current active platform public key for document encryption. PUBLIC ENDPOINT - No authentication required. Used by lenders to encrypt unsigned documents before SDX upload. 
         * @summary Get platform public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatformPublicKey(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPlatformPublicKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatformPublicKey(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlatformApi.getPlatformPublicKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlatformApi - factory interface
 * @export
 */
export const PlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlatformApiFp(configuration)
    return {
        /**
         * Get current active platform public key for document encryption. PUBLIC ENDPOINT - No authentication required. Used by lenders to encrypt unsigned documents before SDX upload. 
         * @summary Get platform public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformPublicKey(options?: RawAxiosRequestConfig): AxiosPromise<GetPlatformPublicKey200Response> {
            return localVarFp.getPlatformPublicKey(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlatformApi - interface
 * @export
 * @interface PlatformApi
 */
export interface PlatformApiInterface {
    /**
     * Get current active platform public key for document encryption. PUBLIC ENDPOINT - No authentication required. Used by lenders to encrypt unsigned documents before SDX upload. 
     * @summary Get platform public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformApiInterface
     */
    getPlatformPublicKey(options?: RawAxiosRequestConfig): AxiosPromise<GetPlatformPublicKey200Response>;

}

/**
 * PlatformApi - object-oriented interface
 * @export
 * @class PlatformApi
 * @extends {BaseAPI}
 */
export class PlatformApi extends BaseAPI implements PlatformApiInterface {
    /**
     * Get current active platform public key for document encryption. PUBLIC ENDPOINT - No authentication required. Used by lenders to encrypt unsigned documents before SDX upload. 
     * @summary Get platform public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformApi
     */
    public getPlatformPublicKey(options?: RawAxiosRequestConfig) {
        return PlatformApiFp(this.configuration).getPlatformPublicKey(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QueueApi - axios parameter creator
 * @export
 */
export const QueueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lender retrieves applications they have declined after hard credit pull. Used for ECOA/Reg B adverse action notice tracking.  Returns applications with: - declinedAt timestamp (for 30-day deadline calculation) - adverseActionDeadline (30 days from decline) - adverseActionOverdue flag (true if > 30 days since decline) - daysSinceDecline count  Lenders should use this endpoint to track which borrowers need adverse action notices sent. 
         * @summary Get declined applications
         * @param {number} [limit] Maximum number of results (1-100)
         * @param {number} [offset] Number of results to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeclinedApplications: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/queue/declined`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lender retrieves applications within the 60-second active window. Applications older than 60 seconds are automatically expired. 
         * @summary Get active application queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lender retrieves statistics about their queue performance, including acceptance rates and average response times. 
         * @summary Get queue statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/queue/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueueApi - functional programming interface
 * @export
 */
export const QueueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueueApiAxiosParamCreator(configuration)
    return {
        /**
         * Lender retrieves applications they have declined after hard credit pull. Used for ECOA/Reg B adverse action notice tracking.  Returns applications with: - declinedAt timestamp (for 30-day deadline calculation) - adverseActionDeadline (30 days from decline) - adverseActionOverdue flag (true if > 30 days since decline) - daysSinceDecline count  Lenders should use this endpoint to track which borrowers need adverse action notices sent. 
         * @summary Get declined applications
         * @param {number} [limit] Maximum number of results (1-100)
         * @param {number} [offset] Number of results to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeclinedApplications(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclinedApplicationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeclinedApplications(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueueApi.getDeclinedApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lender retrieves applications within the 60-second active window. Applications older than 60 seconds are automatically expired. 
         * @summary Get active application queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueue(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueue(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueueApi.getQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lender retrieves statistics about their queue performance, including acceptance rates and average response times. 
         * @summary Get queue statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueueApi.getQueueStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QueueApi - factory interface
 * @export
 */
export const QueueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueueApiFp(configuration)
    return {
        /**
         * Lender retrieves applications they have declined after hard credit pull. Used for ECOA/Reg B adverse action notice tracking.  Returns applications with: - declinedAt timestamp (for 30-day deadline calculation) - adverseActionDeadline (30 days from decline) - adverseActionOverdue flag (true if > 30 days since decline) - daysSinceDecline count  Lenders should use this endpoint to track which borrowers need adverse action notices sent. 
         * @summary Get declined applications
         * @param {QueueApiGetDeclinedApplicationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeclinedApplications(requestParameters: QueueApiGetDeclinedApplicationsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<DeclinedApplicationsResponse> {
            return localVarFp.getDeclinedApplications(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Lender retrieves applications within the 60-second active window. Applications older than 60 seconds are automatically expired. 
         * @summary Get active application queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(options?: RawAxiosRequestConfig): AxiosPromise<QueueResponse> {
            return localVarFp.getQueue(options).then((request) => request(axios, basePath));
        },
        /**
         * Lender retrieves statistics about their queue performance, including acceptance rates and average response times. 
         * @summary Get queue statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStats(options?: RawAxiosRequestConfig): AxiosPromise<QueueStatsResponse> {
            return localVarFp.getQueueStats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueueApi - interface
 * @export
 * @interface QueueApi
 */
export interface QueueApiInterface {
    /**
     * Lender retrieves applications they have declined after hard credit pull. Used for ECOA/Reg B adverse action notice tracking.  Returns applications with: - declinedAt timestamp (for 30-day deadline calculation) - adverseActionDeadline (30 days from decline) - adverseActionOverdue flag (true if > 30 days since decline) - daysSinceDecline count  Lenders should use this endpoint to track which borrowers need adverse action notices sent. 
     * @summary Get declined applications
     * @param {QueueApiGetDeclinedApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApiInterface
     */
    getDeclinedApplications(requestParameters?: QueueApiGetDeclinedApplicationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeclinedApplicationsResponse>;

    /**
     * Lender retrieves applications within the 60-second active window. Applications older than 60 seconds are automatically expired. 
     * @summary Get active application queue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApiInterface
     */
    getQueue(options?: RawAxiosRequestConfig): AxiosPromise<QueueResponse>;

    /**
     * Lender retrieves statistics about their queue performance, including acceptance rates and average response times. 
     * @summary Get queue statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApiInterface
     */
    getQueueStats(options?: RawAxiosRequestConfig): AxiosPromise<QueueStatsResponse>;

}

/**
 * Request parameters for getDeclinedApplications operation in QueueApi.
 * @export
 * @interface QueueApiGetDeclinedApplicationsRequest
 */
export interface QueueApiGetDeclinedApplicationsRequest {
    /**
     * Maximum number of results (1-100)
     * @type {number}
     * @memberof QueueApiGetDeclinedApplications
     */
    readonly limit?: number

    /**
     * Number of results to skip
     * @type {number}
     * @memberof QueueApiGetDeclinedApplications
     */
    readonly offset?: number
}

/**
 * QueueApi - object-oriented interface
 * @export
 * @class QueueApi
 * @extends {BaseAPI}
 */
export class QueueApi extends BaseAPI implements QueueApiInterface {
    /**
     * Lender retrieves applications they have declined after hard credit pull. Used for ECOA/Reg B adverse action notice tracking.  Returns applications with: - declinedAt timestamp (for 30-day deadline calculation) - adverseActionDeadline (30 days from decline) - adverseActionOverdue flag (true if > 30 days since decline) - daysSinceDecline count  Lenders should use this endpoint to track which borrowers need adverse action notices sent. 
     * @summary Get declined applications
     * @param {QueueApiGetDeclinedApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public getDeclinedApplications(requestParameters: QueueApiGetDeclinedApplicationsRequest = {}, options?: RawAxiosRequestConfig) {
        return QueueApiFp(this.configuration).getDeclinedApplications(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lender retrieves applications within the 60-second active window. Applications older than 60 seconds are automatically expired. 
     * @summary Get active application queue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public getQueue(options?: RawAxiosRequestConfig) {
        return QueueApiFp(this.configuration).getQueue(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lender retrieves statistics about their queue performance, including acceptance rates and average response times. 
     * @summary Get queue statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public getQueueStats(options?: RawAxiosRequestConfig) {
        return QueueApiFp(this.configuration).getQueueStats(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SDXApi - axios parameter creator
 * @export
 */
export const SDXApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a JWT token for SDX document operations. Token is valid for 10 minutes. Access is role-based (neobank vs lender permissions). 
         * @summary Generate SDX access token
         * @param {SDXTokenRequest} sDXTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSDXToken: async (sDXTokenRequest: SDXTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDXTokenRequest' is not null or undefined
            assertParamExists('generateSDXToken', 'sDXTokenRequest', sDXTokenRequest)
            const localVarPath = `/sdx-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDXTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lender stores handle for unsigned contracts uploaded to SDX. Documents must already be uploaded to SDX S3. 
         * @summary Store unsigned document handle
         * @param {UnsignedDocumentHandleRequest} unsignedDocumentHandleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeDocumentHandle: async (unsignedDocumentHandleRequest: UnsignedDocumentHandleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'unsignedDocumentHandleRequest' is not null or undefined
            assertParamExists('storeDocumentHandle', 'unsignedDocumentHandleRequest', unsignedDocumentHandleRequest)
            const localVarPath = `/sdx-tokens/document-handle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unsignedDocumentHandleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Neobank stores handle for KYC documents uploaded to SDX. Documents must already be uploaded to SDX S3. 
         * @summary Store KYC document handle
         * @param {KYCHandleRequest} kYCHandleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeKYCHandle: async (kYCHandleRequest: KYCHandleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'kYCHandleRequest' is not null or undefined
            assertParamExists('storeKYCHandle', 'kYCHandleRequest', kYCHandleRequest)
            const localVarPath = `/sdx-tokens/kyc-handle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kYCHandleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SDXApi - functional programming interface
 * @export
 */
export const SDXApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SDXApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a JWT token for SDX document operations. Token is valid for 10 minutes. Access is role-based (neobank vs lender permissions). 
         * @summary Generate SDX access token
         * @param {SDXTokenRequest} sDXTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSDXToken(sDXTokenRequest: SDXTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDXTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSDXToken(sDXTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SDXApi.generateSDXToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lender stores handle for unsigned contracts uploaded to SDX. Documents must already be uploaded to SDX S3. 
         * @summary Store unsigned document handle
         * @param {UnsignedDocumentHandleRequest} unsignedDocumentHandleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeDocumentHandle(unsignedDocumentHandleRequest: UnsignedDocumentHandleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnsignedDocHandleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeDocumentHandle(unsignedDocumentHandleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SDXApi.storeDocumentHandle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Neobank stores handle for KYC documents uploaded to SDX. Documents must already be uploaded to SDX S3. 
         * @summary Store KYC document handle
         * @param {KYCHandleRequest} kYCHandleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeKYCHandle(kYCHandleRequest: KYCHandleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KYCHandleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeKYCHandle(kYCHandleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SDXApi.storeKYCHandle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SDXApi - factory interface
 * @export
 */
export const SDXApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SDXApiFp(configuration)
    return {
        /**
         * Generates a JWT token for SDX document operations. Token is valid for 10 minutes. Access is role-based (neobank vs lender permissions). 
         * @summary Generate SDX access token
         * @param {SDXApiGenerateSDXTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSDXToken(requestParameters: SDXApiGenerateSDXTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<SDXTokenResponse> {
            return localVarFp.generateSDXToken(requestParameters.sDXTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Lender stores handle for unsigned contracts uploaded to SDX. Documents must already be uploaded to SDX S3. 
         * @summary Store unsigned document handle
         * @param {SDXApiStoreDocumentHandleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeDocumentHandle(requestParameters: SDXApiStoreDocumentHandleRequest, options?: RawAxiosRequestConfig): AxiosPromise<UnsignedDocHandleResponse> {
            return localVarFp.storeDocumentHandle(requestParameters.unsignedDocumentHandleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Neobank stores handle for KYC documents uploaded to SDX. Documents must already be uploaded to SDX S3. 
         * @summary Store KYC document handle
         * @param {SDXApiStoreKYCHandleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeKYCHandle(requestParameters: SDXApiStoreKYCHandleRequest, options?: RawAxiosRequestConfig): AxiosPromise<KYCHandleResponse> {
            return localVarFp.storeKYCHandle(requestParameters.kYCHandleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SDXApi - interface
 * @export
 * @interface SDXApi
 */
export interface SDXApiInterface {
    /**
     * Generates a JWT token for SDX document operations. Token is valid for 10 minutes. Access is role-based (neobank vs lender permissions). 
     * @summary Generate SDX access token
     * @param {SDXApiGenerateSDXTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SDXApiInterface
     */
    generateSDXToken(requestParameters: SDXApiGenerateSDXTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<SDXTokenResponse>;

    /**
     * Lender stores handle for unsigned contracts uploaded to SDX. Documents must already be uploaded to SDX S3. 
     * @summary Store unsigned document handle
     * @param {SDXApiStoreDocumentHandleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SDXApiInterface
     */
    storeDocumentHandle(requestParameters: SDXApiStoreDocumentHandleRequest, options?: RawAxiosRequestConfig): AxiosPromise<UnsignedDocHandleResponse>;

    /**
     * Neobank stores handle for KYC documents uploaded to SDX. Documents must already be uploaded to SDX S3. 
     * @summary Store KYC document handle
     * @param {SDXApiStoreKYCHandleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SDXApiInterface
     */
    storeKYCHandle(requestParameters: SDXApiStoreKYCHandleRequest, options?: RawAxiosRequestConfig): AxiosPromise<KYCHandleResponse>;

}

/**
 * Request parameters for generateSDXToken operation in SDXApi.
 * @export
 * @interface SDXApiGenerateSDXTokenRequest
 */
export interface SDXApiGenerateSDXTokenRequest {
    /**
     * 
     * @type {SDXTokenRequest}
     * @memberof SDXApiGenerateSDXToken
     */
    readonly sDXTokenRequest: SDXTokenRequest
}

/**
 * Request parameters for storeDocumentHandle operation in SDXApi.
 * @export
 * @interface SDXApiStoreDocumentHandleRequest
 */
export interface SDXApiStoreDocumentHandleRequest {
    /**
     * 
     * @type {UnsignedDocumentHandleRequest}
     * @memberof SDXApiStoreDocumentHandle
     */
    readonly unsignedDocumentHandleRequest: UnsignedDocumentHandleRequest
}

/**
 * Request parameters for storeKYCHandle operation in SDXApi.
 * @export
 * @interface SDXApiStoreKYCHandleRequest
 */
export interface SDXApiStoreKYCHandleRequest {
    /**
     * 
     * @type {KYCHandleRequest}
     * @memberof SDXApiStoreKYCHandle
     */
    readonly kYCHandleRequest: KYCHandleRequest
}

/**
 * SDXApi - object-oriented interface
 * @export
 * @class SDXApi
 * @extends {BaseAPI}
 */
export class SDXApi extends BaseAPI implements SDXApiInterface {
    /**
     * Generates a JWT token for SDX document operations. Token is valid for 10 minutes. Access is role-based (neobank vs lender permissions). 
     * @summary Generate SDX access token
     * @param {SDXApiGenerateSDXTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SDXApi
     */
    public generateSDXToken(requestParameters: SDXApiGenerateSDXTokenRequest, options?: RawAxiosRequestConfig) {
        return SDXApiFp(this.configuration).generateSDXToken(requestParameters.sDXTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lender stores handle for unsigned contracts uploaded to SDX. Documents must already be uploaded to SDX S3. 
     * @summary Store unsigned document handle
     * @param {SDXApiStoreDocumentHandleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SDXApi
     */
    public storeDocumentHandle(requestParameters: SDXApiStoreDocumentHandleRequest, options?: RawAxiosRequestConfig) {
        return SDXApiFp(this.configuration).storeDocumentHandle(requestParameters.unsignedDocumentHandleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Neobank stores handle for KYC documents uploaded to SDX. Documents must already be uploaded to SDX S3. 
     * @summary Store KYC document handle
     * @param {SDXApiStoreKYCHandleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SDXApi
     */
    public storeKYCHandle(requestParameters: SDXApiStoreKYCHandleRequest, options?: RawAxiosRequestConfig) {
        return SDXApiFp(this.configuration).storeKYCHandle(requestParameters.kYCHandleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SigningApi - axios parameter creator
 * @export
 */
export const SigningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Complete a signing session with dual document handles. Admin only - typically called by the signing service. 
         * @summary Complete signing session
         * @param {string} sessionId 
         * @param {CompleteSigningSessionRequest} completeSigningSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSigningSession: async (sessionId: string, completeSigningSessionRequest: CompleteSigningSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('completeSigningSession', 'sessionId', sessionId)
            // verify required parameter 'completeSigningSessionRequest' is not null or undefined
            assertParamExists('completeSigningSession', 'completeSigningSessionRequest', completeSigningSessionRequest)
            const localVarPath = `/signing-sessions/{sessionId}/complete`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeSigningSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new document signing session (neobank only)
         * @summary Create signing session
         * @param {string} applicationId Unique identifier for the application
         * @param {CreateSigningSessionRequest} createSigningSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSigningSession: async (applicationId: string, createSigningSessionRequest: CreateSigningSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createSigningSession', 'applicationId', applicationId)
            // verify required parameter 'createSigningSessionRequest' is not null or undefined
            assertParamExists('createSigningSession', 'createSigningSessionRequest', createSigningSessionRequest)
            const localVarPath = `/applications/{applicationId}/signing-sessions`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSigningSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get signing session status (returns entity-specific document handle)
         * @summary Get signing session status
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSigningSessionStatus: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getSigningSessionStatus', 'sessionId', sessionId)
            const localVarPath = `/signing-sessions/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all signing sessions for an application. Returns entity-specific document handles based on caller identity. 
         * @summary Get signing sessions for application
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSigningSessionsByApplication: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getSigningSessionsByApplication', 'applicationId', applicationId)
            const localVarPath = `/applications/{applicationId}/signing-sessions`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SigningApi - functional programming interface
 * @export
 */
export const SigningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SigningApiAxiosParamCreator(configuration)
    return {
        /**
         * Complete a signing session with dual document handles. Admin only - typically called by the signing service. 
         * @summary Complete signing session
         * @param {string} sessionId 
         * @param {CompleteSigningSessionRequest} completeSigningSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeSigningSession(sessionId: string, completeSigningSessionRequest: CompleteSigningSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigningSessionCompleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeSigningSession(sessionId, completeSigningSessionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SigningApi.completeSigningSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new document signing session (neobank only)
         * @summary Create signing session
         * @param {string} applicationId Unique identifier for the application
         * @param {CreateSigningSessionRequest} createSigningSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSigningSession(applicationId: string, createSigningSessionRequest: CreateSigningSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigningSessionCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSigningSession(applicationId, createSigningSessionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SigningApi.createSigningSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get signing session status (returns entity-specific document handle)
         * @summary Get signing session status
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSigningSessionStatus(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigningSessionStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSigningSessionStatus(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SigningApi.getSigningSessionStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all signing sessions for an application. Returns entity-specific document handles based on caller identity. 
         * @summary Get signing sessions for application
         * @param {string} applicationId Unique identifier for the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSigningSessionsByApplication(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigningSessionsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSigningSessionsByApplication(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SigningApi.getSigningSessionsByApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SigningApi - factory interface
 * @export
 */
export const SigningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SigningApiFp(configuration)
    return {
        /**
         * Complete a signing session with dual document handles. Admin only - typically called by the signing service. 
         * @summary Complete signing session
         * @param {SigningApiCompleteSigningSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSigningSession(requestParameters: SigningApiCompleteSigningSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<SigningSessionCompleteResponse> {
            return localVarFp.completeSigningSession(requestParameters.sessionId, requestParameters.completeSigningSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new document signing session (neobank only)
         * @summary Create signing session
         * @param {SigningApiCreateSigningSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSigningSession(requestParameters: SigningApiCreateSigningSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<SigningSessionCreateResponse> {
            return localVarFp.createSigningSession(requestParameters.applicationId, requestParameters.createSigningSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get signing session status (returns entity-specific document handle)
         * @summary Get signing session status
         * @param {SigningApiGetSigningSessionStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSigningSessionStatus(requestParameters: SigningApiGetSigningSessionStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<SigningSessionStatusResponse> {
            return localVarFp.getSigningSessionStatus(requestParameters.sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all signing sessions for an application. Returns entity-specific document handles based on caller identity. 
         * @summary Get signing sessions for application
         * @param {SigningApiGetSigningSessionsByApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSigningSessionsByApplication(requestParameters: SigningApiGetSigningSessionsByApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<SigningSessionsListResponse> {
            return localVarFp.getSigningSessionsByApplication(requestParameters.applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SigningApi - interface
 * @export
 * @interface SigningApi
 */
export interface SigningApiInterface {
    /**
     * Complete a signing session with dual document handles. Admin only - typically called by the signing service. 
     * @summary Complete signing session
     * @param {SigningApiCompleteSigningSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningApiInterface
     */
    completeSigningSession(requestParameters: SigningApiCompleteSigningSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<SigningSessionCompleteResponse>;

    /**
     * Create a new document signing session (neobank only)
     * @summary Create signing session
     * @param {SigningApiCreateSigningSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningApiInterface
     */
    createSigningSession(requestParameters: SigningApiCreateSigningSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<SigningSessionCreateResponse>;

    /**
     * Get signing session status (returns entity-specific document handle)
     * @summary Get signing session status
     * @param {SigningApiGetSigningSessionStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningApiInterface
     */
    getSigningSessionStatus(requestParameters: SigningApiGetSigningSessionStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<SigningSessionStatusResponse>;

    /**
     * Get all signing sessions for an application. Returns entity-specific document handles based on caller identity. 
     * @summary Get signing sessions for application
     * @param {SigningApiGetSigningSessionsByApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningApiInterface
     */
    getSigningSessionsByApplication(requestParameters: SigningApiGetSigningSessionsByApplicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<SigningSessionsListResponse>;

}

/**
 * Request parameters for completeSigningSession operation in SigningApi.
 * @export
 * @interface SigningApiCompleteSigningSessionRequest
 */
export interface SigningApiCompleteSigningSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof SigningApiCompleteSigningSession
     */
    readonly sessionId: string

    /**
     * 
     * @type {CompleteSigningSessionRequest}
     * @memberof SigningApiCompleteSigningSession
     */
    readonly completeSigningSessionRequest: CompleteSigningSessionRequest
}

/**
 * Request parameters for createSigningSession operation in SigningApi.
 * @export
 * @interface SigningApiCreateSigningSessionRequest
 */
export interface SigningApiCreateSigningSessionRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof SigningApiCreateSigningSession
     */
    readonly applicationId: string

    /**
     * 
     * @type {CreateSigningSessionRequest}
     * @memberof SigningApiCreateSigningSession
     */
    readonly createSigningSessionRequest: CreateSigningSessionRequest
}

/**
 * Request parameters for getSigningSessionStatus operation in SigningApi.
 * @export
 * @interface SigningApiGetSigningSessionStatusRequest
 */
export interface SigningApiGetSigningSessionStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof SigningApiGetSigningSessionStatus
     */
    readonly sessionId: string
}

/**
 * Request parameters for getSigningSessionsByApplication operation in SigningApi.
 * @export
 * @interface SigningApiGetSigningSessionsByApplicationRequest
 */
export interface SigningApiGetSigningSessionsByApplicationRequest {
    /**
     * Unique identifier for the application
     * @type {string}
     * @memberof SigningApiGetSigningSessionsByApplication
     */
    readonly applicationId: string
}

/**
 * SigningApi - object-oriented interface
 * @export
 * @class SigningApi
 * @extends {BaseAPI}
 */
export class SigningApi extends BaseAPI implements SigningApiInterface {
    /**
     * Complete a signing session with dual document handles. Admin only - typically called by the signing service. 
     * @summary Complete signing session
     * @param {SigningApiCompleteSigningSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningApi
     */
    public completeSigningSession(requestParameters: SigningApiCompleteSigningSessionRequest, options?: RawAxiosRequestConfig) {
        return SigningApiFp(this.configuration).completeSigningSession(requestParameters.sessionId, requestParameters.completeSigningSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new document signing session (neobank only)
     * @summary Create signing session
     * @param {SigningApiCreateSigningSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningApi
     */
    public createSigningSession(requestParameters: SigningApiCreateSigningSessionRequest, options?: RawAxiosRequestConfig) {
        return SigningApiFp(this.configuration).createSigningSession(requestParameters.applicationId, requestParameters.createSigningSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get signing session status (returns entity-specific document handle)
     * @summary Get signing session status
     * @param {SigningApiGetSigningSessionStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningApi
     */
    public getSigningSessionStatus(requestParameters: SigningApiGetSigningSessionStatusRequest, options?: RawAxiosRequestConfig) {
        return SigningApiFp(this.configuration).getSigningSessionStatus(requestParameters.sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all signing sessions for an application. Returns entity-specific document handles based on caller identity. 
     * @summary Get signing sessions for application
     * @param {SigningApiGetSigningSessionsByApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningApi
     */
    public getSigningSessionsByApplication(requestParameters: SigningApiGetSigningSessionsByApplicationRequest, options?: RawAxiosRequestConfig) {
        return SigningApiFp(this.configuration).getSigningSessionsByApplication(requestParameters.applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get detailed information about a specific transfer including current state, amounts, fees, and transaction hashes. Lender-only endpoint. 
         * @summary Get transfer details
         * @param {string} transferId Bridge transfer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (transferId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transferId' is not null or undefined
            assertParamExists('getTransfer', 'transferId', transferId)
            const localVarPath = `/transfers/{transferId}`
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List transfers for the authenticated lender with optional filtering. Returns sweeps, disbursements, and other wallet-to-wallet transfers. Lender-only endpoint. 
         * @summary List transfers
         * @param {ListTransfersStateEnum} [state] Filter by transfer state
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [cursor] Pagination cursor for fetching next page
         * @param {string} [updatedAfter] Filter transfers updated after this ISO 8601 timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers: async (state?: ListTransfersStateEnum, limit?: number, cursor?: string, updatedAfter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updatedAfter'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get detailed information about a specific transfer including current state, amounts, fees, and transaction hashes. Lender-only endpoint. 
         * @summary Get transfer details
         * @param {string} transferId Bridge transfer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(transferId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfer(transferId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.getTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List transfers for the authenticated lender with optional filtering. Returns sweeps, disbursements, and other wallet-to-wallet transfers. Lender-only endpoint. 
         * @summary List transfers
         * @param {ListTransfersStateEnum} [state] Filter by transfer state
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [cursor] Pagination cursor for fetching next page
         * @param {string} [updatedAfter] Filter transfers updated after this ISO 8601 timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransfers(state?: ListTransfersStateEnum, limit?: number, cursor?: string, updatedAfter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransfers(state, limit, cursor, updatedAfter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransfersApi.listTransfers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransfersApiFp(configuration)
    return {
        /**
         * Get detailed information about a specific transfer including current state, amounts, fees, and transaction hashes. Lender-only endpoint. 
         * @summary Get transfer details
         * @param {TransfersApiGetTransferRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(requestParameters: TransfersApiGetTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransferResponse> {
            return localVarFp.getTransfer(requestParameters.transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * List transfers for the authenticated lender with optional filtering. Returns sweeps, disbursements, and other wallet-to-wallet transfers. Lender-only endpoint. 
         * @summary List transfers
         * @param {TransfersApiListTransfersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers(requestParameters: TransfersApiListTransfersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TransferListResponse> {
            return localVarFp.listTransfers(requestParameters.state, requestParameters.limit, requestParameters.cursor, requestParameters.updatedAfter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransfersApi - interface
 * @export
 * @interface TransfersApi
 */
export interface TransfersApiInterface {
    /**
     * Get detailed information about a specific transfer including current state, amounts, fees, and transaction hashes. Lender-only endpoint. 
     * @summary Get transfer details
     * @param {TransfersApiGetTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    getTransfer(requestParameters: TransfersApiGetTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransferResponse>;

    /**
     * List transfers for the authenticated lender with optional filtering. Returns sweeps, disbursements, and other wallet-to-wallet transfers. Lender-only endpoint. 
     * @summary List transfers
     * @param {TransfersApiListTransfersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    listTransfers(requestParameters?: TransfersApiListTransfersRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransferListResponse>;

}

/**
 * Request parameters for getTransfer operation in TransfersApi.
 * @export
 * @interface TransfersApiGetTransferRequest
 */
export interface TransfersApiGetTransferRequest {
    /**
     * Bridge transfer identifier
     * @type {string}
     * @memberof TransfersApiGetTransfer
     */
    readonly transferId: string
}

/**
 * Request parameters for listTransfers operation in TransfersApi.
 * @export
 * @interface TransfersApiListTransfersRequest
 */
export interface TransfersApiListTransfersRequest {
    /**
     * Filter by transfer state
     * @type {'awaiting_funds' | 'funds_received' | 'payment_submitted' | 'payment_processed' | 'canceled' | 'undeliverable' | 'returned' | 'refunded'}
     * @memberof TransfersApiListTransfers
     */
    readonly state?: ListTransfersStateEnum

    /**
     * Maximum number of results to return
     * @type {number}
     * @memberof TransfersApiListTransfers
     */
    readonly limit?: number

    /**
     * Pagination cursor for fetching next page
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly cursor?: string

    /**
     * Filter transfers updated after this ISO 8601 timestamp
     * @type {string}
     * @memberof TransfersApiListTransfers
     */
    readonly updatedAfter?: string
}

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI implements TransfersApiInterface {
    /**
     * Get detailed information about a specific transfer including current state, amounts, fees, and transaction hashes. Lender-only endpoint. 
     * @summary Get transfer details
     * @param {TransfersApiGetTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public getTransfer(requestParameters: TransfersApiGetTransferRequest, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).getTransfer(requestParameters.transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List transfers for the authenticated lender with optional filtering. Returns sweeps, disbursements, and other wallet-to-wallet transfers. Lender-only endpoint. 
     * @summary List transfers
     * @param {TransfersApiListTransfersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public listTransfers(requestParameters: TransfersApiListTransfersRequest = {}, options?: RawAxiosRequestConfig) {
        return TransfersApiFp(this.configuration).listTransfers(requestParameters.state, requestParameters.limit, requestParameters.cursor, requestParameters.updatedAfter, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListTransfersStateEnum = {
    AwaitingFunds: 'awaiting_funds',
    FundsReceived: 'funds_received',
    PaymentSubmitted: 'payment_submitted',
    PaymentProcessed: 'payment_processed',
    Canceled: 'canceled',
    Undeliverable: 'undeliverable',
    Returned: 'returned',
    Refunded: 'refunded'
} as const;
export type ListTransfersStateEnum = typeof ListTransfersStateEnum[keyof typeof ListTransfersStateEnum];


/**
 * TreasuryApi - axios parameter creator
 * @export
 */
export const TreasuryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sweep balances from loan wallets to master treasury wallet. Supports dry-run mode to preview without executing. Lender-only endpoint. 
         * @summary Execute sweep
         * @param {SweepRequest} [sweepRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSweep: async (sweepRequest?: SweepRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/treasury/sweep`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sweepRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all wallets for the authenticated lender: main treasury wallet + per-loan wallets with balances. Includes aggregate totals and infrastructure status. Lender-only endpoint. 
         * @summary Get all wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWallets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/treasury/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Preview sweepable wallets without executing. Returns list of loan wallets with balances and sweepable status. Lender-only endpoint. 
         * @summary Preview sweep
         * @param {string} [minBalance] Minimum balance threshold to be sweepable (default \&quot;0.01\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSweepPreview: async (minBalance?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/treasury/sweep`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (minBalance !== undefined) {
                localVarQueryParameter['minBalance'] = minBalance;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get treasury overview for the authenticated lender. Returns main wallet, virtual accounts, and KYB status. Lender-only endpoint. 
         * @summary Get treasury overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTreasuryOverview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/treasury`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get transaction history for the lender\'s main treasury wallet. Returns deposits and other treasury movements from Bridge. Lender-only endpoint. 
         * @summary Get treasury transaction history
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [cursor] Pagination cursor for fetching next page
         * @param {string} [updatedAfter] Filter transactions updated after this ISO 8601 timestamp
         * @param {string} [updatedBefore] Filter transactions updated before this ISO 8601 timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTreasuryTransactions: async (limit?: number, cursor?: string, updatedAfter?: string, updatedBefore?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/treasury/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-Key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (updatedAfter !== undefined) {
                localVarQueryParameter['updatedAfter'] = (updatedAfter as any instanceof Date) ?
                    (updatedAfter as any).toISOString() :
                    updatedAfter;
            }

            if (updatedBefore !== undefined) {
                localVarQueryParameter['updatedBefore'] = (updatedBefore as any instanceof Date) ?
                    (updatedBefore as any).toISOString() :
                    updatedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TreasuryApi - functional programming interface
 * @export
 */
export const TreasuryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TreasuryApiAxiosParamCreator(configuration)
    return {
        /**
         * Sweep balances from loan wallets to master treasury wallet. Supports dry-run mode to preview without executing. Lender-only endpoint. 
         * @summary Execute sweep
         * @param {SweepRequest} [sweepRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSweep(sweepRequest?: SweepRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SweepResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSweep(sweepRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TreasuryApi.executeSweep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all wallets for the authenticated lender: main treasury wallet + per-loan wallets with balances. Includes aggregate totals and infrastructure status. Lender-only endpoint. 
         * @summary Get all wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllWallets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllWalletsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllWallets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TreasuryApi.getAllWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Preview sweepable wallets without executing. Returns list of loan wallets with balances and sweepable status. Lender-only endpoint. 
         * @summary Preview sweep
         * @param {string} [minBalance] Minimum balance threshold to be sweepable (default \&quot;0.01\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSweepPreview(minBalance?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SweepPreviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSweepPreview(minBalance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TreasuryApi.getSweepPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get treasury overview for the authenticated lender. Returns main wallet, virtual accounts, and KYB status. Lender-only endpoint. 
         * @summary Get treasury overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTreasuryOverview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreasuryOverviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTreasuryOverview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TreasuryApi.getTreasuryOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get transaction history for the lender\'s main treasury wallet. Returns deposits and other treasury movements from Bridge. Lender-only endpoint. 
         * @summary Get treasury transaction history
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [cursor] Pagination cursor for fetching next page
         * @param {string} [updatedAfter] Filter transactions updated after this ISO 8601 timestamp
         * @param {string} [updatedBefore] Filter transactions updated before this ISO 8601 timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTreasuryTransactions(limit?: number, cursor?: string, updatedAfter?: string, updatedBefore?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreasuryTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTreasuryTransactions(limit, cursor, updatedAfter, updatedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TreasuryApi.getTreasuryTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TreasuryApi - factory interface
 * @export
 */
export const TreasuryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TreasuryApiFp(configuration)
    return {
        /**
         * Sweep balances from loan wallets to master treasury wallet. Supports dry-run mode to preview without executing. Lender-only endpoint. 
         * @summary Execute sweep
         * @param {TreasuryApiExecuteSweepRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSweep(requestParameters: TreasuryApiExecuteSweepRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SweepResponse> {
            return localVarFp.executeSweep(requestParameters.sweepRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all wallets for the authenticated lender: main treasury wallet + per-loan wallets with balances. Includes aggregate totals and infrastructure status. Lender-only endpoint. 
         * @summary Get all wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWallets(options?: RawAxiosRequestConfig): AxiosPromise<AllWalletsResponse> {
            return localVarFp.getAllWallets(options).then((request) => request(axios, basePath));
        },
        /**
         * Preview sweepable wallets without executing. Returns list of loan wallets with balances and sweepable status. Lender-only endpoint. 
         * @summary Preview sweep
         * @param {TreasuryApiGetSweepPreviewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSweepPreview(requestParameters: TreasuryApiGetSweepPreviewRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SweepPreviewResponse> {
            return localVarFp.getSweepPreview(requestParameters.minBalance, options).then((request) => request(axios, basePath));
        },
        /**
         * Get treasury overview for the authenticated lender. Returns main wallet, virtual accounts, and KYB status. Lender-only endpoint. 
         * @summary Get treasury overview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTreasuryOverview(options?: RawAxiosRequestConfig): AxiosPromise<TreasuryOverviewResponse> {
            return localVarFp.getTreasuryOverview(options).then((request) => request(axios, basePath));
        },
        /**
         * Get transaction history for the lender\'s main treasury wallet. Returns deposits and other treasury movements from Bridge. Lender-only endpoint. 
         * @summary Get treasury transaction history
         * @param {TreasuryApiGetTreasuryTransactionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTreasuryTransactions(requestParameters: TreasuryApiGetTreasuryTransactionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TreasuryTransactionsResponse> {
            return localVarFp.getTreasuryTransactions(requestParameters.limit, requestParameters.cursor, requestParameters.updatedAfter, requestParameters.updatedBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TreasuryApi - interface
 * @export
 * @interface TreasuryApi
 */
export interface TreasuryApiInterface {
    /**
     * Sweep balances from loan wallets to master treasury wallet. Supports dry-run mode to preview without executing. Lender-only endpoint. 
     * @summary Execute sweep
     * @param {TreasuryApiExecuteSweepRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TreasuryApiInterface
     */
    executeSweep(requestParameters?: TreasuryApiExecuteSweepRequest, options?: RawAxiosRequestConfig): AxiosPromise<SweepResponse>;

    /**
     * Get all wallets for the authenticated lender: main treasury wallet + per-loan wallets with balances. Includes aggregate totals and infrastructure status. Lender-only endpoint. 
     * @summary Get all wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TreasuryApiInterface
     */
    getAllWallets(options?: RawAxiosRequestConfig): AxiosPromise<AllWalletsResponse>;

    /**
     * Preview sweepable wallets without executing. Returns list of loan wallets with balances and sweepable status. Lender-only endpoint. 
     * @summary Preview sweep
     * @param {TreasuryApiGetSweepPreviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TreasuryApiInterface
     */
    getSweepPreview(requestParameters?: TreasuryApiGetSweepPreviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<SweepPreviewResponse>;

    /**
     * Get treasury overview for the authenticated lender. Returns main wallet, virtual accounts, and KYB status. Lender-only endpoint. 
     * @summary Get treasury overview
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TreasuryApiInterface
     */
    getTreasuryOverview(options?: RawAxiosRequestConfig): AxiosPromise<TreasuryOverviewResponse>;

    /**
     * Get transaction history for the lender\'s main treasury wallet. Returns deposits and other treasury movements from Bridge. Lender-only endpoint. 
     * @summary Get treasury transaction history
     * @param {TreasuryApiGetTreasuryTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TreasuryApiInterface
     */
    getTreasuryTransactions(requestParameters?: TreasuryApiGetTreasuryTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<TreasuryTransactionsResponse>;

}

/**
 * Request parameters for executeSweep operation in TreasuryApi.
 * @export
 * @interface TreasuryApiExecuteSweepRequest
 */
export interface TreasuryApiExecuteSweepRequest {
    /**
     * 
     * @type {SweepRequest}
     * @memberof TreasuryApiExecuteSweep
     */
    readonly sweepRequest?: SweepRequest
}

/**
 * Request parameters for getSweepPreview operation in TreasuryApi.
 * @export
 * @interface TreasuryApiGetSweepPreviewRequest
 */
export interface TreasuryApiGetSweepPreviewRequest {
    /**
     * Minimum balance threshold to be sweepable (default \&quot;0.01\&quot;)
     * @type {string}
     * @memberof TreasuryApiGetSweepPreview
     */
    readonly minBalance?: string
}

/**
 * Request parameters for getTreasuryTransactions operation in TreasuryApi.
 * @export
 * @interface TreasuryApiGetTreasuryTransactionsRequest
 */
export interface TreasuryApiGetTreasuryTransactionsRequest {
    /**
     * Maximum number of results to return
     * @type {number}
     * @memberof TreasuryApiGetTreasuryTransactions
     */
    readonly limit?: number

    /**
     * Pagination cursor for fetching next page
     * @type {string}
     * @memberof TreasuryApiGetTreasuryTransactions
     */
    readonly cursor?: string

    /**
     * Filter transactions updated after this ISO 8601 timestamp
     * @type {string}
     * @memberof TreasuryApiGetTreasuryTransactions
     */
    readonly updatedAfter?: string

    /**
     * Filter transactions updated before this ISO 8601 timestamp
     * @type {string}
     * @memberof TreasuryApiGetTreasuryTransactions
     */
    readonly updatedBefore?: string
}

/**
 * TreasuryApi - object-oriented interface
 * @export
 * @class TreasuryApi
 * @extends {BaseAPI}
 */
export class TreasuryApi extends BaseAPI implements TreasuryApiInterface {
    /**
     * Sweep balances from loan wallets to master treasury wallet. Supports dry-run mode to preview without executing. Lender-only endpoint. 
     * @summary Execute sweep
     * @param {TreasuryApiExecuteSweepRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TreasuryApi
     */
    public executeSweep(requestParameters: TreasuryApiExecuteSweepRequest = {}, options?: RawAxiosRequestConfig) {
        return TreasuryApiFp(this.configuration).executeSweep(requestParameters.sweepRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all wallets for the authenticated lender: main treasury wallet + per-loan wallets with balances. Includes aggregate totals and infrastructure status. Lender-only endpoint. 
     * @summary Get all wallets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TreasuryApi
     */
    public getAllWallets(options?: RawAxiosRequestConfig) {
        return TreasuryApiFp(this.configuration).getAllWallets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Preview sweepable wallets without executing. Returns list of loan wallets with balances and sweepable status. Lender-only endpoint. 
     * @summary Preview sweep
     * @param {TreasuryApiGetSweepPreviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TreasuryApi
     */
    public getSweepPreview(requestParameters: TreasuryApiGetSweepPreviewRequest = {}, options?: RawAxiosRequestConfig) {
        return TreasuryApiFp(this.configuration).getSweepPreview(requestParameters.minBalance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get treasury overview for the authenticated lender. Returns main wallet, virtual accounts, and KYB status. Lender-only endpoint. 
     * @summary Get treasury overview
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TreasuryApi
     */
    public getTreasuryOverview(options?: RawAxiosRequestConfig) {
        return TreasuryApiFp(this.configuration).getTreasuryOverview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get transaction history for the lender\'s main treasury wallet. Returns deposits and other treasury movements from Bridge. Lender-only endpoint. 
     * @summary Get treasury transaction history
     * @param {TreasuryApiGetTreasuryTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TreasuryApi
     */
    public getTreasuryTransactions(requestParameters: TreasuryApiGetTreasuryTransactionsRequest = {}, options?: RawAxiosRequestConfig) {
        return TreasuryApiFp(this.configuration).getTreasuryTransactions(requestParameters.limit, requestParameters.cursor, requestParameters.updatedAfter, requestParameters.updatedBefore, options).then((request) => request(this.axios, this.basePath));
    }
}



